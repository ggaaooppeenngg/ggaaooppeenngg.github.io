<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_85tctgPWrqH2EPVuuD5IT6KE-tW8nH0hTISJDMnShg">
  <meta name="baidu-site-verification" content="bb16c5b1fd3302c18e0015bef11eea42">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ggaaooppeenngg.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:type" content="website">
<meta property="og:title" content="ggaaooppeenngg">
<meta property="og:url" content="https://ggaaooppeenngg.github.io/page/5/index.html">
<meta property="og:site_name" content="ggaaooppeenngg">
<meta property="og:description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ggaaooppeenngg">
<meta property="article:tag" content="ggaaooppeenngg,kernel,sysml,golang,python,rust">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ggaaooppeenngg.github.io/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ggaaooppeenngg</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-62096626-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-62096626-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?bb16c5b1fd3302c18e0015bef11eea42"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ggaaooppeenngg</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">为什么计算机科学是无限的但生命是有限的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">136</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">14</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">80</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ggaaooppeenngg</p>
  <div class="site-description" itemprop="description">为什么计算机科学是无限的但生命是有限的</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">136</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ggaaooppeenngg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ggaaooppeenngg" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:peng.gao.dut@gmail.com" title="E-Mail → mailto:peng.gao.dut@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2018/04/30/k8s-%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2018/04/30/k8s-%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/" class="post-title-link" itemprop="url">k8s 基于 kubeadm 的安全配置和高可用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-30 16:03:08" itemprop="dateCreated datePublished" datetime="2018-04-30T16:03:08+08:00">2018-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2018/04/30/k8s-%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2018/04/30/k8s-基于-kubeadm-的安全配置和高可用/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最新的 kubeadm 的设计文档在<a target="_blank" rel="noopener" href="https://github.com/kubernetes/website/blob/master/docs/reference/setup-tools/kubeadm/kubeadm.md">这里</a>，如果把里面设计大概看一遍就能够理解里面的流程了，可以说设计的还是很缜密的，并且大大简化了 k8s 的运维工作。</p>
<h2 id="kubeadm-安全设施"><a href="#kubeadm-安全设施" class="headerlink" title="kubeadm 安全设施"></a>kubeadm 安全设施</h2><p>主要解释 kubeadm init 和 kubeadm join 的过程和实现</p>
<h3 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a>kubeadm init</h3><ol>
<li>首先进行 preflight-checks ，检查系统是否满足初始化的状态。</li>
<li>创建自签名的 CA，并且生成和签发各个 component 的私钥和证书 (/etc/kubernetes/pki)，如果文件已存在就不会再生成了，比如要给 apiserver 添加域名可以重新签发一个证书，然后重启就好了。</li>
<li>写入各个服务的配置文件，以及一个 admin.conf (/etc/kubernetes/)</li>
<li>配置 kubelet 的动态配置加载     (disable by default)</li>
<li>配置静态 pod  (/etc/kubernetes/manifests)</li>
<li>给 master 添加 taint 和 label，让其他 pod 默认不会运行在 master 上</li>
<li>生成用于让其他 kubelet 加入的 token</li>
<li>配置用 token 加入的可以自动确认 CSR（也就是用 CA 自动签 kubelet 的证书）</li>
<li>设置 kube-dns</li>
<li>检查 self-hosting，如果设置了，就把 static pod 转成 daemonset</li>
</ol>
<p>是否使用外部 CA 的条件是，目录下有 CA 证书，但是没有 CA 私钥。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> res, _ := certsphase.UsingExternalCA(i.cfg); !res &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PHASE 1: Generate certificates</span></span><br><span class="line">        <span class="keyword">if</span> err := certsphase.CreatePKIAssets(i.cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PHASE 2: Generate kubeconfig files for the admin and the kubelet</span></span><br><span class="line">        <span class="keyword">if</span> err := kubeconfigphase.CreateInitKubeConfigFiles(kubeConfigDir, i.cfg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[externalca] The file &#x27;ca.key&#x27; was not found, yet all other certificates are present. Using external CA mode - certificates or kubeconfig will not be generated.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的生成 PKI 相关的配置的过程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreatePKIAssets will create and write to disk all PKI assets necessary to establish the control plane.</span></span><br><span class="line"><span class="comment">// If the PKI assets already exists in the target folder, they are used only if evaluated equal; otherwise an error is returned.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreatePKIAssets</span><span class="params">(cfg *kubeadmapi.MasterConfiguration)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">        certActions := []<span class="function"><span class="keyword">func</span><span class="params">(cfg *kubeadmapi.MasterConfiguration)</span></span> <span class="type">error</span>&#123;</span><br><span class="line">                CreateCACertAndKeyFiles,</span><br><span class="line">                CreateAPIServerCertAndKeyFiles,</span><br><span class="line">                CreateAPIServerKubeletClientCertAndKeyFiles,</span><br><span class="line">                CreateEtcdCACertAndKeyFiles,</span><br><span class="line">                CreateEtcdServerCertAndKeyFiles,</span><br><span class="line">                CreateEtcdPeerCertAndKeyFiles,</span><br><span class="line">                CreateEtcdHealthcheckClientCertAndKeyFiles,</span><br><span class="line">                CreateAPIServerEtcdClientCertAndKeyFiles,</span><br><span class="line">                CreateServiceAccountKeyAndPublicKeyFiles,</span><br><span class="line">                CreateFrontProxyCACertAndKeyFiles,</span><br><span class="line">                CreateFrontProxyClientCertAndKeyFiles,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, action := <span class="keyword">range</span> certActions &#123;</span><br><span class="line">                err := action(cfg)</span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> err</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">&quot;[certificates] Valid certificates and keys now exist in %q\n&quot;</span>, cfg.CertificatesDir)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>列表中的函数都是用来生成所有证书和私钥的，主要依靠 <code>k8s.io/kubernetes/cmd/kubeadm/app/phases/certs/pkiutil </code> 来完成。私钥很容易生成，没什么需要特别配置的，主要看 CA 的证书里面配了啥，因为这个跟 k8s 的鉴权有关系。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSelfSignedCACert creates a CA certificate</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSelfSignedCACert</span><span class="params">(cfg Config, key *rsa.PrivateKey)</span></span> (*x509.Certificate, <span class="type">error</span>) &#123;</span><br><span class="line">        now := time.Now()</span><br><span class="line">        tmpl := x509.Certificate&#123;</span><br><span class="line">                SerialNumber: <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">0</span>),</span><br><span class="line">                Subject: pkix.Name&#123;</span><br><span class="line">                        CommonName:   cfg.CommonName,</span><br><span class="line">                        Organization: cfg.Organization,</span><br><span class="line">                &#125;,</span><br><span class="line">                NotBefore:             now.UTC(),</span><br><span class="line">                NotAfter:              now.Add(duration365d * <span class="number">10</span>).UTC(),</span><br><span class="line">                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,</span><br><span class="line">                BasicConstraintsValid: <span class="literal">true</span>,</span><br><span class="line">                IsCA: <span class="literal">true</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        certDERBytes, err := x509.CreateCertificate(cryptorand.Reader, &amp;tmpl, &amp;tmpl, key.Public(), key)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x509.ParseCertificate(certDERBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 <code>openssl x509 -in /etc/kubernetes/pki/ca.crt -text -noout</code> 可以查看 ca 证书里面的内容，和我们看到的配置是一致的。</p>
<img data-src="/zh-CN/2018/04/30/k8s-%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/ca-pic.png" class="" title="[ca]">

<p>然后我们再看一下 apiserver 的私钥和证书是怎么签的，首先把生成的 CA 证书和私钥加载进来，然后生成私钥并且签出自己的证书。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateAPIServerCertAndKeyFiles</span><span class="params">(cfg *kubeadmapi.MasterConfiguration)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">        caCert, caKey, err := loadCertificateAuthority(cfg.CertificatesDir, kubeadmconstants.CACertAndKeyBaseName)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        apiCert, apiKey, err := NewAPIServerCertAndKey(cfg, caCert, caKey)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> writeCertificateFilesIfNotExist(</span><br><span class="line">                cfg.CertificatesDir,</span><br><span class="line">                kubeadmconstants.APIServerCertAndKeyBaseName,</span><br><span class="line">                caCert,</span><br><span class="line">                apiCert,</span><br><span class="line">                apiKey,</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里比较重要，因为 SAN 这个是用来匹配域名的，如果这里没写好，HTTPS 是拒绝访问的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewAPIServerCertAndKey generate certificate for apiserver, signed by the given CA.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAPIServerCertAndKey</span><span class="params">(cfg *kubeadmapi.MasterConfiguration, caCert *x509.Certificate, caKey *rsa.PrivateKey)</span></span> (*x509.Certificate, *rsa.PrivateKey, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">        altNames, err := pkiutil.GetAPIServerAltNames(cfg)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failure while composing altnames for API server: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        config := certutil.Config&#123;</span><br><span class="line">                CommonName: kubeadmconstants.APIServerCertCommonName,</span><br><span class="line">                AltNames:   *altNames,</span><br><span class="line">                Usages:     []x509.ExtKeyUsage&#123;x509.ExtKeyUsageServerAuth&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">        apiCert, apiKey, err := pkiutil.NewCertAndKey(caCert, caKey, config)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failure while creating API server key and certificate: %v&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> apiCert, apiKey, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="/zh-CN/2018/04/30/k8s-%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/api-crt.png" class="" title="[apiserver crt]">

<p>apiserver 的证书也是对的，马赛克的部分是我自己配的一些 IP 和 域名，和 kubeadm 配的一些 kube-dns 用的 overlay 网络上的 master 域名，其他 master 上的 components 也是类似的，在配高可用的时候要把每个 master 节点上的域名和 IP 都配上。kubelet 的证书也要配对，就在 join 里面介绍了，这个会用来鉴权 node 的身份。</p>
<p>其他部分的代码和设计文档的描述是一致的，所以没什么好看的，感觉一个好的设计文档是非常重要的，代码只是设计的实现，如果设计本身就可读性很强，阅读代码只是辅助理解一些细节和找 BUG 用的而已。</p>
<h3 id="kubeadm-join"><a href="#kubeadm-join" class="headerlink" title="kubeadm join"></a>kubeadm join</h3><ol>
<li>首先用 token 鉴权的方式获取 apiserver 的 CA 证书，并且通过 SHA256 验证。</li>
<li>加载动态配置，如果 master 上有的话。</li>
<li>TLS 初始化，首先用 token 鉴权的方式把自己的 CSR 发给 apiserver，然后签发自己的证书，这个证书要用来检查 node 的身份的。</li>
<li>配置 kubelet 和 server 开始建立连接。</li>
</ol>
<p>新版本的 kubelet 有些变动，支持把一些 featuregate 配置写到文件里面，比如这个<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/issues/43783">阻止 fork bomb</a> 的配置，新版本只能用配置文件写了，不能通过参数配置。</p>
<p>kubeadm 的详细过程如下：</p>
<p>首先会把 flags 传入<code> NodeConfiguration</code> 中，开始 <code>AddJoinConfigFlags(cmd.PersistentFlags()</code>，如果没有 <code>nodeNamecfg</code> 默认用 host 的 name 并且小写化通过 <code>GetHostname</code>获得，和在宿主机上执行 <code>hostname</code> 是一致的。在初始化之前先 尝试启动 <code>TryStartKubelet</code> 过程，然后把 token 和 server 写入（证书 data 是怎么生成的？），先配置kubelet-bootstrap-config</p>
<p> 整体流程如下，token 验证是基于 JWT 的，所以 token 的格式是 <code>&quot;^([a-z0-9]&#123;6&#125;)\\.([a-z0-9]&#123;16&#125;)$&quot;</code>，分两部分，<code>tokenID.tokenSecret</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">discovery.For</span><br><span class="line">-&gt;GetValidatedClusterInfoObject 这个是获取 CA 证书的过程</span><br><span class="line">     -&gt;token.RetrieveValidatedClusterInfo 这一步是 JWT 验证</span><br><span class="line">         -&gt;tokenutil.ParseToken   得到 tokenID 和 tokenSecret</span><br><span class="line">         -&gt;pubKeyPins.Allow 加载用于检验 CA 证书的 HASH 值</span><br><span class="line">         -&gt;buildInsecureBootstrapKubeConfig （用 token-bootstrap-client 身份)获取信息</span><br><span class="line">            -&gt; 从kube-public 获取 configmap (和 kubectl describe configmap cluster-info -n kube-public 中的信息是一致的）这个configmap 里面包含 JWS 签名和 master 的 CA 证书，获取对应 tokenID 的 jws token，验证 token 成功，并且验证 CA 的证书 hash，如果通过说明这个 master 是可信的，然后拿到 CA 证书以后开始构建自己的证书，建立 secure config。</span><br><span class="line">         -&gt;</span><br></pre></td></tr></table></figure>

<p>kubeconfigutil.WriteToDisk 会把 <code>bootstrap-kubelet.conf</code> 写入到配置目录中，kubeadm 的任务就完成了，之前的 kubeadm 会代替 kubelet 生成 kubelet.conf（其中用的是公钥鉴权），现在移走了，kubelet 启动的时候会尝试使用这个配置文件建立 HTTPS 的鉴权配置文件。</p>
<img data-src="/zh-CN/2018/04/30/k8s-%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/bootstrap-conf.png" class="" title="[boostrap conf]">

<p>可以看一下 kubelet 用这个配置给 master 发 CSR 以后得到了什么，可以看到是生成了自己的证书的。</p>
<img data-src="/zh-CN/2018/04/30/k8s-%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/kubelet-crt.png" class="" title="[kubelet bootstrap conf]">

<p>并且这个证书里面的 SAN 也是用来进行 Node 鉴权的身份确认的信息。用 <code>openssl x509 -in /var/lib/kubelet/pki/kubelet-client.crt  -text -noout</code>查看信息。</p>
<img data-src="/zh-CN/2018/04/30/k8s-%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/kubelet-https-crt.png" class="" title="[kubelet conf]">

<p>红线部分就是 Node 鉴权的信息，基于这个确认 node 的身份。另外一个是 Role Based Access Control，那个主要是配给 pod，限制 pod 行为用的，类似于 linux 的 <code>chmod</code>。</p>
<h2 id="kubeadm-高可用配置"><a href="#kubeadm-高可用配置" class="headerlink" title="kubeadm 高可用配置"></a>kubeadm 高可用配置</h2><p>如果没有安全配置，其实高可用挺好配置的，现在加入了安全配置，虽然麻烦，但是还是能理解 k8s 的良苦用心的，理解了整个鉴权的过程以后就可以做，现在支持配置文件初始化其实更好配置了。可以基于<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/setup/independent/high-availability/">这个文档配置</a>，算了我还是不总结了，看懂上面的，照着配置就好了。主要是自己生成 CA，他们用的 <code>cfssl</code> 和 <code>cfssljson</code>，这个工具比 openssl 好用一点，比较容易配置。生成 ca 证书和私钥以后，就可以构建 HTTPS 的 etcd。</p>
<p>先创建 ca 的配置文件 <code>ca-config.json</code>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;signing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;expiry&quot;</span><span class="punctuation">:</span> <span class="string">&quot;43800h&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;expiry&quot;</span><span class="punctuation">:</span> <span class="string">&quot;43800h&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;usages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;signing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;key encipherment&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;server auth&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;client auth&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;client&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;expiry&quot;</span><span class="punctuation">:</span> <span class="string">&quot;43800h&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;usages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;signing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;key encipherment&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;client auth&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;peer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;expiry&quot;</span><span class="punctuation">:</span> <span class="string">&quot;43800h&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;usages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;signing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;key encipherment&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;server auth&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;client auth&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后生成用于自签名的 csr 的配置文件 <code>ca-csr.json</code>，用于签发自签名的 CA 证书。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CN&quot;</span><span class="punctuation">:</span> <span class="string">&quot;etcd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;algo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">2048</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果就是目录下面生成了，<code>ca-key.pem</code> 和 <code>ca.pem</code>，这个命令不太按规则，对应的叫 <code>ca.key</code> 和 <code>ca.crt</code>，<code>pem</code> 是密钥保存的格式。</p>
<p>接下来用 <code>client.json</code> 获得自己的私钥和通过 ca 签的证书。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;CN&quot;</span><span class="punctuation">:</span> <span class="string">&quot;client&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;algo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ecdsa&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">256</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=client client.json | cfssljson -bare client</code>，生成了 <code>client-key.pem</code>,<code>client.pem</code>，分别是私钥和证书，把文件 <code>ca.pem</code>,<code>ca-key.pem</code>, <code>client.pem</code>,<code>client-key.pem</code>,<code>ca-config.json</code>, 拷贝到每台 master 机器上面，一般放到 <code>/etc/kubernetes/pki/</code> 下面。</p>
<p>然后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cfssl print-defaults csr &gt; config.json</span><br><span class="line">sed -i &#x27;0,/CN/&#123;s/example\.net/&#x27;&quot;$PEER_NAME&quot;&#x27;/&#125;&#x27; config.json</span><br><span class="line">sed -i &#x27;s/www\.example\.net/&#x27;&quot;$PRIVATE_IP&quot;&#x27;/&#x27; config.json</span><br><span class="line">sed -i &#x27;s/example\.net/&#x27;&quot;$PEER_NAME&quot;&#x27;/&#x27; config.json</span><br><span class="line"></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server config.json | cfssljson -bare server</span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=peer config.json | cfssljson -bare peer</span><br></pre></td></tr></table></figure>

<p>签出出两对密钥和证书，把每台的机器的 域名 和 IP 替换掉示例的 example 配置，就是这些地方可以改成自己的域名和地址，这个会被用来 check。</p>
<img data-src="/zh-CN/2018/04/30/k8s-%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8/etcd-csr.png" class="" title="[etcd csr ]">

<p>可以放到 kubelet 的 static pod 里面，启动 etcd，两个证书分别是用作 server 验证和 client 验证的，server 让别人访问的时候相信你，peer 是你访问别人的时候让别人相信你。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">&gt;/etc/kubernetes/manifests/etcd.yaml</span> <span class="string">&lt;&lt;EOF</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">etcd</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">control-plane</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&lt;podname&gt;</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">etcd</span> <span class="string">--name</span> <span class="string">$&#123;PEER_NAME&#125;</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--data-dir</span> <span class="string">/var/lib/etcd</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--listen-client-urls</span> <span class="string">https://$&#123;PRIVATE_IP&#125;:2379</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--advertise-client-urls</span> <span class="string">https://$&#123;PRIVATE_IP&#125;:2379</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--listen-peer-urls</span> <span class="string">https://$&#123;PRIVATE_IP&#125;:2380</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--initial-advertise-peer-urls</span> <span class="string">https://$&#123;PRIVATE_IP&#125;:2380</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--cert-file=/certs/server.pem</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--key-file=/certs/server-key.pem</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--client-cert-auth</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--trusted-ca-file=/certs/ca.pem</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--peer-cert-file=/certs/peer.pem</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--peer-key-file=/certs/peer-key.pem</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--peer-client-cert-auth</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--peer-trusted-ca-file=/certs/ca.pem</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--initial-cluster</span> <span class="string">etcd0=https://&lt;etcd0-ip-address&gt;:2380,etcd1=https://&lt;etcd1-ip-address&gt;:2380,etcd2=https://&lt;etcd2-ip-address&gt;:2380</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--initial-cluster-token</span> <span class="string">my-etcd-token</span> <span class="string">\</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--initial-cluster-state</span> <span class="string">new</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/etcd-amd64:3.1.10</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">2379</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">    <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">    <span class="attr">timeoutSeconds:</span> <span class="number">15</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">etcd</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PUBLIC_IP</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">fieldRef:</span></span><br><span class="line">        <span class="attr">fieldPath:</span> <span class="string">status.hostIP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PRIVATE_IP</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">fieldRef:</span></span><br><span class="line">        <span class="attr">fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PEER_NAME</span></span><br><span class="line">    <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">fieldRef:</span></span><br><span class="line">        <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">etcd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/certs</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">certs</span></span><br><span class="line"><span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">etcd</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/etc/kubernetes/pki/etcd</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">certs</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>然后每个节点的 master init 的配置文件按照下面这个配置，client.pem 是用来让 etcd 相信 apiserver 的。<code>private-ip</code> 和 <code>load-balancer-ip</code> 都是要写到证书的  SAN 里面的，不然用这些 ip 是访问不了 apiserver 的。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MasterConfiguration</span></span><br><span class="line"><span class="attr">api:</span></span><br><span class="line">  <span class="attr">advertiseAddress:</span> <span class="string">&lt;private-ip&gt;</span></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://&lt;etcd0-ip-address&gt;:2379</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://&lt;etcd1-ip-address&gt;:2379</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://&lt;etcd2-ip-address&gt;:2379</span></span><br><span class="line">  <span class="attr">caFile:</span> <span class="string">/etc/kubernetes/pki/etcd/ca.pem</span></span><br><span class="line">  <span class="attr">certFile:</span> <span class="string">/etc/kubernetes/pki/etcd/client.pem</span></span><br><span class="line">  <span class="attr">keyFile:</span> <span class="string">/etc/kubernetes/pki/etcd/client-key.pem</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">podSubnet:</span> <span class="string">&lt;podCIDR&gt;</span></span><br><span class="line"><span class="attr">apiServerCertSANs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&lt;load-balancer-ip&gt;</span></span><br><span class="line"><span class="attr">apiServerExtraArgs:</span></span><br><span class="line">  <span class="attr">apiserver-count:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>至于怎么做 loadbalance 可以用七层的也可以用四层的，七层把证书配到负载均衡服务上，四层的就不用，自己在裸机器上做可以用 vip + nginx 做一个四层的，也可以把证书放到 nginx 上做七层的，但是在云环境下，都不怎么支持自己配置 vip，需要用云厂商的 lb 服务，这个就看具体提供商的服务怎么配了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2018/04/26/HTTPS-%E7%9A%84%E5%85%AC%E9%92%A5%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2018/04/26/HTTPS-%E7%9A%84%E5%85%AC%E9%92%A5%E4%BD%93%E7%B3%BB/" class="post-title-link" itemprop="url">HTTPS 加密体系</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-26 22:39:00" itemprop="dateCreated datePublished" datetime="2018-04-26T22:39:00+08:00">2018-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/https/" itemprop="url" rel="index"><span itemprop="name">https</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2018/04/26/HTTPS-%E7%9A%84%E5%85%AC%E9%92%A5%E4%BD%93%E7%B3%BB/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2018/04/26/HTTPS-的公钥体系/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先公钥念“gongyue”，而不是公钥，拼音打字打多了就发现得这么读。</p>
<p>HTTPS 是基于 SSL/TLS 的安全 HTTP 协议，其实 HTTPS 主要还是看安全套接字层，在这之上还是一个 HTTP 协议，这里主要总结一下我们现在主流用到的加密体系，比如我们经常看到的 <code>.pem</code>、<code>.crt</code>、<code>.key</code>、<code>.csr</code> 还有 <code>CA</code> 啊之类的是啥东西，并且这些东西都如何工作和应用的。</p>
<p>在密码学里面，有几个角色，类似于中国的甲乙丙丁，一个是 Alice 和 Bob，这是正常通信的两个人，还有一个是 Eve，是信道上具备窃听能力的人，另外一个是 Mallory，这个人可以妨碍网络流量，主动攻击。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>其实最简单的加密算法就是对称加密</p>
<img data-src="/zh-CN/2018/04/26/HTTPS-%E7%9A%84%E5%85%AC%E9%92%A5%E4%BD%93%E7%B3%BB/symmetric-encryption.gif" class="" title="[symmetric encryption]">

<p>Alice 和 Bob 有一个共有的密码，也就是只有两个人拥有，相互传输的密文只能通过这个密钥解开。</p>
<p>首先加密需要基于密钥，凯撒密码可不可以，可以是可以，但是被人知道算法以后，就可以被所有人破解，并且优秀的加密算法应该被人验证，如果不是公开的算法就没有办法验证，当然一些保守的加密方法会不公开，这样其实也很难解密，但是互联网的加密协议很显然是用在千家万户的，所以一定要是经得起推敲的加密算法。</p>
<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><p>分组密码的作用是，一般会用 128 位一个分组，这样加密的好处是即使一个小的变化也会导致输出大量的变化，这样攻击者很难通过出现频率分析加密方式（比如 HTTP 开头都是一样的，所以使用顺序加密，很容易用 HTTP 的通用开头做输入得出加密方法）。但是分组密码的小影响会导致大改变的特性导致攻击者没办法这么做。</p>
<p>（如果攻击者把有的流量都记录下来，等有一天通过方法获得密钥就能解开这些数据了，可能是未来算力提高，或者通过法律手段，斯诺登的加密信箱就是 FBI 让加密邮箱公司强制提供的）</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数其实很熟悉了，解释一下 MAC。</p>
<h3 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h3><p>MAC 是 message authetication code，是密钥的哈希函数，因为普通哈希函数，如果 Mallory 可以直接用假的数据用哈希算出结果发给 Bob，缺少身份验证，MAC 就是带密钥的哈希函数，HMAC 其实就是把密钥和消息组合在一起的协议。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密又叫做公钥加密，对称加密固然好，但是对称密钥在团体中使用的话，大家都要共享，密钥给来给去的很容易出问题。对称加密就没有这个问题，可以方便传播，对称密钥分私钥和公钥，一个用于加密一个用于解密，私钥加密的数据只能用公钥解密。公钥的出现使得密钥可以大范围传播。</p>
<img data-src="/zh-CN/2018/04/26/HTTPS-%E7%9A%84%E5%85%AC%E9%92%A5%E4%BD%93%E7%B3%BB/asymmetric-encryption.gif" class="" title="[symmetric encryption]">

<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名主要验证消息的真实性，对消息进行验证。主要是对消息进行哈希，然后用私钥加密，追加到文档中做身份验证，这样用公钥解的开的话就能证明消息的发送者。</p>
<h2 id="TLS-的具体协议"><a href="#TLS-的具体协议" class="headerlink" title="TLS 的具体协议"></a>TLS 的具体协议</h2><h2 id="PKI-公钥基础设施"><a href="#PKI-公钥基础设施" class="headerlink" title="PKI 公钥基础设施"></a>PKI 公钥基础设施</h2><p>PKI 主要是用来保证公钥的可信，通过中间的权威机构（CA）签发的公钥也就是证书才能被认可是合法的证书。</p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>证书包含了版本、序列号、签名算法、颁发者、有效期、使用者、公钥。证书也有证书链，比如 root CA 可以签发 中间 CA 的证书。根证书一般是跟着操作系统一起造就装好了的，大公司的操作系统和浏览器都有自己的根证书库，自带就在电脑上。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>RSA 是目前最广泛应用的密钥算法，破解 1024 位的 RSA 密钥的成本大约是 1000 万人民币，现在一般用 2048 位的 RSA，基本无解。</p>
<p>其实公钥体系已经很完全了，但是大部分出问题都情况是私钥泄漏，管理自己的私钥非常重要。</p>
<p>1. 不要用 CA 生成的私钥，尽量自己生成。<br>2. 不要用刚开机的机器生成随机数，这台机器获得的外界熵不够多。<br>3. 定期更换私钥<br>4. 不要随意传播私钥<br>5. 安全存储私钥，这个主要是中间 CA 可能要用，普通服务直接换私钥就可以。</p>
<p>下面就用 OpenSSL 进行一些实验。</p>
<p>首先我们生成一个 RSA 密钥，前面提到了最好用 2048 位的，用 AES-128 算法来加密保存，会让你输入密码，这个密钥基于这个密码保存，这个文件的格式叫 <code>PEM</code> 所以如果看到 <code>PEM</code> 格式的文件就知道是私钥了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$openssl genrsa -aes128 -out test.key 2048</span><br><span class="line">Generating RSA private key, 2048 bit long modulus</span><br><span class="line">...+++</span><br><span class="line">.............................+++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line">Enter pass phrase for test.key:</span><br><span class="line">Verifying - Enter pass phrase for test.key:</span><br></pre></td></tr></table></figure>
<p>可以看这个文件，看起来一通乱七八糟的东西，但是根据开头的信息，我们有办法用密码把私钥解析出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$cat test.key</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">Proc-Type: 4,ENCRYPTED</span><br><span class="line">DEK-Info: AES-128-CBC,52551A2438582E22358335433B7BAEE0</span><br><span class="line"></span><br><span class="line">GiVITGQMbkGxzBYestzFNX4KMUgP84A2p49mOBozQWkAol+zU5llumFXrj/bzATq</span><br><span class="line">OiH01+UN7sqKXD+lNwXsvL2bhhWFGe4h80CbCaVhPYnAtNtxU4HNTbAnCFZPmTHg</span><br><span class="line">wC5JCHlJvt6TGIOeOeyTj9qnCeIKd1XJGYypG8syzzaKuNbSwlKN8DrUKGJP/w/8</span><br><span class="line">gCPKT2AA2l53ysxBI6i2jHAxQSs1Y+K1jFrZjgObT3QDN4eqT1Io/waSDAiB8tkl</span><br><span class="line">rW35ZYO0Toe3iJgTOp325v5dvC6mCOvL0QAQWDz7y239l8fAdyDJUO2tSzjXfIii</span><br><span class="line">FM12NaHfw5m+GcT6brqlwbAOL6BSMX8Q+Dj/fdeDoPOF+pKnG4AGW3LPEY6LJgq0</span><br><span class="line">pkExHJ5cl/nEL2Q2H3yekvPjW40XDZfjyQSivwEJGhsmAq3+tfis/7h5f5Rg/2yh</span><br><span class="line">Vb8kkPQTu0SofS1VFkSQN6iJe5A3imjMkacKDoKtafORR1lWu0noaOqr757orcgI</span><br><span class="line">hK847ijdFdwjstycrGBdN1INr0Yx/FnyaPYNR2XZhWD4uQwZ1tMVge5duw8jgHrH</span><br><span class="line">ZwCeBAgfpSynbMy/1GTru1sO2T6qpZj9pfao59jVcN1fka+YKI5oEdxFFc97wcgk</span><br><span class="line">XVX9lVrcPrI0bMyuhje5Vi04HbOxpd4GmtnNPKTwtmMbDsSVVIX+hlFltSBl+0in</span><br><span class="line">PsKlUeBGjAmUapT3x1v7OP5K7K8YvszHMehbctDS2E9bZstCwhnsMog3b+Jxhw40</span><br><span class="line">gXsOc6Vb3kJljkPXu6k7qGGkqzVqUuUMSaWlE87s5Cm4ZyS8c5IPQvmQk4S/1AJP</span><br><span class="line">v5sD3TObRlJAIw0MEItPY4daQBMyIXPr+UXUAKfMoFK8bXG9aNpACKm/pQ1pVMj1</span><br><span class="line">eE0+lzQ1UZUVM0GotBZGce+TtbrU/I/dbhGLA2KKyoohsCSH2yV+wGIMrmmbUiqH</span><br><span class="line">a46FYwJLtFdDZ9m3ZVj1KCMza9/B2ylIetCX98C3/fVd81L3rxpSmbpWvzWYhw+Y</span><br><span class="line">205t8p26WUloAQrkP+kqw0HDsiDeEU2QilvNwtA5qlfd8666rJEJpBg50jM8Sb0R</span><br><span class="line">JYsG8Mc2a9CNpXt5pVi2kHdoRRkiSeGDh9xTnOlvnCc77p4MMlvcC3bqHwGe85ON</span><br><span class="line">0q5xVJMyLwzAXR82X0FunRiiDNBO3Pg6k+UBALmLNrgieet57Jdva90OnkEA0Ihg</span><br><span class="line">sYHHnfsMMJ6EnW4mNov8tdVi7mExK8K+RRe1vu+zAqzx/UuKkjekW0NdzQjHv4Hs</span><br><span class="line">mX/9XzVE2cLG9GLWVojyTS5XUg16NBn7qM3HRQmQoAgXHlfCJUx33xMjTL3glbNH</span><br><span class="line">65jpvG1S7l6U45BGMI3d2eQ0XfiSUHOHh/zHOIGRl7JcHyoK082IzivPbHkrlolv</span><br><span class="line">o1E+4sgpFc09rQYgcW2cb6Nr3H3aYOlC86iPn4Ecxj8M/wznH/JNjjfoKKhmFWcU</span><br><span class="line">EtmrreXjR8QlUCXCHZCA3DOi/MujcPU0qGZkaz+Ttii4NACZoHpedL+XQ9EcXci7</span><br><span class="line">xkFO4NxsezDunpvXNHgkzES+as5lNxSa4wC4tUbC9h4zhgbeiOGBSTL8Aq0MxwX3</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p>解析私钥</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">$openssl rsa -text -in test.key</span><br><span class="line">Enter pass phrase for test.key:</span><br><span class="line">Private-Key: (2048 bit)</span><br><span class="line">modulus:</span><br><span class="line">    00:a0:18:a6:70:ce:65:64:ea:f1:43:30:35:ff:cf:</span><br><span class="line">    b4:5a:8e:20:52:04:84:bf:bf:3a:b4:a7:65:94:a5:</span><br><span class="line">    df:b5:14:09:61:ba:79:8a:43:d1:fe:cc:d9:96:d3:</span><br><span class="line">    81:5b:82:d7:63:e1:e9:6f:30:5e:b0:3f:fe:65:c4:</span><br><span class="line">    e1:d5:b2:e3:ce:ba:fc:7b:5e:b2:83:f0:9f:3f:c2:</span><br><span class="line">    15:39:b4:fa:e7:3c:ff:42:96:e7:a6:7a:29:e1:ba:</span><br><span class="line">    0b:c7:99:aa:ac:07:2a:2b:74:b3:f8:10:8d:0f:91:</span><br><span class="line">    44:a4:fa:48:c1:aa:88:0e:86:ff:c1:da:59:c8:dd:</span><br><span class="line">    32:d5:5b:15:f4:80:3e:2f:d7:d3:92:09:63:54:d0:</span><br><span class="line">    01:46:78:cd:5c:5d:f1:1c:ad:a7:ab:84:5c:86:e1:</span><br><span class="line">    25:69:6d:6c:6c:df:90:5f:af:ca:6f:43:17:50:05:</span><br><span class="line">    b0:77:3d:92:e9:e7:4c:66:c3:58:08:96:60:7a:16:</span><br><span class="line">    02:d3:6f:56:cb:df:41:69:eb:83:f3:28:b7:82:0a:</span><br><span class="line">    c2:c6:b4:a3:6e:f1:2d:7f:ec:ea:87:7b:94:4b:8b:</span><br><span class="line">    b8:e1:72:0d:00:c1:8d:9f:cc:03:32:de:74:6e:26:</span><br><span class="line">    29:0b:4f:f4:41:93:1c:9c:ae:22:41:81:71:b6:9c:</span><br><span class="line">    8c:17:15:63:d5:86:ce:74:b2:99:fb:7f:ff:37:c8:</span><br><span class="line">    03:7b</span><br><span class="line">publicExponent: 65537 (0x10001)</span><br><span class="line">privateExponent:</span><br><span class="line">    1a:ae:40:fe:c7:c6:ea:1c:a5:7c:97:0a:48:c9:aa:</span><br><span class="line">    ba:f4:b8:ba:32:7a:95:22:1f:7c:7f:f1:53:e6:98:</span><br><span class="line">    f3:aa:95:2d:ae:50:17:14:da:68:66:67:54:d5:86:</span><br><span class="line">    d7:63:64:d6:06:8e:4a:b3:7a:f4:50:95:eb:0b:f6:</span><br><span class="line">    bf:10:83:1a:ae:da:e9:0c:8d:1f:a3:f8:46:3d:e8:</span><br><span class="line">    1f:a7:e3:b0:a9:df:b8:8f:41:a7:e2:f0:1b:e8:4f:</span><br><span class="line">    92:42:2f:c9:5f:a0:4d:81:b3:84:81:ed:a0:4c:8b:</span><br><span class="line">    6e:1b:30:08:e6:8c:aa:2f:21:6c:83:21:37:72:75:</span><br><span class="line">    c8:4c:d7:c9:d9:9d:83:87:67:05:4d:6d:28:72:71:</span><br><span class="line">    63:3b:b6:82:f8:42:0f:94:af:f2:b1:d8:c5:d3:3f:</span><br><span class="line">    50:bf:13:61:b2:0b:de:6b:34:42:cd:29:27:04:c9:</span><br><span class="line">    ff:49:14:75:d0:d5:e5:5c:4b:29:a1:95:c3:c5:e5:</span><br><span class="line">    34:46:9e:81:d4:9d:c3:c4:06:c9:96:90:39:90:fb:</span><br><span class="line">    db:06:77:fa:46:73:38:60:0e:e3:40:7b:d0:5d:a0:</span><br><span class="line">    97:0d:6e:0b:39:d6:99:63:a6:ee:67:b7:94:35:e2:</span><br><span class="line">    63:cf:02:a1:eb:0a:f0:50:99:6f:30:ae:6b:ef:1e:</span><br><span class="line">    14:a0:1a:f4:8e:ed:cd:81:bf:3d:2b:9d:b5:9e:b8:</span><br><span class="line">    21</span><br><span class="line">prime1:</span><br><span class="line">    00:cc:ff:e2:f4:39:5d:33:de:96:15:e6:7c:d2:e6:</span><br><span class="line">    a3:56:a9:6a:09:0c:e9:26:94:36:41:92:b9:db:c9:</span><br><span class="line">    09:20:28:9d:bc:c6:76:60:88:93:97:81:16:86:da:</span><br><span class="line">    4d:65:0e:87:ec:ef:15:6d:c9:06:f7:99:12:eb:4a:</span><br><span class="line">    a6:7e:49:9d:1a:68:ca:35:57:5c:4b:2f:32:2e:e4:</span><br><span class="line">    76:87:a5:02:94:27:1a:1f:38:28:58:77:68:2d:5d:</span><br><span class="line">    fa:c2:fd:c4:09:80:e4:eb:14:84:cc:73:06:96:4b:</span><br><span class="line">    08:8e:da:1c:55:38:8d:8c:7f:19:01:fa:54:b3:62:</span><br><span class="line">    d4:cb:4c:df:01:e0:02:d8:c3</span><br><span class="line">prime2:</span><br><span class="line">    00:c7:ec:f1:2b:83:26:d1:35:e3:55:00:3e:a9:7d:</span><br><span class="line">    2e:f0:68:4d:27:77:3f:d5:1c:99:ef:a0:98:3c:fd:</span><br><span class="line">    fd:d7:8f:51:f5:82:e7:8f:37:34:a7:1a:1f:c4:83:</span><br><span class="line">    44:ab:11:62:54:7a:5e:5c:a4:7f:d6:dd:f8:45:3c:</span><br><span class="line">    b6:bc:1e:b5:56:df:60:65:66:aa:43:82:f5:7a:7c:</span><br><span class="line">    72:3b:3d:fe:33:d4:27:b2:c5:9a:07:36:b4:ca:bc:</span><br><span class="line">    1d:a7:7a:5f:9c:1a:75:2b:2c:57:97:5a:b8:a9:de:</span><br><span class="line">    0e:8a:8c:84:ff:51:e9:12:e9:d4:8b:bf:de:5f:98:</span><br><span class="line">    52:9c:08:55:42:e1:70:be:e9</span><br><span class="line">exponent1:</span><br><span class="line">    15:76:dd:7e:90:db:0f:69:48:f1:b6:16:6f:c6:b2:</span><br><span class="line">    67:8a:89:8d:b5:0a:5c:7d:bc:48:95:62:5c:7e:ea:</span><br><span class="line">    33:b1:cd:02:4d:0d:6c:02:20:e2:06:24:23:ae:8b:</span><br><span class="line">    d7:fe:f3:80:7d:70:12:f4:af:84:11:45:07:d9:e3:</span><br><span class="line">    20:e9:f8:47:21:9d:ba:84:11:27:d6:23:3d:01:b2:</span><br><span class="line">    df:75:09:96:15:9a:08:96:ca:b2:a8:9e:01:d2:0b:</span><br><span class="line">    45:8b:68:91:4e:2b:a9:e9:96:16:0a:1d:30:73:5e:</span><br><span class="line">    cc:06:4e:5d:25:f4:bc:37:3a:99:18:6a:f1:f5:71:</span><br><span class="line">    2e:70:38:11:6c:31:20:1d</span><br><span class="line">exponent2:</span><br><span class="line">    00:a6:f0:8f:21:4a:4e:6b:7b:97:ec:2e:5c:24:a2:</span><br><span class="line">    c7:43:2f:94:dd:53:92:15:9d:e0:5c:5b:b9:43:94:</span><br><span class="line">    c3:15:f0:32:fb:d2:e7:10:8b:84:87:d4:24:9a:af:</span><br><span class="line">    11:f3:d6:7c:49:16:35:1d:1e:af:30:f8:00:8b:af:</span><br><span class="line">    fa:d6:72:bd:f1:60:6c:d9:bf:34:85:53:21:2f:ba:</span><br><span class="line">    22:98:9d:57:5a:67:d9:0e:4a:3a:27:b3:e2:9b:37:</span><br><span class="line">    21:7b:eb:8f:52:86:35:38:6b:ba:68:43:f4:d6:c2:</span><br><span class="line">    f9:59:6f:a4:ce:9d:d3:05:5c:03:82:fe:1f:ed:aa:</span><br><span class="line">    ff:b0:12:b5:3f:37:88:31:a1</span><br><span class="line">coefficient:</span><br><span class="line">    09:97:9e:dc:20:fe:c5:e2:34:47:d8:64:de:bb:ad:</span><br><span class="line">    70:65:4d:08:49:c8:cf:28:40:f6:87:43:09:c9:63:</span><br><span class="line">    bc:d8:cd:11:53:78:ba:ad:1a:f0:8b:e7:fa:1c:5f:</span><br><span class="line">    c9:9d:5f:ae:e1:2a:7f:87:7a:7f:1a:e3:c8:b5:8d:</span><br><span class="line">    eb:b2:af:18:c6:1e:07:43:f0:e7:be:4e:bc:c6:1b:</span><br><span class="line">    77:b8:43:36:58:3a:b5:8a:2c:f7:76:37:c7:97:4c:</span><br><span class="line">    8c:fd:47:71:09:f8:76:fe:8d:0f:e1:3a:30:56:5c:</span><br><span class="line">    2b:70:60:9d:fa:53:74:8a:db:b9:04:78:ce:1c:1d:</span><br><span class="line">    28:ca:78:81:53:07:de:5e</span><br><span class="line">writing RSA key</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIIEowIBAAKCAQEAoBimcM5lZOrxQzA1/8+0Wo4gUgSEv786tKdllKXftRQJYbp5</span><br><span class="line">ikPR/szZltOBW4LXY+HpbzBesD/+ZcTh1bLjzrr8e16yg/CfP8IVObT65zz/Qpbn</span><br><span class="line">pnop4boLx5mqrAcqK3Sz+BCND5FEpPpIwaqIDob/wdpZyN0y1VsV9IA+L9fTkglj</span><br><span class="line">VNABRnjNXF3xHK2nq4RchuElaW1sbN+QX6/Kb0MXUAWwdz2S6edMZsNYCJZgehYC</span><br><span class="line">029Wy99BaeuD8yi3ggrCxrSjbvEtf+zqh3uUS4u44XINAMGNn8wDMt50biYpC0/0</span><br><span class="line">QZMcnK4iQYFxtpyMFxVj1YbOdLKZ+3//N8gDewIDAQABAoIBABquQP7HxuocpXyX</span><br><span class="line">CkjJqrr0uLoyepUiH3x/8VPmmPOqlS2uUBcU2mhmZ1TVhtdjZNYGjkqzevRQlesL</span><br><span class="line">9r8Qgxqu2ukMjR+j+EY96B+n47Cp37iPQafi8BvoT5JCL8lfoE2Bs4SB7aBMi24b</span><br><span class="line">MAjmjKovIWyDITdydchM18nZnYOHZwVNbShycWM7toL4Qg+Ur/Kx2MXTP1C/E2Gy</span><br><span class="line">C95rNELNKScEyf9JFHXQ1eVcSymhlcPF5TRGnoHUncPEBsmWkDmQ+9sGd/pGczhg</span><br><span class="line">DuNAe9BdoJcNbgs51pljpu5nt5Q14mPPAqHrCvBQmW8wrmvvHhSgGvSO7c2Bvz0r</span><br><span class="line">nbWeuCECgYEAzP/i9DldM96WFeZ80uajVqlqCQzpJpQ2QZK528kJICidvMZ2YIiT</span><br><span class="line">l4EWhtpNZQ6H7O8VbckG95kS60qmfkmdGmjKNVdcSy8yLuR2h6UClCcaHzgoWHdo</span><br><span class="line">LV36wv3ECYDk6xSEzHMGlksIjtocVTiNjH8ZAfpUs2LUy0zfAeAC2MMCgYEAx+zx</span><br><span class="line">K4Mm0TXjVQA+qX0u8GhNJ3c/1RyZ76CYPP39149R9YLnjzc0pxofxINEqxFiVHpe</span><br><span class="line">XKR/1t34RTy2vB61Vt9gZWaqQ4L1enxyOz3+M9QnssWaBza0yrwdp3pfnBp1KyxX</span><br><span class="line">l1q4qd4OioyE/1HpEunUi7/eX5hSnAhVQuFwvukCgYAVdt1+kNsPaUjxthZvxrJn</span><br><span class="line">iomNtQpcfbxIlWJcfuozsc0CTQ1sAiDiBiQjrovX/vOAfXAS9K+EEUUH2eMg6fhH</span><br><span class="line">IZ26hBEn1iM9AbLfdQmWFZoIlsqyqJ4B0gtFi2iRTiup6ZYWCh0wc17MBk5dJfS8</span><br><span class="line">NzqZGGrx9XEucDgRbDEgHQKBgQCm8I8hSk5re5fsLlwkosdDL5TdU5IVneBcW7lD</span><br><span class="line">lMMV8DL70ucQi4SH1CSarxHz1nxJFjUdHq8w+ACLr/rWcr3xYGzZvzSFUyEvuiKY</span><br><span class="line">nVdaZ9kOSjons+KbNyF7649ShjU4a7poQ/TWwvlZb6TOndMFXAOC/h/tqv+wErU/</span><br><span class="line">N4gxoQKBgAmXntwg/sXiNEfYZN67rXBlTQhJyM8oQPaHQwnJY7zYzRFTeLqtGvCL</span><br><span class="line">5/ocX8mdX67hKn+Hen8a48i1jeuyrxjGHgdD8Oe+TrzGG3e4QzZYOrWKLPd2N8eX</span><br><span class="line">TIz9R3EJ+Hb+jQ/hOjBWXCtwYJ36U3SK27kEeM4cHSjKeIFTB95e</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p>这个私钥是我自己生成的，没用来干什么，所以直接展示了，但是生产环境的私钥要妥善保管，现在我们生成共钥，输入密码，读取密钥，然后 <code>-pubout</code> 表示生成公钥。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$openssl rsa -in test.key -pubout -out test-public.key</span><br><span class="line">Enter pass phrase for test.key:</span><br><span class="line">writing RSA key</span><br><span class="line">$cat test-public.key</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoBimcM5lZOrxQzA1/8+0</span><br><span class="line">Wo4gUgSEv786tKdllKXftRQJYbp5ikPR/szZltOBW4LXY+HpbzBesD/+ZcTh1bLj</span><br><span class="line">zrr8e16yg/CfP8IVObT65zz/Qpbnpnop4boLx5mqrAcqK3Sz+BCND5FEpPpIwaqI</span><br><span class="line">Dob/wdpZyN0y1VsV9IA+L9fTkgljVNABRnjNXF3xHK2nq4RchuElaW1sbN+QX6/K</span><br><span class="line">b0MXUAWwdz2S6edMZsNYCJZgehYC029Wy99BaeuD8yi3ggrCxrSjbvEtf+zqh3uU</span><br><span class="line">S4u44XINAMGNn8wDMt50biYpC0/0QZMcnK4iQYFxtpyMFxVj1YbOdLKZ+3//N8gD</span><br><span class="line">ewIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>
<p>创建证书需要发起 CSR(certificate signing request)，到 CA 那里，这个 csr 包含了申请者的信息和申请者的公钥。下面就是创建 csr 的命令，其中比较重要的是要配置好 Common Name，这个会拿来和访问的 host 进行匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$openssl req -new -key test.key -out test.csr</span><br><span class="line">Enter pass phrase for test.key:</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &#x27;.&#x27;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) []:CN</span><br><span class="line">State or Province Name (full name) []:SH</span><br><span class="line">Locality Name (eg, city) []:SH</span><br><span class="line">Organization Name (eg, company) []:.</span><br><span class="line">Organizational Unit Name (eg, section) []:.</span><br><span class="line">Common Name (eg, fully qualified host name) []:www.example.com</span><br><span class="line">Email Address []:</span><br><span class="line"></span><br><span class="line">Please enter the following &#x27;extra&#x27; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:1234</span><br></pre></td></tr></table></figure>
<p>可以查看里面的信息是否正确，req 表示处理 csr 文件，-text 一般是用于展示文件内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$openssl req -text -in test.csr -noout</span><br><span class="line">Certificate Request:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 0 (0x0)</span><br><span class="line">        Subject: C=CN, ST=SH, L=SH, CN=www.example.com</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:a0:18:a6:70:ce:65:64:ea:f1:43:30:35:ff:cf:</span><br><span class="line">                    b4:5a:8e:20:52:04:84:bf:bf:3a:b4:a7:65:94:a5:</span><br><span class="line">                    df:b5:14:09:61:ba:79:8a:43:d1:fe:cc:d9:96:d3:</span><br><span class="line">                    81:5b:82:d7:63:e1:e9:6f:30:5e:b0:3f:fe:65:c4:</span><br><span class="line">                    e1:d5:b2:e3:ce:ba:fc:7b:5e:b2:83:f0:9f:3f:c2:</span><br><span class="line">                    15:39:b4:fa:e7:3c:ff:42:96:e7:a6:7a:29:e1:ba:</span><br><span class="line">                    0b:c7:99:aa:ac:07:2a:2b:74:b3:f8:10:8d:0f:91:</span><br><span class="line">                    44:a4:fa:48:c1:aa:88:0e:86:ff:c1:da:59:c8:dd:</span><br><span class="line">                    32:d5:5b:15:f4:80:3e:2f:d7:d3:92:09:63:54:d0:</span><br><span class="line">                    01:46:78:cd:5c:5d:f1:1c:ad:a7:ab:84:5c:86:e1:</span><br><span class="line">                    25:69:6d:6c:6c:df:90:5f:af:ca:6f:43:17:50:05:</span><br><span class="line">                    b0:77:3d:92:e9:e7:4c:66:c3:58:08:96:60:7a:16:</span><br><span class="line">                    02:d3:6f:56:cb:df:41:69:eb:83:f3:28:b7:82:0a:</span><br><span class="line">                    c2:c6:b4:a3:6e:f1:2d:7f:ec:ea:87:7b:94:4b:8b:</span><br><span class="line">                    b8:e1:72:0d:00:c1:8d:9f:cc:03:32:de:74:6e:26:</span><br><span class="line">                    29:0b:4f:f4:41:93:1c:9c:ae:22:41:81:71:b6:9c:</span><br><span class="line">                    8c:17:15:63:d5:86:ce:74:b2:99:fb:7f:ff:37:c8:</span><br><span class="line">                    03:7b</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        Attributes:</span><br><span class="line">            challengePassword        :unable to print attribute</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         33:83:fa:d3:a1:7d:1b:5c:cc:cb:b1:19:99:79:e4:b8:29:fc:</span><br><span class="line">         0e:ac:e6:40:f5:13:f0:d7:f7:2b:67:d4:32:39:78:3f:0b:f0:</span><br><span class="line">         5e:2c:f4:5c:c1:14:f0:f7:82:5d:1e:c5:bf:00:3e:87:d2:b5:</span><br><span class="line">         ed:a7:46:75:70:da:db:53:f1:19:37:15:63:09:63:a8:4d:74:</span><br><span class="line">         19:ed:c5:3a:50:7b:db:5a:68:f0:88:37:54:23:0d:bb:4d:c3:</span><br><span class="line">         b6:1a:3f:1d:93:24:17:f3:c5:66:c8:9c:43:67:e8:3b:cc:48:</span><br><span class="line">         20:8e:9e:da:a6:a0:48:90:6d:b1:bc:ff:0d:39:62:7b:8c:5c:</span><br><span class="line">         cb:ec:ce:e1:de:0c:f3:5b:51:3e:5c:ab:ad:6f:f5:96:9c:e5:</span><br><span class="line">         12:9e:1b:a7:27:90:fe:d3:9f:f9:c2:9d:7e:b5:62:ac:f9:45:</span><br><span class="line">         33:6a:a7:b5:c2:ab:b7:18:a8:a6:91:15:26:27:a4:c9:84:26:</span><br><span class="line">         88:85:3e:68:99:8c:f4:c6:32:8d:61:71:83:cb:86:96:92:2e:</span><br><span class="line">         c7:bc:76:e0:59:82:e8:fe:47:39:da:f0:57:72:f7:59:c4:ba:</span><br><span class="line">         7a:51:23:13:bc:8c:75:07:d7:2d:cf:2b:69:07:20:80:27:6d:</span><br><span class="line">         6d:ae:cb:27:5d:ef:0c:92:99:a4:02:45:5b:58:ac:e9:71:1e:</span><br><span class="line">         ee:5f:54:78</span><br></pre></td></tr></table></figure>
<p>可以看到里面的信息，还有签名算法，以及公钥等等。</p>
<p>我们可以用自己的私钥给自己签名，比如 x509 是证书的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$openssl x509 -req -days 365 -in test.csr -signkey test.key -out test.crt</span><br><span class="line">Signature ok</span><br><span class="line">subject=/C=CN/ST=SH/L=SH/CN=www.example.com</span><br><span class="line">Getting Private key</span><br><span class="line">Enter pass phrase for test.key:</span><br></pre></td></tr></table></figure>
<p>也可以把两步结合起来，直接创建自签名的证书，<code>openssl req -new -x509 -days 365 -key test.key -out test.crt</code>，如果不想要交互式的可以直接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 365 -key test.key -out test.crt \</span><br><span class="line">-subj &quot;/C=CN/L=BJ/O=HaiDian/CN=www.example.com&quot;</span><br></pre></td></tr></table></figure>
<p>CN 只能写一个，虽然可以写泛域名，但是要支持多个域名可以通过扩展字段 SAN（Subject Alternative Name)来解决。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2018/04/21/CUDA-%E7%9A%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2018/04/21/CUDA-%E7%9A%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">CUDA 的计算模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-21 18:20:28" itemprop="dateCreated datePublished" datetime="2018-04-21T18:20:28+08:00">2018-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2018/04/21/CUDA-%E7%9A%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2018/04/21/CUDA-的计算模型/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="我的一点观点"><a href="#我的一点观点" class="headerlink" title="我的一点观点"></a>我的一点观点</h2><p>我个人觉得 nvidia 的 CUDA 太封闭了，不是很能明白这样封闭的产品怎么能够长久生存，仅仅是因为家大业大么，如果有家公司推出了八成性能的 GPU，但是整套开发的生态非常友好，是不是会像 Android 取代诺基亚一样，还是 nvidia 就是苹果，就算封闭环境也能保证强劲体验，这我也不好说了。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>CUDA+cudnn 装起来挺麻烦的，反正如果有错误的话，可以检查 CUDA samples 里面的 deviceQuery 是否成功，如果不成功可以用 strace 看一下少了什么东西，再想办法安装上去。检查 cudnn samples 是否成功也是一样的，里面有一个 mnistDNN 的例子。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">__global__ void helloFromGPU (void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Hello world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Hello World! from CPU\n&quot;);</span><br><span class="line"></span><br><span class="line">	helloFromGPU &lt;&lt;&lt;1, 10&gt;&gt;&gt;();</span><br><span class="line">	cudaDeviceReset();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是一段 GPU 的 Hello world，执行下面的代码可以看到我们在 GPU 上并行执行了十个 “Hello world!” 的打印。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvcc -<span class="built_in">arch</span> sm_20 hello.cu -o hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello</span></span><br><span class="line">Hello World! from CPU</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>
<h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2><p>CUDA 全称 Compute Unified Device Architecure，用于定义 GPU 的架构标准。GPU 的工作方式主要依赖于多核心的并行计算，CUDA 提供了方便的模型进行这种模式的编程，下面就会简单介绍一下 CUDA 的架构以及基于 GPU 的编程。</p>
<p>CUDA 一次启动的线程称为网格(grid)，网格中包含块，每个块包含新程，是一个二维的模式，这张图片就说明得很清晰，首先是由 Grid 组成，然后每个 Block 有 shared memory，同 block 的线程可以访问 shared memory，不同的 Block 的线程只能访问全局的内存，这种结构也方便设计和实现并行算法。</p>
<p><img data-src="https://www.researchgate.net/profile/Marco_Nobile/publication/261069154/figure/fig1/AS:296718735298563@1447754667270/Schematization-of-CUDA-architecture-Schematic-representation-of-CUDA-threads-and-memory.png" alt="cuda-arch"></p>
<p>CUDA 的编译器 nvcc 是 gcc 的一个扩展，支持编写运行在 GPU 上的函数，其中的，<code>&lt;&lt;x, y&gt;&gt;</code> 扩展就是用来指定 block 和 thread 的数量的。</p>
<p>比如典型的俩个向量相加的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sumArrayOnHost</span><span class="params">(<span class="type">float</span> *A, <span class="type">float</span> *B, <span class="type">float</span> *C, <span class="type">const</span> <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        C[i] = A[i] + B[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 GPU 的核函数怎么写呢，是这样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">sumArrayOnGPU</span><span class="params">(<span class="type">float</span> *A, <span class="type">float</span> *N, <span class="type">float</span> C)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = threadIdx.x</span><br><span class="line">    C[i] = A[i] + B[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，如果 N 是 32 的话，可以如下调用，<code>__global__</code> 表示这个函数可以在 host 调用也可以在 GPU 上调用，用个 32 个线程的 block 算这个向量和，N 隐性包含在了定义中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sumArrayOnGPU&lt;&lt;<span class="number">1</span>, <span class="number">32</span>&gt;&gt;(<span class="type">float</span> *A, <span class="type">float</span> *B, <span class="type">float</span> *C)</span><br></pre></td></tr></table></figure>

<h2 id="线程组织"><a href="#线程组织" class="headerlink" title="线程组织"></a>线程组织</h2><p>基于 CPU 和 GPU 的异构计算平台可以优势互补，CPU 负责处理逻辑复杂的串行程序，而 GPU 重点处理数据密集型的并行计算程序，从而发挥最大功效。</p>
<p>线程组织主要依据网格（现在网络这个词其实比较容易混淆，可以是神经网络可以是计算机网络，这里指的是线程的组织形式）模型。主要分 grid, block, thread，组织的方式就靠索引来决定，可以通过 block 索引和 thread 索引进行线程的定位。CUDA 提供了块内线程同步的方法，但是没有提供块间同步的原语。</p>
<h3 id="线程束分化"><a href="#线程束分化" class="headerlink" title="线程束分化"></a>线程束分化</h3><p>线程束 = warp</p>
<p>CPU 有很强的分支预测的能力，会预加载指令，如果预测正确，执行代价就很小，但是 GPU 在这方面是很弱的，因为线程束当中如果执行分支出现不同，那出现分支的线程就会被禁止执行，这也是用 GPU 做并行编程的时候需要参考的一个很重要的因素，保证并行的线程出现线程束分化的情况尽量少。</p>
<p>下面就是线程束分化的例子。</p>
<p><img data-src="http://15418.courses.cs.cmu.edu/spring2013content/lectures/02_basicarch/images/slide_030.png"></p>
<h3 id="并行归约问题"><a href="#并行归约问题" class="headerlink" title="并行归约问题"></a>并行归约问题</h3><p>并行归约是指如何对并行问题进行归约，比如说相邻配对和交错配对。</p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>管理 GPU 主要是通过 CUDA API 或者 <code>nvidia-smi</code> 命令来获取。</p>
<h2 id="SM（流式多处理器）"><a href="#SM（流式多处理器）" class="headerlink" title="SM（流式多处理器）"></a>SM（流式多处理器）</h2><p>上面讲的是抽象上的分层，但是实际的物理层面承载 GPU 的是 SM。最早的 GPU 架构叫 Fermi，然后是 Kepler，然后才是 Tesla。一般说的 <code>cm_20</code>, <code>sm_20</code> 就指这种计算能力和架构，新款的 GPU 计算能力要更强一点。</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>CUDA 的内存模型和 CPU 是类似的也是多级的结构。线程有局部内存，块之间有全局内存。GPU 和 CPU 都是主要采用 DRAM 来做主存，CPU 的一级缓存会用 SRAM 做。CPU 的多级缓存对用户来说不是很需要考虑，尽量屏蔽了其中的细节，但是 GPU 相对来说会把这种分级结构暴露给用户，这对编程来说也是一种新的挑战。</p>
<h2 id="后面"><a href="#后面" class="headerlink" title="后面"></a>后面</h2><p>用 GPU 计算一些计算密集型的程序，速度是真快，比 CPU 块很多，所以这也是为什么大量深度学习的应用都要通过 GPU 加速的原因。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2018/01/03/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2018/01/03/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/" class="post-title-link" itemprop="url">裸写反向误差传播</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-03 20:32:04" itemprop="dateCreated datePublished" datetime="2018-01-03T20:32:04+08:00">2018-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2018/01/03/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2018/01/03/从零实现反向误差传播/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文通过裸写神经网络的方法，帮助理解神经网络的工作方式，直接在 <a target="_blank" rel="noopener" href="https://www.kesci.com/apps/home/project/5a4a334225c4185a1b990d7e">klab</a> 上查看就可以。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/12/19/kube-dns-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/12/19/kube-dns-service/" class="post-title-link" itemprop="url">kube-dns service</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-19 22:28:28" itemprop="dateCreated datePublished" datetime="2017-12-19T22:28:28+08:00">2017-12-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/12/19/kube-dns-service/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/12/19/kube-dns-service/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>kube-dns 是 kubernetes 基于 DNS 的服务发现模块，主要由三个容器组成，分别是 dnsmasq, kube-dns, sidecar，整体的结构如图。</p>
<img data-src="/zh-CN/2017/12/19/kube-dns-service/kube-dns-infra.png" class="">

<h2 id="sidecar"><a href="#sidecar" class="headerlink" title="sidecar"></a>sidecar</h2><p>sidecar 是一个监控健康模块，同时向外暴露metrics 记录，但是为啥叫三蹦子不知道。</p>
<p>接受的探测参数是</p>
<p><code>--probe=&lt;label&gt;,&lt;server&gt;,&lt;dnsname&gt;[,&lt;interval_seconds&gt;][,&lt;type&gt;]</code></p>
<p>例子如下</p>
<p><code>--probe=dnsmasq,127.0.0.1:53,kubernetes.default.svc.cluster.local,5,A</code></p>
<p>等于是每隔 5s 向127.0.0.1:53 进行 DNS 查询 kubernetes.default.svc.cluster.local 的 A 记录</p>
<p>对应的结构体是</p>
<img data-src="/zh-CN/2017/12/19/kube-dns-service/dns-probe-option.png" class="">

<h2 id="dnsmasq"><a href="#dnsmasq" class="headerlink" title="dnsmasq"></a>dnsmasq</h2><p>dnsmasq-nanny 是 dnsmasq 的保姆进程，<a target="_blank" rel="noopener" href="http://www.thekelleys.org.uk/dnsmasq/doc.html">dnsmasq</a> 是一个简易的 DNS server。</p>
<p>dnsmasq-nanny “–” 后面是 dnsmasq 的参数，比如下面这个参数表示的是把 <code>server=/cluster.local/127.0.0.1#10053</code> 当作 dnsmasq 的配置，10053 是 kube-dns 的地址，也就是把 cluster.local 的域名拦截转到 kube-dns 进行解析，剩下的通过正常的域名解析流程。</p>
<p><code>--server=/cluster.local/127.0.0.1#10053</code></p>
<p>dnsmasq 简单来说扮演的是集群当中的一个传统 dns server 并且把集群内部的 dns 查询拦截到 kube-dns 当中通过中心化的方法进行 dns 查询，集群的 dns 查询主要依靠 kube-dns。</p>
<h2 id="kube-dns"><a href="#kube-dns" class="headerlink" title="kube-dns"></a>kube-dns</h2><p>kube-dns 主要基于 <a target="_blank" rel="noopener" href="https://github.com/skynetservices/skydns">skydns</a> 来实现。</p>
<p>在 <code>k8s.io/dns/pkg/dns/dns.go</code>  的 <code>KubeDNS.Start</code> 下面有 endpoints 和 services 的 controllers，会把 service 注册到 kube-dns 的 cache 当中 (k8s.io/dns/pkg/dns/treecache)，这里有 k8s 域名命名<a target="_blank" rel="noopener" href="https://github.com/kubernetes/dns/blob/master/docs/specification.md">规范</a></p>
<p>主要的实现方式是 skydns 接受一个后端实现。</p>
<img data-src="/zh-CN/2017/12/19/kube-dns-service/skydns-backend.png" class="">



<p><code>KubeDNS.Records</code> <code>KubeDNS.ReverseRecord</code> 基于 TreeCache 实现 DNS 记录存储的后端，从而使得 skydns 提供 DNS 服务。</p>
<img data-src="/zh-CN/2017/12/19/kube-dns-service/kube-dns.png" class="">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体来说 kube-dns 还是一个比较简单的模块，基于 kube-apiserver 的一个控制器，提供中心化的 DNS 查询。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">kube-controller-manager 分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-27 21:30:11" itemprop="dateCreated datePublished" datetime="2017-11-27T21:30:11+08:00">2017-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/11/27/kube-controller-分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>kube-controller-manager 可以认为是一个守护进程用于监视 apiserver 暴露的集群状态，并且不断地尝试把当前状态向集群的目标状态迁移。为了避免频繁查询 apiserver，apiserver 提供了 watch 接口用于监视资源的增加删除和更新，client-go 对此作了抽象，封装一层 informer 来表示本地 apiserver 状态的 cache。<a target="_blank" rel="noopener" href="https://v.qq.com/x/page/c03641vzw2m.html?start=7">这个视频</a> 有一个 Google 工程师讲解的 client-go 的详细内容，<a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/2693.html">这篇</a> 七牛前同事的文章介绍了 informer 的整体结构，写得也很好。</p>
<h3 id="client-当中的-controller"><a href="#client-当中的-controller" class="headerlink" title="client 当中的 controller"></a>client 当中的 controller</h3><p>处理事件的 controller 由几部分构成，首先是 Config 当中的可配置部分，下图是 controller 的关系，controller 实现了 Controller 接口。</p>
<img data-src="/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/controller.png" class="">

<p>controller 从 Queue 当中通过 Pop 获取对象交给 Process 回调处理，DeltaFIFO 和 FIFO 是类似的，只是 DeltaFIFO 可以处理删除事件，一般都用 DeltaFIFO。ListerWatcher 就是用客户端构造出来的，针对对应资源的 List Watch 方法的集合，List 用于获取最开始的对象获取，Watch 用于监控之后的变化，所有最开始的时候现有的对象会通过 List 传给 Add 回调，同步了当前状态以后再不断接受新的变化，但是 Watch 本身是有超时机制的，不能永久监听，所以再超时之后还会通过 List 方法，先同步一次再进行删除操作。Resync Period 表示把 cache 中的对象重新入队给回调函数处理，这种情况一般是可能你可能漏掉了更细操作，或者是之前的一些失败了。大部分情况用不到这个选项，可以非常相信 etcd 的功能。</p>
<p>调用路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cache.NewListWatchFromClient -&gt; listWatcher</span><br><span class="line">cache.NewIndexer -&gt; store</span><br><span class="line">cache.NewLister(store) -&gt; lister</span><br><span class="line">cache.NewReflector</span><br><span class="line">go refector.Run()</span><br></pre></td></tr></table></figure>

<p>还有一个关键结构是 reflector，reflector 会把对象转化成对应的需要的对象并且 Add 到 Queue 当中去。</p>
<p>Informer 本身的框架是异步的，所以为了做并发控制就引入了 workqueue 的组件，workqueue 有 rate limit 的功能，并且能够合并更新操作。</p>
<p>注意不要修改传入的对象，因为他们要和 cache 一致，如果要写对象的话，需要使用 api.Scheme.Copy 这个函数，进行深度拷贝，所有的 k8s Object 都要支持深拷贝的方法。</p>
<h3 id="kube-controller-当中的插件式-controller"><a href="#kube-controller-当中的插件式-controller" class="headerlink" title="kube-controller 当中的插件式 controller"></a>kube-controller 当中的插件式 controller</h3><p>在<code>k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go </code> 中的<code>NewControllerInitializers</code> 函数有大部分 controller 的列表，<code>bootstrapsigner</code> 和 <code>tokencleaner</code> 是默认关闭的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ControllersDisabledByDefault = sets.NewString(</span><br><span class="line">	<span class="string">&quot;bootstrapsigner&quot;</span>,</span><br><span class="line">	<span class="string">&quot;tokencleaner&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>需要特殊初始化的是 <code>serviceaccount-tok</code>，另外的是 <code>NewControllerInitializers</code> 当中的 controller 了。所有的 controller 初始化函数都要满足如下接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InitFunc is used to launch a particular controller.  It may run additional &quot;should I activate checks&quot;.</span></span><br><span class="line"><span class="comment">// Any error returned will cause the controller process to `Fatal`</span></span><br><span class="line"><span class="comment">// The bool indicates whether the controller was enabled.</span></span><br><span class="line"><span class="keyword">type</span> InitFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx ControllerContext)</span></span> (<span class="type">bool</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h4 id="node-controller"><a href="#node-controller" class="headerlink" title="node controller"></a>node controller</h4><p>接下来看一个具体的 controller，<code>startNodeController</code>。</p>
<p><code>startNodeController</code> 首先解析 <code>ClusterCIDR</code> 和 <code>ServiceCIDR</code> 两个子网范围，下面是 <code>NodeController</code> 初始化需要的参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nodeController, err := nodecontroller.NewNodeController(</span><br><span class="line">	ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">	ctx.InformerFactory.Core().V1().Nodes(),</span><br><span class="line">	ctx.InformerFactory.Extensions().V1beta1().DaemonSets(),</span><br><span class="line">	ctx.Cloud,</span><br><span class="line">	ctx.ClientBuilder.ClientOrDie(<span class="string">&quot;node-controller&quot;</span>),</span><br><span class="line">	ctx.Options.PodEvictionTimeout.Duration,</span><br><span class="line">	ctx.Options.NodeEvictionRate,</span><br><span class="line">	ctx.Options.SecondaryNodeEvictionRate,</span><br><span class="line">	ctx.Options.LargeClusterSizeThreshold,</span><br><span class="line">	ctx.Options.UnhealthyZoneThreshold,</span><br><span class="line">	ctx.Options.NodeMonitorGracePeriod.Duration,</span><br><span class="line">	ctx.Options.NodeStartupGracePeriod.Duration,</span><br><span class="line">	ctx.Options.NodeMonitorPeriod.Duration,</span><br><span class="line">	clusterCIDR,</span><br><span class="line">	serviceCIDR,</span><br><span class="line">	<span class="type">int</span>(ctx.Options.NodeCIDRMaskSize),</span><br><span class="line">	ctx.Options.AllocateNodeCIDRs,</span><br><span class="line">	ipam.CIDRAllocatorType(ctx.Options.CIDRAllocatorType),</span><br><span class="line">	ctx.Options.EnableTaintManager,</span><br><span class="line">	utilfeature.DefaultFeatureGate.Enabled(features.TaintBasedEvictions),</span><br><span class="line">	utilfeature.DefaultFeatureGate.Enabled(features.TaintNodesByCondition),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>InformerFactory 是用来构造具体 resource 的 informer 的工厂类型，构造了 pods, nodes, daemonsets 的 informer, 说明 node controller 需要 watch 这几种 resource 的变化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts an asynchronous loop that monitors the status of cluster nodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nc *Controller)</span></span> Run(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">        glog.Infof(<span class="string">&quot;Starting node controller&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> glog.Infof(<span class="string">&quot;Shutting down node controller&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !controller.WaitForCacheSync(<span class="string">&quot;node&quot;</span>, stopCh, nc.nodeInformerSynced, nc.podInformerSynced, nc.daemonSetInformerSynced) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Incorporate the results of node status pushed from kubelet to master.</span></span><br><span class="line">        <span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := nc.monitorNodeStatus(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        glog.Errorf(<span class="string">&quot;Error monitoring node status: %v&quot;</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, nc.nodeMonitorPeriod, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nc.runTaintManager &#123;</span><br><span class="line">                <span class="keyword">go</span> nc.taintManager.Run(wait.NeverStop)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nc.useTaintBasedEvictions &#123;</span><br><span class="line">                <span class="comment">// Handling taint based evictions. Because we don&#x27;t want a dedicated logic in TaintManager for NC-originated</span></span><br><span class="line">                <span class="comment">// taints and we normally don&#x27;t rate limit evictions caused by taints, we need to rate limit adding taints.</span></span><br><span class="line">                <span class="keyword">go</span> wait.Until(nc.doNoExecuteTaintingPass, scheduler.NodeEvictionPeriod, wait.NeverStop)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Managing eviction of nodes:</span></span><br><span class="line">                <span class="comment">// When we delete pods off a node, if the node was not empty at the time we then</span></span><br><span class="line">                <span class="comment">// queue an eviction watcher. If we hit an error, retry deletion.</span></span><br><span class="line">                <span class="keyword">go</span> wait.Until(nc.doEvictionPass, scheduler.NodeEvictionPeriod, wait.NeverStop)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看一下运行的时候是如何做的，首先要调用 <code>controller.WaitForCacheSync</code> 等待 node，pod，daemonSet 的 inofrmer 同步，这是因为在 kube-controller-manager 当中使用的子 controller 使用的 informer 都是共享型的，也就是多个 controller 之间共享一个 informer  的 cache，所以在开始的时候需要保证所有的 sharedInformerFactory 创建的 informers 之间的 cache 先等待一次一致。controller 的读基本上是从 cache 读的，只要写才会打到 etcd 里面，然后等待 cache 的更新回调。</p>
<img data-src="/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/monitor_node_status.png" class="">

<p>nodeController 主要分成两部分，一部分是 <code>monitorNodeStatus</code> , 它首先从 informer 的 cache 当中 list 新添加的节点和删除的节点，和 newZoneRepresentations。node 是分 zone 的，这在单可用区的 cluster 当中是个空字符串，但是如果 labels 中有 <code>failure-domain.beta.kubernetes.io/zone</code> 和 <code>failure-domain.beta.kubernetes.io/region</code> 就会构成不同的可用区的划分, 这个适用于仅仅在一家云厂商分不同可用区的时候可以用到。<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/admin/multiple-zones/">这篇文档</a> 描述了多 zone 的 cluster 的内容，没有 zone 有相应的可用状态，如果某个 zone 变成不可用需要把 pod 从这个 zone 当中剔除，所以 pod 的 failover 是以 zone 为单位的。</p>
<p>处理 node 比较啰嗦，<code>tryUpdateNodeStatus</code> 尝试获取当前的 conditions 更新并且获取 conditions。处理 node 过程主要是标记 node 为不可用的 node，或者把不可用的状态恢复过来。</p>
<p>接下来的就是处理 pod eviction 的部分，另外，<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/">这篇文档</a>解释了一些 kubelet 支持的资源耗尽的情况下 kubelet 的剔除策略。</p>
<p><code>taintManager.Run</code> 处理 taint 的逻辑，<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/">这篇文档</a> 解释了 taint 和 toleration 的关系，以及基于 taint 的 eviction 策略。首先看 node 的更新，然后把上面不能 tolerate 的 pod 传给 handlePodUpdate，然后 pod 有更新也会 handlePodUpdate，在 pod 更新的时间中会让 node 抢占一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> nodeUpdate := &lt;-tc.nodeUpdateChannel:</span><br><span class="line">                tc.handleNodeUpdate(nodeUpdate)</span><br><span class="line">        <span class="keyword">case</span> podUpdate := &lt;-tc.podUpdateChannel:</span><br><span class="line">                <span class="comment">// If we found a Pod update we need to empty Node queue first.</span></span><br><span class="line">        priority:</span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> nodeUpdate := &lt;-tc.nodeUpdateChannel:</span><br><span class="line">                                tc.handleNodeUpdate(nodeUpdate)</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span> priority</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// After Node queue is emptied we process podUpdate.</span></span><br><span class="line">                tc.handlePodUpdate(podUpdate)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是 eviction 的部分，基于 eviction 的会把 pod 直接删除，基于 taint 只是打上标记，然后通过上面的 tiantManager 剔除。和 pod eviction 不同，taint eviction 是通过限制加 taint 的速率控制 raltelimit 的。</p>
<h4 id="podGCController"><a href="#podGCController" class="headerlink" title="podGCController"></a>podGCController</h4><p>pod GC Controller 只 watch pod 一种资源，比较简单。</p>
<p>在 <code>k8s.io/kubernetes/pkg/controller/podgc/gc_controller.go</code> 下。</p>
<p><code>gcc.gcOrphaned</code> 删除 node 不存在的 pod，<code>gcc.gcUnscheduledTerminating</code> 删除正在终止，但是没有调度的 pod，<code>gcc.gcTerminated</code> 删除已经被终止的 pod。</p>
<h4 id="其他-controller"><a href="#其他-controller" class="headerlink" title="其他 controller"></a>其他 controller</h4><p>其他 controller 也是类似的，从 apiserver 获取状态，并且向对应的状态迁移，这也是为什么 kubernetes 的命令和资源都是宣告式的原因。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Kubernetes API 分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-05 02:40:14" itemprop="dateCreated datePublished" datetime="2017-11-05T02:40:14+08:00">2017-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/11/05/Kubernetes-API-分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="kubernetes-概览"><a href="#kubernetes-概览" class="headerlink" title="kubernetes 概览"></a>kubernetes 概览</h2><p>以下是 k8s 的整体架构，在 master 节点上主要是 kube-apiserver（整合了 kube-aggregator），还有 kube-scheduler，以及 kube-controller-manager，包括后端存储 etcd。</p>
<img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/architecture.png" class="">

<p>其中 kube-apiserver 是一个比较关键的部分，而且前期写得坑很多，导致这一部分虽然看起来是一个 API server 其实代码很复杂，特别冗余，而且目前对 kube-apiserver 还要做拆分，能够支持插入第三方的 apiserver，也就是又一个 aggregated apiserver 的 feature，也是和 kube-apiserver 和里面包的一层 genericserver 揉合在一起了，感觉一个大的系统 API server 越写越挫是一个通病，还好现在 k8s 迷途知返正在调整。</p>
<h2 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h2><p>Kube-apiserver 可以是认为在 generic server 上封装的一层官方默认的 apiserver，有第三方需要的情况下，自己也可以在 generic server 上封装一层加入到集成模式中，这里主要介绍 kube-apiserver 的结构。</p>
<h3 id="restful-API"><a href="#restful-API" class="headerlink" title="restful API"></a>restful API</h3><p>kube-apiserver 是一个 restful 服务，请求直接通过 HTTP 请求发送，例如创建一个 ubuntu 的 pod，用以下的 <code>pod.yaml</code> 文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ubuntu1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ubuntu1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ubuntu1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;1d&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>执行命令 <code>kubectl create -f ./pod.yaml -v=8</code>，可以看到对应的 POST 请求如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request Body: &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Pod&quot;,&quot;metadata&quot;:&#123;&quot;labels&quot;:&#123;&quot;name&quot;:&quot;ubuntu1&quot;&#125;,&quot;name&quot;:&quot;ubuntu1&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;containers&quot;:[&#123;&quot;command&quot;:[&quot;sleep&quot;,&quot;1d&quot;],&quot;image&quot;:&quot;ubuntu&quot;,&quot;name&quot;:&quot;ubuntu1&quot;&#125;],&quot;schedulerName&quot;:&quot;default-scheduler&quot;&#125;&#125;</span><br><span class="line">curl -k -v -XPOST  -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;User-Agent: kubectl/v1.7.5 (linux/amd64) kubernetes/17d7182&quot; https://localhost:6443/api/v1/namespaces/default/pods</span><br><span class="line">POST https://localhost:6443/api/v1/namespaces/default/pods 201 Created in 6 milliseconds</span><br><span class="line">Response Headers:</span><br><span class="line">    Content-Type: application/json</span><br><span class="line">    Content-Length: 1208</span><br><span class="line">    Date: Wed, 18 Oct 2017 15:04:17 GMT</span><br><span class="line">Response Body: &#123;&quot;kind&quot;:&quot;Pod&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;metadata&quot;:&#123;&quot;name&quot;:&quot;ubuntu1&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;selfLink&quot;:&quot;/api/v1/namespaces/default/pods/ubuntu1&quot;,&quot;uid&quot;:&quot;9c9af581-b415-11e7-8033-024d1ba659e8&quot;,&quot;resourceVersion&quot;:&quot;486154&quot;,&quot;creationTimestamp&quot;:&quot;2017-10-18T15:04:17Z&quot;,&quot;labels&quot;:&#123;&quot;name&quot;:&quot;ubuntu1&quot;&#125;&#125;,&quot;spec&quot;:&#123;&quot;volumes&quot;:[&#123;&quot;name&quot;:&quot;default-token-p0980&quot;,&quot;secret&quot;:&#123;&quot;secretName&quot;:&quot;default-token-p0980&quot;,&quot;defaultMode&quot;:420&#125;&#125;],&quot;containers&quot;:[&#123;&quot;name&quot;:&quot;ubuntu1&quot;,&quot;image&quot;:&quot;ubuntu&quot;,&quot;command&quot;:[&quot;sleep&quot;,&quot;1d&quot;],&quot;resources&quot;:&#123;&#125;,&quot;volumeMounts&quot;:[&#123;&quot;name&quot;:&quot;default-token-p0980&quot;,&quot;readOnly&quot;:true,&quot;mountPath&quot;:&quot;/var/run/secrets/kubernetes.io/serviceaccount&quot;&#125;],&quot;terminationMessagePath&quot;:&quot;/dev/termination-log&quot;,&quot;terminationMessagePolicy&quot;:&quot;File&quot;,&quot;imagePullPolicy&quot;:&quot;Always&quot;&#125;],&quot;restartPolicy&quot;:&quot;Always&quot;,&quot;terminationGracePeriodSeconds&quot;:30,&quot;dnsPolicy&quot;:&quot;ClusterFirst&quot;,&quot;serviceAccountName&quot;:&quot;default&quot;,&quot;serviceAccount&quot;:&quot;default&quot;,&quot;securityContext&quot;:&#123;&#125;,&quot;schedulerName&quot;:&quot;default-scheduler&quot;,&quot;tolerations&quot;:[&#123;&quot;key&quot;:&quot;node.kubernetes.io/not-ready&quot;,&quot;operator&quot;:&quot;Exists&quot;,&quot;effect&quot;:&quot;NoExecute&quot;,&quot;tolerationSeconds&quot;:300&#125;,&#123;&quot;key&quot;:&quot;node.alpha.kubernetes.io/unreachable&quot;,&quot;operator&quot;:&quot;Exists&quot;,&quot;effect&quot;:&quot;NoExecute&quot;,&quot;tolerationSeconds&quot;:300&#125;]&#125;,&quot;status&quot;:&#123;&quot;phase&quot;:&quot;Pending&quot;,&quot;qosClass&quot;:&quot;BestEffort&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>从 url path 里面可以看到几个划分，path 的分类大概有下面这几种。</p>
<img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/api-path.png" class="">

<p>路径上整体分成 group, version, resource, 作为核心 API group 的 core（包括 pod, node 之类的 resource)，不带 group，直接接在 /api/ 后面，其他的 api group 则接在 /apis 后面。以 pod 为例，pod 对应的数据类型如下，这个数据结构和 POST 请求中的结构的参数是一致的。</p>
<img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/pod.png" class="">

<p>如果是 job 的话则是在，<code>pkg/apis/batch/v2alpha1/types.go</code>，和 API 路径是对应的。例子当中 <code>kubectl</code> 加上 level 大于 8 的 log 就会打印请求和相应的 body，可以看到 request body 和上面的数据结构是一致的。这个请求会发送到 apiserver 进行处理并且返回存储之后的 pod。</p>
<h3 id="重要结构体"><a href="#重要结构体" class="headerlink" title="重要结构体"></a>重要结构体</h3><h4 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h4><p>父结构，主要的配置内容，其中有一个结构 <code>RESTOptionsGetter genericregistry.RESTOptionsGetter</code> 是和 API 初始化相关的，这个接口的实现是在 <code>k8s.io/apiserver/pkg/server/options/etcd.go</code> 中的 <code>storageFactoryRestOptionsFactory</code> 实现的，对应的实现函数是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *storageFactoryRestOptionsFactory)</span></span> GetRESTOptions(resource schema.GroupResource) (generic.RESTOptions, <span class="type">error</span>) &#123;</span><br><span class="line">	storageConfig, err := f.StorageFactory.NewConfig(resource)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> generic.RESTOptions&#123;&#125;, fmt.Errorf(<span class="string">&quot;unable to find storage destination for %v, due to %v&quot;</span>, resource, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret := generic.RESTOptions&#123;</span><br><span class="line">		StorageConfig:           storageConfig,</span><br><span class="line">		Decorator:               generic.UndecoratedStorage,</span><br><span class="line">		DeleteCollectionWorkers: f.Options.DeleteCollectionWorkers,</span><br><span class="line">		EnableGarbageCollection: f.Options.EnableGarbageCollection,</span><br><span class="line">		ResourcePrefix:          f.StorageFactory.ResourcePrefix(resource),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> f.Options.EnableWatchCache &#123;</span><br><span class="line">		sizes, err := ParseWatchCacheSizes(f.Options.WatchCacheSizes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> generic.RESTOptions&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		cacheSize, ok := sizes[resource]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			cacheSize = f.Options.DefaultWatchCacheSize</span><br><span class="line">		&#125;</span><br><span class="line">		ret.Decorator = genericregistry.StorageWithCacher(cacheSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="APIGroupInfo"><a href="#APIGroupInfo" class="headerlink" title="APIGroupInfo"></a>APIGroupInfo</h4><img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/APIGroupInfo.png" class="">

<p>APIGroupInfo 主要定义了一个 API 组的相关信息，观察一下 APIGroupInfo 是如何初始化的。</p>
<p>在 <code>k8s.io/pkg/master/master.go</code> 当中，每个 Resource 都要提供自己的 Provider，比如说 <code>storagerest</code> 就在 <code>k8s.io/kubernetes/pkg/registry/storage/rest/storage_storage.go </code> 定义了 <code>NewRESTStorage</code> 方法。而默认的 resource 的 legacy provider 单独处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.ExtraConfig.APIResourceConfigSource.AnyResourcesForVersionEnabled(apiv1.SchemeGroupVersion) &#123;</span><br><span class="line">	legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider&#123;</span><br><span class="line">		StorageFactory:       c.ExtraConfig.StorageFactory,</span><br><span class="line">		ProxyTransport:       c.ExtraConfig.ProxyTransport,</span><br><span class="line">		KubeletClientConfig:  c.ExtraConfig.KubeletClientConfig,</span><br><span class="line">		EventTTL:             c.ExtraConfig.EventTTL,</span><br><span class="line">		ServiceIPRange:       c.ExtraConfig.ServiceIPRange,</span><br><span class="line">		ServiceNodePortRange: c.ExtraConfig.ServiceNodePortRange,</span><br><span class="line">		LoopbackClientConfig: c.GenericConfig.LoopbackClientConfig,</span><br><span class="line">	&#125;</span><br><span class="line">	m.InstallLegacyAPI(&amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后通过调用 <code>k8s.io/kubernetes/pkg/registry/core/rest.LegacyRESTStorageProvider</code> 的 <code>NewLegacyRESTStorage</code> 来初始化基础对象的 apigroup info，比如初始化 podStorage，serviceStorage 和 nodeStorage 等等。legacy ApiGrouInfo 的 Scheme, ParamaterCodec, NegotiatedSerializer 都是用 <code>    &quot;k8s.io/kubernetes/pkg/api&quot;</code> 包下的全局变量初始化的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scheme:                      api.Scheme,</span><br><span class="line">ParameterCodec:              api.ParameterCodec,</span><br><span class="line">NegotiatedSerializer:        api.Codecs,</span><br></pre></td></tr></table></figure>

<p>然后合并成一个 <code>restStorage</code> 存入 apiGroupInfo 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">restStorageMap := map[string]rest.Storage&#123;</span><br><span class="line">	&quot;pods&quot;:             podStorage.Pod,</span><br><span class="line">	&quot;pods/attach&quot;:      podStorage.Attach,</span><br><span class="line">	&quot;pods/status&quot;:      podStorage.Status,</span><br><span class="line">	&quot;pods/log&quot;:         podStorage.Log,</span><br><span class="line">	&quot;pods/exec&quot;:        podStorage.Exec,</span><br><span class="line">	&quot;pods/portforward&quot;: podStorage.PortForward,</span><br><span class="line">	&quot;pods/proxy&quot;:       podStorage.Proxy,</span><br><span class="line">	&quot;pods/binding&quot;:     podStorage.Binding,</span><br><span class="line">	&quot;bindings&quot;:         podStorage.Binding,</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>举个例子 podStorage 就是用的 <code>genericregistry.Store</code>，这是一个通用的 etc 辅助结构，把 etcd 抽象成存储结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// REST implements a RESTStorage for pods</span><br><span class="line">type REST struct &#123;</span><br><span class="line">	*genericregistry.Store</span><br><span class="line">	proxyTransport http.RoundTripper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="serialization"><a href="#serialization" class="headerlink" title="serialization"></a>serialization</h3><p><code>pkg/api.Codecs</code> 是全局默认的 codec 来自下面这段代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCodecFactory</span><span class="params">(scheme *runtime.Scheme)</span></span> CodecFactory &#123;</span><br><span class="line">	serializers := newSerializersForScheme(scheme, json.DefaultMetaFactory)</span><br><span class="line">	<span class="keyword">return</span> newCodecFactory(scheme, serializers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认具体定义了这几种 serilizer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func newSerializersForScheme(scheme *runtime.Scheme, mf json.MetaFactory) []serializerType &#123;</span><br><span class="line">	jsonSerializer := json.NewSerializer(mf, scheme, scheme, false)</span><br><span class="line">	jsonPrettySerializer := json.NewSerializer(mf, scheme, scheme, true)</span><br><span class="line">	yamlSerializer := json.NewYAMLSerializer(mf, scheme, scheme)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>而且标准库的 json 有很严重的性能问题，换用了 json-iter 但是有很多标准库不兼容的问题，性能提升了大概 20% 但是没办法和进主线，我尝试在上面工作的了一段时间，改了两个问题还是有错，由于时间关系，暂时放弃了这个工作，相关的 issue 在<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/54289">这里</a></p>
<h3 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h3><p>首先通过 <code>./staging/src/k8s.io/apiserver/pkg/server/config.go  </code> 下的 <code>DefaultBuildHandlerChain</code>  构建 filters。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func DefaultBuildHandlerChain(apiHandler http.Handler, c *Config) http.Handler &#123;</span><br><span class="line">	handler := genericapifilters.WithAuthorization(apiHandler, c.RequestContextMapper, c.Authorizer, c.Serializer)</span><br><span class="line">	handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.RequestContextMapper, c.LongRunningFunc)</span><br><span class="line">	handler = genericapifilters.WithImpersonation(handler, c.RequestContextMapper, c.Authorizer, c.Serializer)</span><br><span class="line">	if utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) &#123;</span><br><span class="line">		handler = genericapifilters.WithAudit(handler, c.RequestContextMapper, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		handler = genericapifilters.WithLegacyAudit(handler, c.RequestContextMapper, c.LegacyAuditWriter)</span><br><span class="line">	&#125;</span><br><span class="line">	failedHandler := genericapifilters.Unauthorized(c.RequestContextMapper, c.Serializer, c.SupportsBasicAuth)</span><br><span class="line">	if utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) &#123;</span><br><span class="line">		failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.RequestContextMapper, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">	&#125;</span><br><span class="line">	handler = genericapifilters.WithAuthentication(handler, c.RequestContextMapper, c.Authenticator, failedHandler)</span><br><span class="line">	handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, nil, nil, nil, &quot;true&quot;)</span><br><span class="line">	handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.RequestContextMapper, c.LongRunningFunc, c.RequestTimeout)</span><br><span class="line">	handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver, c.RequestContextMapper)</span><br><span class="line">	handler = apirequest.WithRequestContext(handler, c.RequestContextMapper)</span><br><span class="line">	handler = genericfilters.WithPanicRecovery(handler)</span><br><span class="line">	return handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic recover"></a>panic recover</h5><p><code>genericfilters.WithPanicRecovery</code> 在 handler 的最外层对出现的 panic 恢复，并且打印每次请求的 log，所以你想观察 API 请求的情况可以 <code>grep wrap.go</code> 就能看到。</p>
<h5 id="request-context"><a href="#request-context" class="headerlink" title="request context"></a>request context</h5><p><code>apirequest.WithRequestContext</code> 给 request 绑定一个 Context</p>
<h5 id="RequestInfo"><a href="#RequestInfo" class="headerlink" title="RequestInfo"></a>RequestInfo</h5><p>跟路 url 提取后续请求需要的 group, version, namespace, verb, resource 等信息。</p>
<h5 id="WithTimeoutForNonLongRunningRequests"><a href="#WithTimeoutForNonLongRunningRequests" class="headerlink" title="WithTimeoutForNonLongRunningRequests"></a>WithTimeoutForNonLongRunningRequests</h5><p>限制 API 调用时间，超时处理提前终止 write。</p>
<h5 id="WithCORS"><a href="#WithCORS" class="headerlink" title="WithCORS"></a>WithCORS</h5><p>允许跨域访问。</p>
<h5 id="authentication"><a href="#authentication" class="headerlink" title="authentication"></a>authentication</h5><p>在 <code>k8s.io/apiserver/pkg/endpoints/filters/authentication.go</code> 下。<code>WithAuthentication</code> 插入鉴权信息，例如证书鉴权，token 鉴权等，并且从鉴权信息当中获取 user 信息（可能是 service account 也可能是外部用户）user 身份是由<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/admin/authentication/">这</a> 里面的几种方式确认的</p>
<h5 id="authorization"><a href="#authorization" class="headerlink" title="authorization"></a>authorization</h5><p>检查是否有权限进行对应资源的操作。一种是 RBAC 一种是 Node。具体这两种方式可以看这个<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/admin/authorization/">介绍</a>，RBAC 主要是针对服务的，而 Node 模式主要是针对 kubelet 的。</p>
<h5 id="impersonation"><a href="#impersonation" class="headerlink" title="impersonation"></a>impersonation</h5><p>让用户伪装成其他用户，比如 admin 可以用普通用户的身份创建资源。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>通过 genericapiserver 的 <code>InstallLegacyAPIGroup</code> 就注册到路由当中。具体的做法就是根据 version, resource, sub resource, verb 等信息构造路由，然后用 <code>go-restful </code> 注册处理函数。比如说 GET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">route := ws.GET(action.Path).To(handler).</span><br><span class="line">	Doc(doc).</span><br><span class="line">	Param(ws.QueryParameter(&quot;pretty&quot;, &quot;If &#x27;true&#x27;, then the output is pretty printed.&quot;)).</span><br><span class="line">	Operation(&quot;read&quot;+namespaced+kind+strings.Title(subresource)+operationSuffix).</span><br><span class="line">	Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).</span><br><span class="line">	Returns(http.StatusOK, &quot;OK&quot;, producedObject).</span><br><span class="line">	Writes(producedObject)</span><br></pre></td></tr></table></figure>

<p>handler 里面做的内容就是序列化，然后根据具体的要求（GET DELETE 等）到 etcd 中操作，当然本身还有一层缓存，这取决于 API 的 options 是希望更新还是直接读缓存（缓存会比 etcd 旧一些），比如对于 kubelet 会不断查询 node 信息，但是 kubelet 本身并不需要最新的信息，这个时候就会从缓存中读取。</p>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>开启代理 <code>kubectl proxy</code>，就可以通过 localhost 直接访问 kube-apiserver HTTP 服务。然后执行 <code>go tool pprof http://localhost:8001/debug/pprof/profile</code> 可以获得 profile 结果，下图红色的部分就是调用耗时最多的部分。</p>
<img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/prof.png" class="">

<p>除此之外，kube-apiserver 本身也暴露了很多 prometheus 的 metrics 但是往上现在没有现成的模板，只能根据自己的需求来在 prometheus 当作做 query。可以在 <code>k8s.io/apiserver/pkg/endpoints/metrics/metrics.go</code> 里面看到。</p>
<p>之前也说过，超时间调用时会打 log 的，在代码中保存了一些 trace 日志，可以通过 <code>grep Trace</code>来过滤。Trace[%d] 这样开头, %d 是一个 id 可以看到具体的 trace 信息。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/" class="post-title-link" itemprop="url">kubernetes 调度器指北</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-26 00:45:56" itemprop="dateCreated datePublished" datetime="2017-09-26T00:45:56+08:00">2017-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/09/26/kubernetes-指北/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近因为 k8s 的默认调度器功能太丰富，太“高级”了，一些屌丝特性没有满足，所以前段时间自己魔改了一下满足了一些屌丝特性，暂时叫做乞丐调度器，顺便把默认的调度器代码翻了一下，这里对默认的代码做一下总结。</p>
<h2 id="CreateScheduler"><a href="#CreateScheduler" class="headerlink" title="CreateScheduler"></a>CreateScheduler</h2><img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/CreateScheduler.png" class="">

<p>CreateScheduler 会从 policy file 当中获取算法的配置信息。接口<code>k8s.io/kubernetes/plugin/pkg/scheduler.Configurator</code> 定义了构造一个 scheduler 的配置信息。<code>k8s.io/kubernetes/plugin/pkg/scheduler/factor.ConfigFactory</code> 是这个接口的一个实现。<code>c.Create</code> 会把 <code>AlgorithmProvider</code> 配置的 <code>Predicate</code> 和 <code>Priority</code> 的 key 当作参数传给，<code>f.CreateFromKeys</code> 这样主要对应的 key 注册了的话就会有对应的算法绑定到 scheduler 上面。目前有两种 Provider，一种是用默认 predicate 和 默认 priority 的 AlgorithmProvider，另一种是把 <code>LeastRequestedPriority</code> 换成 <code>MostRequestedPriority</code> 的自动伸缩友好的 AlgorithmProvider。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Registers algorithm providers. By default we use &#x27;DefaultProvider&#x27;, but user can specify one to be used</span></span><br><span class="line"><span class="comment">// by specifying flag.</span></span><br><span class="line">factory.RegisterAlgorithmProvider(factory.DefaultProvider, defaultPredicates(), defaultPriorities())</span><br><span class="line"><span class="comment">// Cluster autoscaler friendly scheduling algorithm.</span></span><br><span class="line">factory.RegisterAlgorithmProvider(ClusterAutoscalerProvider, defaultPredicates(),</span><br><span class="line">	copyAndReplace(defaultPriorities(), <span class="string">&quot;LeastRequestedPriority&quot;</span>, <span class="string">&quot;MostRequestedPriority&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Scheduler-Server"><a href="#Scheduler-Server" class="headerlink" title="Scheduler Server"></a>Scheduler Server</h2><p><code>options.ScheduleServer</code> 是服务端对应的配置结构，其中有几个成员。</p>
<ol>
<li> KubeSchedulerConfiguration 调度器的配置</li>
<li> Master 表示 API server 的地址</li>
<li> Kubeconfig k8s 配置文件的路径</li>
</ol>
<p><code>func Run(s *options.SchedulerServer) error</code> 会根据 <code>Sechduler Server</code> 来运行。<code>EventBroadcaster</code> 接受事件，并且把事件发送给事件处理者（ EventSink watcher, log)，<code>startHTTP</code> 主要是是 profiling 接口，心跳检测接口和 prometheus 的 instrumenting 接口。<code>informerFactory</code>，看起来是一个异步同步信息的 cache，平时调度是直接走 cache，更新的时候才会走 API。最后配置了选主的话会从 Etcd 拿到锁，并且拿到 Master 的锁。</p>
<img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/scheduler-init.png" class="">

<h2 id="k8s-io-kubernetes-plugin-pkg-scheduler-Scheduler-Run"><a href="#k8s-io-kubernetes-plugin-pkg-scheduler-Scheduler-Run" class="headerlink" title="k8s.io/kubernetes/plugin/pkg/scheduler.Scheduler.Run"></a>k8s.io/kubernetes/plugin/pkg/scheduler.Scheduler.Run</h2><p>初始化以后，Run 对应的是一个 0 秒循环的大 loop（相当于每次 loop 等于主动调用一次 Go runtime.Sched())，在每次循环当中都会调用 <code>sched.scheduleOne</code>，首先 <code>NextPod</code> 会同步等待一个 pod 变成 available 的状态，并且跳过正在被删除的 pod，然后调用 <code>sched.schedule</code> 走到具体的调度算法当中，整个过程是串行，没有批量调度 pod 的操作。在进行具体的调度算法之后，会得到一个可行的 node，如果调度失败的话会，并且调度失败的原因是找不到合适的 node 的话，就尝试 <code>sched.preempt</code>，这个的作用就是尝试在替换现有 pod 的情况下能够获得调度机会的策略，那么就抢占已经被调度的 pod，标记目标 pod 的 Annotation 然后踢出权重最低的那个 pod。如果成果获得一个可调度的节点，就通过把本地 cache 先更新到已经调度之后的状态，标记 pod 已经在要调度的 node 上，也就是调用 <code>sched.assume</code> 假设 pod 已经调度到了节点上，再异步的通过 ApiServer 的接口，<code>sched.bind</code> 让 pod 正在运行到 node 上。</p>
<img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/scheduleOne.png" class="">

<h2 id="sched-schedule"><a href="#sched-schedule" class="headerlink" title="sched.schedule"></a>sched.schedule</h2><p>schedule 调用 <em>algorithm/scheduler_interface.go</em>下面定义的调度器的接口 <code>Schedule</code>。对应的实现在 <em>core/generic_scheduler.go</em> 下面。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScheduleAlgorithm is an interface implemented by things that know how to schedule pods</span></span><br><span class="line"><span class="comment">// onto machines.</span></span><br><span class="line"><span class="keyword">type</span> ScheduleAlgorithm <span class="keyword">interface</span> &#123;</span><br><span class="line">	Schedule(*v1.Pod, NodeLister) (selectedMachine <span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Preempt receives scheduling errors for a pod and tries to create room for</span></span><br><span class="line">	<span class="comment">// the pod by preempting lower priority pods if possible.</span></span><br><span class="line">	<span class="comment">// It returns the node where preemption happened, a list of preempted pods, and error if any.</span></span><br><span class="line">	Preempt(*v1.Pod, NodeLister, <span class="type">error</span>) (selectedNode *v1.Node, preemptedPods []*v1.Pod, err <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Predicates() returns a pointer to a map of predicate functions. This is</span></span><br><span class="line">	<span class="comment">// exposed for testing.</span></span><br><span class="line">	Predicates() <span class="keyword">map</span>[<span class="type">string</span>]FitPredicate</span><br><span class="line">	<span class="comment">// Prioritizers returns a slice of priority config. This is exposed for</span></span><br><span class="line">	<span class="comment">// testing.</span></span><br><span class="line">	Prioritizers() []PriorityConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Schedule</code> 会根据调度算法得到一个合适的节点，而 <code>Preempt</code> 则是尝试抢占一个 pod 以获得调度到节点上的机会。<code>Predicates</code> 和 <code>Priorities</code> 则是两个重要的部分，<code>Predicates</code> 类似一个过滤器，对节点进行筛选，而 <code>Priorities</code> 则是对筛选出来的节点进行权重的排序，最后得到一个合适的调度节点。</p>
<h3 id="算法工厂"><a href="#算法工厂" class="headerlink" title="算法工厂"></a>算法工厂</h3><p>算法工厂就是注册 <code>Preciate</code> 和 <code>Priority</code> 的地方，之前已经说了可以通过 <code>AlgorithmProvider</code> 获得一组 <code>Predicate</code> 和 <code>Priority</code>，比如 DefaultProvider 提供了默认的一套，如果不用 Provider，需要在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/examples/blob/master/staging/scheduler-policy-config.json">policy file</a> 当中另外指定要使用的 <code>Predicate</code> 和 <code>Priority</code>，不过目前好像没有用这种方式，还是通过 Provider 指定了一套要使用的算法 。注册 <code>AlgorithmProvider  </code>是通过<code>factory.RegisterAlgorithmProvider</code>，然后调用 <code>NewGenericScheduler</code> (在 <em>k8s.io/kubernetes/plugin/pkg/scheduler/core/generic_scheduler.go</em> 当中)，初始化要用到的 predicates 和 priorities。</p>
<h3 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h3><p><code>Schedule</code> 其实很简单，就是通过 <code>findNodesThatFit</code>，先根据 <code>Predicate</code> 过滤出合适的 Node，然后调用 <code>PrioritizeNodes</code>，用 <code>Priorities</code> 对 Node 根据算法的权重进行排序，因为每个 node 要走的流程是一样的并且最终结果相互没有影响，所以这个过程是并发的，<a target="_blank" rel="noopener" href="http://blog.csdn.net/waltonwang/article/details/54409917">这篇文章</a>的图画的很好，示意很明显。</p>
<img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/Schedule.jpeg" class="">

<p>最后会得到一个最理想的节点，再通过 bing 告诉 API server 这个节点被选中了。</p>
<h2 id="sched-preempt"><a href="#sched-preempt" class="headerlink" title="sched.preempt"></a>sched.preempt</h2><p>抢占过程是在 pod 没有找到合适的节点情况下，如果能在踢出一个 pod 获得调度机会的情况下进行抢占。抢占算是一个比较新的特性，在 1.8 里面都是默认关掉的，要打开的话需要指定<code>kube-scheduler</code> 的 <code>--feature-gates=PodPriority=true</code> 还有 apiserver 的 <code>--runtime-config=scheduling.k8s.io/v1alpha1=true</code>。可以通过添加 <code>PriorityClass</code> 把 pod 分权重，现在这个特性算是给 pod 也加上的权重。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">high-priority</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">1000000</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;This priority class should be used for XYZ service pods only.&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后可以在<code>spec</code>当中指定 <code>priorityClassName: high-priority</code>，这样这么大的权重，这个 pod 就很难被抢占了，具体流程如下图。</p>
<img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/schedule-preempt.png" class="">

<p><code>podEligibleToPreemptOthers</code> 主要判断如果 目标 pod 被标记为（通过 pod 的 annotation 标记）已经要抢占其他 pod，并且有一个优先级小于 目标 pod 的 pod 即将被删除 (<code>p.DeletionTimestamp != nil </code>)，就直接退出，因为这个时候这个被删除的 pod 其实在为目标 pod 腾出空间了，在下次调度的时候就会获得调度机会。<code>nodesWherePreemptionMightHelp</code>，类似于 schedule 的时候的 predicate 阶段，只不过多了一步是通过尝试移除 pod 跑一遍 predicates 看看这个节点能不能被通过。 <code>selectNodesForPreemption</code> 则和 priority 的阶段类似，把删除 pod 之后的可以通过的节点进行排序选出一个排名最高的节点。再通过 <code>selectVictimsOnNode</code> 把节点上的 pod 按照节点的 priority 排序选出“受害者”，越高越难被抢占。可以在 spec 里面设置这个值，选出了节点上的受害者以后，通过<code>pickOneNodeForPreemption</code>，主要的依据是拥有最低的最高 pod 权重的节点先被选出来，比如 node1 上 pod 的最高权重是 10，node2 上 pod 的最高权重是 8，那么 node2 被选中，如果有平局的话，最少的“受害者”先选，如果还平局，随机选一个。最后得到一个要被抢占的节点。</p>
<h2 id="自定义调度器的方式"><a href="#自定义调度器的方式" class="headerlink" title="自定义调度器的方式"></a>自定义调度器的方式</h2><p>自定义调度器有三种方法。</p>
<p>第一种是通过添加 <code>Predicate</code> 和 <code>Priority</code> 的方式，做微调，这种方式比较简单，只要定义好对应的函数并且通过函数工厂注册就可以。</p>
<p>第二种是使用自定义的调度器，具体的方法可以看<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/">官方文档</a>，通过把 pod 的 spec.schedulerName 指向自定义的调度器就可以把调度任务转到自己实现的服务。</p>
<p>第三种是使用 extender，extender 本身和调度器的过程类似，接口是如下定义的，主要是针对一些不算受集群本身控制的资源，需要通过外部调用来进行调度的情况，相关文档在<a href="blog.kubernetes.io/2017/03/advanced-scheduling-in-kubernetes.html">这里</a>。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>目前单机简单的测试条件下，1s 钟可以调度成功 450 左右的 pod，具体的性能参数还要慢慢挖掘。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">flannel 网络架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-21 00:15:27" itemprop="dateCreated datePublished" datetime="2017-09-21T00:15:27+08:00">2017-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/09/21/flannel-网络架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>flannel 是一个中心化的 overlay 容器网络，设计简单，容易理解，对于 k8s 来说，有一个假设：所有容器都可以和集群里任意其他容器或者节点通信，并且通信双方看到的对方的 IP 地址就是实际的地址，主要的好处就是不需要任何的端口映射和地址转换，拥有一张扁平的网络更容易管理，而且由于是基于 Etcd 的中心化的管理，所以对于一些 IP 变化异常频繁的场景来说，比一些去中心化的方案能够较及时同步网络拓扑关系。</p>
<h2 id="IP-地址的管理"><a href="#IP-地址的管理" class="headerlink" title="IP 地址的管理"></a>IP 地址的管理</h2><p>flannel 的 IP 地址是通过 Etcd 管理的，在 k8s 初始化的时候指定 pod 大网的网段 <code>--pod-network-cidr=10.244.0.0/16</code>，flanneld 可以直接通过 Etcd 管理，如果启动的时候指定了 <code>--kube-subnet-mgr</code>，可以直接通过 k8s 的 apiserver 来获得一个小网段的租期，通过 <code>kubectl get &lt;NodeName&gt; -o jsonpath=&#39;&#123;.spec.podCIDR&#125;&#39;</code> 可以获取对应节点的 CIDR 表示的网段，flannel 是以节点为单元划分小网段的，每个节点上的 pod 在这个例子当中是划分一个 10.244.x.0/24 的网段，所以总共能分配 255 个节点，每个节点上可以分配 253 个 pod。结构如下图所示，每个节点上都会有一个 flanneld 用于管理自己网段的租期。</p>
<img data-src="/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/flannel-02.png" class="">

<p>可以通过在 host 上 <code>cat /run/flannel/subnet.env</code> 查看同步下来的信息，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FLANNEL_NETWORK=10.244.0.0/16</span><br><span class="line">FLANNEL_SUBNET=10.244.0.1/24</span><br><span class="line">FLANNEL_MTU=8951</span><br><span class="line">FLANNEL_IPMASQ=true</span><br></pre></td></tr></table></figure>

<p>说明当前节点分配的网段是 <code>10.244.0.1/24</code>。在每个节点上因为已经确定了网段，用 ipam 就可以管理这一范围 ip 地址的分配，所以本身 pod 的 IP 分配和中心 Etcd 没有太多联系。</p>
<h2 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h2><p>简单来说就是通过建立 VXLAN  隧道，通过 UDP 把 IP 封装一层直接送到对应的节点，实现了一个大的 VLAN。没有使用 IPoIP 或者 GRE 主要是因为一些云厂商比如 AWS 的安全策略只能支持 TCP/UDP/ICMP。</p>
<p>flannel 本身会创建一个类似下面这样配置的 CNI bridge 设备。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mtu&quot;</span> <span class="punctuation">:</span> <span class="number">8973</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipMasq&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isGateway&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipam&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;10.244.0.1/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;routes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;dst&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;10.244.0.0/16&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>具体的网络拓扑图如下，所用的网段开头是 10.1，但是划分是一致的，图里面的 docker0 应该是 cni0，flannel0 应该是 flannel.1，这个命名的区别主要是不带点的是 UDP 封装，带点的是 vxlan 封装，图片比较早。</p>
<img data-src="/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/flannel-01.png" class="">

<p>第一步，首先是从容器中(10.1.20.3)出来，走桥接去到 cni0 (10.1.20.1)，通过<code>brctl show</code> 可以看到 <code>cni0</code> 接了两个容器的 veth。</p>
<p>第二步，然后根据路由规则，在宿主机上能够用<code>ip route</code>，找到一条走到大网段的路由。<code>10.15.0.0/16 dev flannel.1</code>，到达 <code>flannel.1</code>。</p>
<p>第三步，<code>flannel.1</code> 会走 vxlan，这个是在内核实现的，如果用 UDP 封装就是在用户态实现的，用户态实现的等于把包从内核过了两遍，没有直接用 vxlan 封装的直接走内核效率高，所以基本上不会使用 UDP 封装。对应的 vxlan 配置可以通过 <code>bridge fdb flannel.1</code> 看到，没有一条隧道就会有一条这样的转发表。因为到达每个对应网段的信息是在 Etcd 上分配的 flannel.1 只要 watch 然后发现有更改的时候对应配置隧道指向对应容器网段的宿主机 IP 就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8a:55:a7:e2:e9:18 dev flannel.1 dst 192.168.0.100 self permanent</span><br></pre></td></tr></table></figure>

<p>第四步，走宿主机的网络到达对端，对端的 vxlan 收到以后会拆开封装，丢到协议栈里面。</p>
<p>第五步，根据路由 <code>ip route</code>，中的一条<code>10.1.15.0/24 dev cni0  proto kernel  scope link  src 10.1.15.1</code>，送到 <code>cni0</code> 然后再转发给容器 <code>10.1.15.2</code>, 最后就能完成 pod 跨界点的互通了。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>因为整个的网段分配是存在 Etcd 里面的，节点只要 watch 然后根据网段建隧道就可以，相对来说中心化的系统设计比较简单，而且对于 IP 地址变动能够及时反应，特别是节点和容器都有剧烈变化的时候（别问我为啥物理节点会有剧烈变化，创业公司玩法怎么省钱怎么来……），相比于去中心化的一些设计能够更快同步一些。当然建隧道是一个点对点的规模，也就是如果有 n 个节点建隧道的话，每个节点上都要建 n-1 条隧道。</p>
<p>一种改进方式是使用 host-gw 的后端方式，以及 ipvlan，不过目前 ipvlan 还没有支持，<a target="_blank" rel="noopener" href="http://machinezone.github.io/research/networking-solutions-for-kubernetes/">这里</a>有一个各种后端实现的比较，vxlan 表现很最差，host-gw 的做法是不用隧道的方式，而是把路由信息直接写到节点上，直接打平到节点上，等于是节点之间是一个大网，每个节点上的小网段通过路由的方式和大网互通，将到达各个节点的网段的路由刷到节点上，而不是建 vxlan 隧道的方式，比如文中的例子，会有这样的路由。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.1.15.0/24 via 192.168.0.100 dev eth0 </span><br><span class="line">10.1.15.0/24 dev cni0  proto kernel  scope link  src 10.1.20.1</span><br></pre></td></tr></table></figure>

<p>然而，由于 flannel 只能够修改各个主机的路由表，一旦主机直接隔了个其他路由设备，比如三层路由器，这个包就会在路由设备上被丢掉。这样一来，host-gw 的模式就只能用于二层直接可达的网络。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">LC-trie 快速路由查找算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-05 00:46:17" itemprop="dateCreated datePublished" datetime="2017-09-05T00:46:17+08:00">2017-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/09/05/LC-trie-快速路由查找算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一般来说我们把字典树称作 trie，这是一个用于查找字符串的数据结构，举个简单的例子。下面就是一个把 b，abc，abd，bcd，abcd，efg，hii 这 6 个单词构造成字典树的例子。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.jpg" class="">

<p>在路由表中我们可以把子网看作一个二进制字符串，对于 IPv4 来说，字符串的长度就有 32 位。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/2.jpg" class="">

<p>以上面这个为例子，有编号 0 到 14 这几个二进制的字符串（字符集和只有 0 和 1），右边是他们的具体字符串，这样的字典树有一点像二叉树。如果把它画出来是这样的。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/3.jpg" class="">

<p>对这个树做压缩有一个办法就是把单节点作压缩，形成下面这个树，这个就是路径压缩，path compressed trie。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/4.jpg" class="">

<p>我们需要在压缩的地方进行标记，比如 skip 4 那里把一段 1011 压缩掉了。而 LC-trie 指的是 Level Compressed trie，这个树会把层级进行压缩，因为我们得到的这个字典树实际上是一个稀疏树，高度并不是平衡的，所以为了达到平衡，需要做的一件事情是把高度进行压缩，压缩之后变成下面这个形式，这样整棵树就会更加扁平。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/5.jpg" class="">

<p>这个树是有两种类型的节点，一种是 leaf，保存了路由具体的信息的叶子结点，一种是 trie node（tnode）保存了中间节点，子节点可能是 tnode 或者 leaf。trie 上有几个数据要存储，一个是 bits，这个表示的是子节点的选择度（这个怎么理解呢，就是我接下来的子节点是八叉了，因为我把原来的树压缩了，所以现在不需要二选一，现在直接来个八选一就可以），对于一个八叉的压缩来说，就要有一个 3 位的数字来存储，也就是 log(8)，当然也可以能是 7 叉，但是必须是 2 的指数。而 pos 表示的是从那个 bit 开始，它的作用和 skip 类似只不过不是一个相对值，而是一个累加值，表示我们要从哪开始（从字符串的起始位置开始数）。</p>
<p>我们先看一下搜索的代码，其实很简单，就是不断匹配公共前缀直到直到找到叶子节点（ bits == 0）。匹配前缀的方式比较 tricky，用异或进行确认。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcu_read_lock needs to be hold by caller from readside */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> key_vector *<span class="title function_">fib_find_node</span><span class="params">(<span class="keyword">struct</span> trie *t,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> key_vector **tp, u32 key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key_vector</span> *<span class="title">pn</span>, *<span class="title">n</span> =</span> t-&gt;kv;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		pn = n;</span><br><span class="line">		n = get_child_rcu(n, index);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!n)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		index = get_cindex(key, n);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* This bit of code is a bit tricky but it combines multiple</span></span><br><span class="line"><span class="comment">		 * checks into a single check.  The prefix consists of the</span></span><br><span class="line"><span class="comment">		 * prefix plus zeros for the bits in the cindex. The index</span></span><br><span class="line"><span class="comment">		 * is the difference between the key and this value.  From</span></span><br><span class="line"><span class="comment">		 * this we can actually derive several pieces of data.</span></span><br><span class="line"><span class="comment">		 *   if (index &gt;= (1ul &lt;&lt; bits))</span></span><br><span class="line"><span class="comment">		 *     we have a mismatch in skip bits and failed</span></span><br><span class="line"><span class="comment">		 *   else</span></span><br><span class="line"><span class="comment">		 *     we know the value is cindex</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This check is safe even if bits == KEYLENGTH due to the</span></span><br><span class="line"><span class="comment">		 * fact that we can only allocate a node with 32 bits if a</span></span><br><span class="line"><span class="comment">		 * long is greater than 32 bits.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (index &gt;= (<span class="number">1ul</span> &lt;&lt; n-&gt;bits)) &#123;</span><br><span class="line">			n = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* keep searching until we find a perfect match leaf or NULL */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (IS_TNODE(n));</span><br><span class="line"></span><br><span class="line">	*tp = pn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体看一下 <code>get_cindex</code> 匹配的方式，<code>#define get_cindex(key, kv) (((key) ^ (kv)-&gt;key) &gt;&gt; (kv)-&gt;pos)</code>，对 tnode 和 被比较的 key 做异或，这个怎么理解呢，看下面的图的例子这是正确匹配以后的结果，灰色代表 0，蓝色代表 1，两个值进行异或的话，首先 pos 会被右移掉，然后 bits 的部分会原样保留，因为 tnode 的这部分都是 0。然后亲址的部分如果完全匹配的话结果就都是 0 ，但是如果不完全匹配的话，结果就会比 index 还要大，因为高位还有 1，所以这就是为什么 <code>index &gt;= (1ul &lt;&lt; n-&gt;bits</code> 能判断是否匹配的前缀的原因。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/6.jpg" class="">

<p>然后我们再看一下插入的流程。首先算出匹配到当前节点的子节点（有可能有，有可能没有）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fib_insert_node</span><span class="params">(<span class="keyword">struct</span> trie *t, <span class="keyword">struct</span> key_vector *tp,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> fib_alias *new, t_key key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key_vector</span> *<span class="title">n</span>, *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">	l = leaf_new(key, new);</span><br><span class="line">	<span class="keyword">if</span> (!l)</span><br><span class="line">		<span class="keyword">goto</span> noleaf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve child from parent node */</span></span><br><span class="line">	n = get_child(tp, get_index(key, tp));</span><br></pre></td></tr></table></figure>
<p>如果有子节点，就要创建一个新的 tnode，再把这个 key 给插入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Case 2: n is a LEAF or a TNODE and the key doesn&#x27;t match.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Add a new tnode here</span></span><br><span class="line"><span class="comment"> *  first tnode need some special handling</span></span><br><span class="line"><span class="comment"> *  leaves us in position for handling as case 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (n) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key_vector</span> *<span class="title">tn</span>;</span></span><br></pre></td></tr></table></figure>
<p><code>__fls</code> find last set bit，就是找到 pos，然后扩展出有两个选择（2 的 1 次方）的 tnode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tn = tnode_new(key, __fls(key ^ n-&gt;key), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!tn)</span><br><span class="line">	<span class="keyword">goto</span> notnode;</span><br></pre></td></tr></table></figure>
<p>设置 tn 的 父节点为 tp，然后把 key 插入到 tn 当中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* initialize routes out of node */</span></span><br><span class="line">	NODE_INIT_PARENT(tn, tp);</span><br><span class="line">	put_child(tn, get_index(key, tn) ^ <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start adding routes into the node */</span></span><br><span class="line">	put_child_root(tp, key, tn);</span><br><span class="line">	node_set_parent(n, tn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parent now has a NULL spot where the leaf can go */</span></span><br><span class="line">	tp = tn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Case 3: n is NULL, and will just insert a new leaf */</span></span><br><span class="line">node_push_suffix(tp, new-&gt;fa_slen);</span><br><span class="line">NODE_INIT_PARENT(l, tp);</span><br><span class="line">put_child_root(tp, key, l);</span><br></pre></td></tr></table></figure>
<p>开始进行平衡调整树形。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	trie_rebalance(t, tp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">notnode:</span><br><span class="line">	node_free(l);</span><br><span class="line">noleaf:</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下树的高度是如何进行调整的，从当前节点一直向上压缩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trie_rebalance</span><span class="params">(<span class="keyword">struct</span> trie *t, <span class="keyword">struct</span> key_vector *tn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!IS_TRIE(tn))</span><br><span class="line">		tn = resize(t, tn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_WORK 10</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> key_vector *<span class="title function_">resize</span><span class="params">(<span class="keyword">struct</span> trie *t, <span class="keyword">struct</span> key_vector *tn)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IP_FIB_TRIE_STATS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">trie_use_stats</span> __<span class="title">percpu</span> *<span class="title">stats</span> =</span> t-&gt;stats;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>利用 <code>container_of</code> 获取父节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_vector</span> *<span class="title">tp</span> =</span> node_parent(tn);</span><br></pre></td></tr></table></figure>
<p>获取子节点，初始化 <code>max_work</code> 为 10。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cindex = get_index(tn-&gt;key, tp);</span><br><span class="line"><span class="type">int</span> max_work = MAX_WORK;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;In tnode_resize %p inflate_threshold=%d threshold=%d\n&quot;</span>,</span><br><span class="line">	 tn, inflate_threshold, halve_threshold);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* track the tnode via the pointer from the parent instead of</span></span><br><span class="line"><span class="comment"> * doing it ourselves.  This way we can let RCU fully do its</span></span><br><span class="line"><span class="comment"> * thing without us interfering</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BUG_ON(tn != get_child(tp, cindex));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Double as long as the resulting node has a number of</span></span><br><span class="line"><span class="comment"> * nonempty nodes that are above the threshold.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><code>should_inflate</code> 决定要不要压缩的依据是根据动态压缩算法来的（引用4），直观的来说就是高度超过了一个动态计算的阈值，并且还没压缩超过十次就会继续压缩。这个动态阈值的算法是用非空子节点的数目如果超过压缩之后子节点数目的一半就值得压缩。而 <code>inflate</code> 做的事情就把层级压缩一层，也就是把 children 的 children 按照 bits 的匹配放到 parent 的 new_children 当中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">while</span> (should_inflate(tp, tn) &amp;&amp; max_work) &#123;</span><br><span class="line">		tp = inflate(t, tn);</span><br><span class="line">		<span class="keyword">if</span> (!tp) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IP_FIB_TRIE_STATS</span></span><br><span class="line">			this_cpu_inc(stats-&gt;resize_node_skipped);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		max_work--;</span><br><span class="line">		tn = get_child(tp, cindex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update parent in case inflate failed */</span></span><br><span class="line">	tp = node_parent(tn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Return if at least one inflate is run */</span></span><br><span class="line">	<span class="keyword">if</span> (max_work != MAX_WORK)</span><br><span class="line">		<span class="keyword">return</span> tp;</span><br></pre></td></tr></table></figure>
<p>到这里说明一次调整都没有发生，说明节点很稀疏，也就是把节点分开。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Halve as long as the number of empty children in this</span></span><br><span class="line"><span class="comment">	 * node is above threshold.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (should_halve(tp, tn) &amp;&amp; max_work) &#123;</span><br><span class="line">		tp = halve(t, tn);</span><br><span class="line">		<span class="keyword">if</span> (!tp) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IP_FIB_TRIE_STATS</span></span><br><span class="line">			this_cpu_inc(stats-&gt;resize_node_skipped);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		max_work--;</span><br><span class="line">		tn = get_child(tp, cindex);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个孩子，可以进行 path compress，没必要再多一个中间节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Only one child remains */</span></span><br><span class="line">	<span class="keyword">if</span> (should_collapse(tn))</span><br><span class="line">		<span class="keyword">return</span> collapse(t, tn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update parent in case halve failed */</span></span><br><span class="line">	<span class="keyword">return</span> node_parent(tn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个的 LC-trie 的结构大致如此，主要用于路由表中路由规则的快速匹配，是在 3.6 之后引进的，摒弃了之前用哈希来查找路由表的算法。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/06.09.md">The-Art-Of-Programming-By-July</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nada.kth.se/~snilsson/publications/IP-address-lookup-using-LC-tries/">Fast address lookup for Internet routers</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/fib_trie.txt">LC-trie implementation notes</a></li>
<li><a target="_blank" rel="noopener" href="https://pdfs.semanticscholar.org/e880/05c8801983758917bf6e647da97f1027c86b.pdf">Implementing a dynamic compressed trie</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2014 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ggaaooppeenngg</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"ggaaooppeenngg","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
