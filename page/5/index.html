<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_85tctgPWrqH2EPVuuD5IT6KE-tW8nH0hTISJDMnShg">
  <meta name="baidu-site-verification" content="bb16c5b1fd3302c18e0015bef11eea42">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ggaaooppeenngg.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:type" content="website">
<meta property="og:title" content="ggaaooppeenngg">
<meta property="og:url" content="https://ggaaooppeenngg.github.io/page/5/index.html">
<meta property="og:site_name" content="ggaaooppeenngg">
<meta property="og:description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ggaaooppeenngg">
<meta property="article:tag" content="ggaaooppeenngg,kernel,sysml,golang,python,rust">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ggaaooppeenngg.github.io/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ggaaooppeenngg</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-62096626-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-62096626-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?bb16c5b1fd3302c18e0015bef11eea42"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ggaaooppeenngg</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">为什么计算机科学是无限的但生命是有限的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">134</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">14</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">78</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ggaaooppeenngg</p>
  <div class="site-description" itemprop="description">为什么计算机科学是无限的但生命是有限的</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">134</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ggaaooppeenngg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ggaaooppeenngg" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:peng.gao.dut@gmail.com" title="E-Mail → mailto:peng.gao.dut@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2018/04/21/CUDA-%E7%9A%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2018/04/21/CUDA-%E7%9A%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">CUDA 的计算模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-21 18:20:28" itemprop="dateCreated datePublished" datetime="2018-04-21T18:20:28+08:00">2018-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2018/04/21/CUDA-%E7%9A%84%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2018/04/21/CUDA-的计算模型/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="我的一点观点"><a href="#我的一点观点" class="headerlink" title="我的一点观点"></a>我的一点观点</h2><p>我个人觉得 nvidia 的 CUDA 太封闭了，不是很能明白这样封闭的产品怎么能够长久生存，仅仅是因为家大业大么，如果有家公司推出了八成性能的 GPU，但是整套开发的生态非常友好，是不是会像 Android 取代诺基亚一样，还是 nvidia 就是苹果，就算封闭环境也能保证强劲体验，这我也不好说了。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>CUDA+cudnn 装起来挺麻烦的，反正如果有错误的话，可以检查 CUDA samples 里面的 deviceQuery 是否成功，如果不成功可以用 strace 看一下少了什么东西，再想办法安装上去。检查 cudnn samples 是否成功也是一样的，里面有一个 mnistDNN 的例子。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">__global__ void helloFromGPU (void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Hello world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Hello World! from CPU\n&quot;);</span><br><span class="line"></span><br><span class="line">	helloFromGPU &lt;&lt;&lt;1, 10&gt;&gt;&gt;();</span><br><span class="line">	cudaDeviceReset();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是一段 GPU 的 Hello world，执行下面的代码可以看到我们在 GPU 上并行执行了十个 “Hello world!” 的打印。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvcc -<span class="built_in">arch</span> sm_20 hello.cu -o hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello</span></span><br><span class="line">Hello World! from CPU</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>
<h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2><p>CUDA 全称 Compute Unified Device Architecure，用于定义 GPU 的架构标准。GPU 的工作方式主要依赖于多核心的并行计算，CUDA 提供了方便的模型进行这种模式的编程，下面就会简单介绍一下 CUDA 的架构以及基于 GPU 的编程。</p>
<p>CUDA 一次启动的线程称为网格(grid)，网格中包含块，每个块包含新程，是一个二维的模式，这张图片就说明得很清晰，首先是由 Grid 组成，然后每个 Block 有 shared memory，同 block 的线程可以访问 shared memory，不同的 Block 的线程只能访问全局的内存，这种结构也方便设计和实现并行算法。</p>
<p><img data-src="https://www.researchgate.net/profile/Marco_Nobile/publication/261069154/figure/fig1/AS:296718735298563@1447754667270/Schematization-of-CUDA-architecture-Schematic-representation-of-CUDA-threads-and-memory.png" alt="cuda-arch"></p>
<p>CUDA 的编译器 nvcc 是 gcc 的一个扩展，支持编写运行在 GPU 上的函数，其中的，<code>&lt;&lt;x, y&gt;&gt;</code> 扩展就是用来指定 block 和 thread 的数量的。</p>
<p>比如典型的俩个向量相加的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sumArrayOnHost</span><span class="params">(<span class="type">float</span> *A, <span class="type">float</span> *B, <span class="type">float</span> *C, <span class="type">const</span> <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        C[i] = A[i] + B[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是 GPU 的核函数怎么写呢，是这样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__global__ <span class="type">void</span> <span class="title function_">sumArrayOnGPU</span><span class="params">(<span class="type">float</span> *A, <span class="type">float</span> *N, <span class="type">float</span> C)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = threadIdx.x</span><br><span class="line">    C[i] = A[i] + B[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，如果 N 是 32 的话，可以如下调用，<code>__global__</code> 表示这个函数可以在 host 调用也可以在 GPU 上调用，用个 32 个线程的 block 算这个向量和，N 隐性包含在了定义中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sumArrayOnGPU&lt;&lt;<span class="number">1</span>, <span class="number">32</span>&gt;&gt;(<span class="type">float</span> *A, <span class="type">float</span> *B, <span class="type">float</span> *C)</span><br></pre></td></tr></table></figure>

<h2 id="线程组织"><a href="#线程组织" class="headerlink" title="线程组织"></a>线程组织</h2><p>基于 CPU 和 GPU 的异构计算平台可以优势互补，CPU 负责处理逻辑复杂的串行程序，而 GPU 重点处理数据密集型的并行计算程序，从而发挥最大功效。</p>
<p>线程组织主要依据网格（现在网络这个词其实比较容易混淆，可以是神经网络可以是计算机网络，这里指的是线程的组织形式）模型。主要分 grid, block, thread，组织的方式就靠索引来决定，可以通过 block 索引和 thread 索引进行线程的定位。CUDA 提供了块内线程同步的方法，但是没有提供块间同步的原语。</p>
<h3 id="线程束分化"><a href="#线程束分化" class="headerlink" title="线程束分化"></a>线程束分化</h3><p>线程束 = warp</p>
<p>CPU 有很强的分支预测的能力，会预加载指令，如果预测正确，执行代价就很小，但是 GPU 在这方面是很弱的，因为线程束当中如果执行分支出现不同，那出现分支的线程就会被禁止执行，这也是用 GPU 做并行编程的时候需要参考的一个很重要的因素，保证并行的线程出现线程束分化的情况尽量少。</p>
<p>下面就是线程束分化的例子。</p>
<p><img data-src="http://15418.courses.cs.cmu.edu/spring2013content/lectures/02_basicarch/images/slide_030.png"></p>
<h3 id="并行归约问题"><a href="#并行归约问题" class="headerlink" title="并行归约问题"></a>并行归约问题</h3><p>并行归约是指如何对并行问题进行归约，比如说相邻配对和交错配对。</p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><p>管理 GPU 主要是通过 CUDA API 或者 <code>nvidia-smi</code> 命令来获取。</p>
<h2 id="SM（流式多处理器）"><a href="#SM（流式多处理器）" class="headerlink" title="SM（流式多处理器）"></a>SM（流式多处理器）</h2><p>上面讲的是抽象上的分层，但是实际的物理层面承载 GPU 的是 SM。最早的 GPU 架构叫 Fermi，然后是 Kepler，然后才是 Tesla。一般说的 <code>cm_20</code>, <code>sm_20</code> 就指这种计算能力和架构，新款的 GPU 计算能力要更强一点。</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>CUDA 的内存模型和 CPU 是类似的也是多级的结构。线程有局部内存，块之间有全局内存。GPU 和 CPU 都是主要采用 DRAM 来做主存，CPU 的一级缓存会用 SRAM 做。CPU 的多级缓存对用户来说不是很需要考虑，尽量屏蔽了其中的细节，但是 GPU 相对来说会把这种分级结构暴露给用户，这对编程来说也是一种新的挑战。</p>
<h2 id="后面"><a href="#后面" class="headerlink" title="后面"></a>后面</h2><p>用 GPU 计算一些计算密集型的程序，速度是真快，比 CPU 块很多，所以这也是为什么大量深度学习的应用都要通过 GPU 加速的原因。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2018/01/03/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2018/01/03/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/" class="post-title-link" itemprop="url">裸写反向误差传播</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-03 20:32:04" itemprop="dateCreated datePublished" datetime="2018-01-03T20:32:04+08:00">2018-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2018/01/03/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2018/01/03/从零实现反向误差传播/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文通过裸写神经网络的方法，帮助理解神经网络的工作方式，直接在 <a target="_blank" rel="noopener" href="https://www.kesci.com/apps/home/project/5a4a334225c4185a1b990d7e">klab</a> 上查看就可以。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/12/19/kube-dns-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/12/19/kube-dns-service/" class="post-title-link" itemprop="url">kube-dns service</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-19 22:28:28" itemprop="dateCreated datePublished" datetime="2017-12-19T22:28:28+08:00">2017-12-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/12/19/kube-dns-service/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/12/19/kube-dns-service/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>kube-dns 是 kubernetes 基于 DNS 的服务发现模块，主要由三个容器组成，分别是 dnsmasq, kube-dns, sidecar，整体的结构如图。</p>
<img data-src="/zh-CN/2017/12/19/kube-dns-service/kube-dns-infra.png" class="">

<h2 id="sidecar"><a href="#sidecar" class="headerlink" title="sidecar"></a>sidecar</h2><p>sidecar 是一个监控健康模块，同时向外暴露metrics 记录，但是为啥叫三蹦子不知道。</p>
<p>接受的探测参数是</p>
<p><code>--probe=&lt;label&gt;,&lt;server&gt;,&lt;dnsname&gt;[,&lt;interval_seconds&gt;][,&lt;type&gt;]</code></p>
<p>例子如下</p>
<p><code>--probe=dnsmasq,127.0.0.1:53,kubernetes.default.svc.cluster.local,5,A</code></p>
<p>等于是每隔 5s 向127.0.0.1:53 进行 DNS 查询 kubernetes.default.svc.cluster.local 的 A 记录</p>
<p>对应的结构体是</p>
<img data-src="/zh-CN/2017/12/19/kube-dns-service/dns-probe-option.png" class="">

<h2 id="dnsmasq"><a href="#dnsmasq" class="headerlink" title="dnsmasq"></a>dnsmasq</h2><p>dnsmasq-nanny 是 dnsmasq 的保姆进程，<a target="_blank" rel="noopener" href="http://www.thekelleys.org.uk/dnsmasq/doc.html">dnsmasq</a> 是一个简易的 DNS server。</p>
<p>dnsmasq-nanny “–” 后面是 dnsmasq 的参数，比如下面这个参数表示的是把 <code>server=/cluster.local/127.0.0.1#10053</code> 当作 dnsmasq 的配置，10053 是 kube-dns 的地址，也就是把 cluster.local 的域名拦截转到 kube-dns 进行解析，剩下的通过正常的域名解析流程。</p>
<p><code>--server=/cluster.local/127.0.0.1#10053</code></p>
<p>dnsmasq 简单来说扮演的是集群当中的一个传统 dns server 并且把集群内部的 dns 查询拦截到 kube-dns 当中通过中心化的方法进行 dns 查询，集群的 dns 查询主要依靠 kube-dns。</p>
<h2 id="kube-dns"><a href="#kube-dns" class="headerlink" title="kube-dns"></a>kube-dns</h2><p>kube-dns 主要基于 <a target="_blank" rel="noopener" href="https://github.com/skynetservices/skydns">skydns</a> 来实现。</p>
<p>在 <code>k8s.io/dns/pkg/dns/dns.go</code>  的 <code>KubeDNS.Start</code> 下面有 endpoints 和 services 的 controllers，会把 service 注册到 kube-dns 的 cache 当中 (k8s.io/dns/pkg/dns/treecache)，这里有 k8s 域名命名<a target="_blank" rel="noopener" href="https://github.com/kubernetes/dns/blob/master/docs/specification.md">规范</a></p>
<p>主要的实现方式是 skydns 接受一个后端实现。</p>
<img data-src="/zh-CN/2017/12/19/kube-dns-service/skydns-backend.png" class="">



<p><code>KubeDNS.Records</code> <code>KubeDNS.ReverseRecord</code> 基于 TreeCache 实现 DNS 记录存储的后端，从而使得 skydns 提供 DNS 服务。</p>
<img data-src="/zh-CN/2017/12/19/kube-dns-service/kube-dns.png" class="">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体来说 kube-dns 还是一个比较简单的模块，基于 kube-apiserver 的一个控制器，提供中心化的 DNS 查询。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">kube-controller-manager 分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-27 21:30:11" itemprop="dateCreated datePublished" datetime="2017-11-27T21:30:11+08:00">2017-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/11/27/kube-controller-分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>kube-controller-manager 可以认为是一个守护进程用于监视 apiserver 暴露的集群状态，并且不断地尝试把当前状态向集群的目标状态迁移。为了避免频繁查询 apiserver，apiserver 提供了 watch 接口用于监视资源的增加删除和更新，client-go 对此作了抽象，封装一层 informer 来表示本地 apiserver 状态的 cache。<a target="_blank" rel="noopener" href="https://v.qq.com/x/page/c03641vzw2m.html?start=7">这个视频</a> 有一个 Google 工程师讲解的 client-go 的详细内容，<a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/2693.html">这篇</a> 七牛前同事的文章介绍了 informer 的整体结构，写得也很好。</p>
<h3 id="client-当中的-controller"><a href="#client-当中的-controller" class="headerlink" title="client 当中的 controller"></a>client 当中的 controller</h3><p>处理事件的 controller 由几部分构成，首先是 Config 当中的可配置部分，下图是 controller 的关系，controller 实现了 Controller 接口。</p>
<img data-src="/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/controller.png" class="">

<p>controller 从 Queue 当中通过 Pop 获取对象交给 Process 回调处理，DeltaFIFO 和 FIFO 是类似的，只是 DeltaFIFO 可以处理删除事件，一般都用 DeltaFIFO。ListerWatcher 就是用客户端构造出来的，针对对应资源的 List Watch 方法的集合，List 用于获取最开始的对象获取，Watch 用于监控之后的变化，所有最开始的时候现有的对象会通过 List 传给 Add 回调，同步了当前状态以后再不断接受新的变化，但是 Watch 本身是有超时机制的，不能永久监听，所以再超时之后还会通过 List 方法，先同步一次再进行删除操作。Resync Period 表示把 cache 中的对象重新入队给回调函数处理，这种情况一般是可能你可能漏掉了更细操作，或者是之前的一些失败了。大部分情况用不到这个选项，可以非常相信 etcd 的功能。</p>
<p>调用路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cache.NewListWatchFromClient -&gt; listWatcher</span><br><span class="line">cache.NewIndexer -&gt; store</span><br><span class="line">cache.NewLister(store) -&gt; lister</span><br><span class="line">cache.NewReflector</span><br><span class="line">go refector.Run()</span><br></pre></td></tr></table></figure>

<p>还有一个关键结构是 reflector，reflector 会把对象转化成对应的需要的对象并且 Add 到 Queue 当中去。</p>
<p>Informer 本身的框架是异步的，所以为了做并发控制就引入了 workqueue 的组件，workqueue 有 rate limit 的功能，并且能够合并更新操作。</p>
<p>注意不要修改传入的对象，因为他们要和 cache 一致，如果要写对象的话，需要使用 api.Scheme.Copy 这个函数，进行深度拷贝，所有的 k8s Object 都要支持深拷贝的方法。</p>
<h3 id="kube-controller-当中的插件式-controller"><a href="#kube-controller-当中的插件式-controller" class="headerlink" title="kube-controller 当中的插件式 controller"></a>kube-controller 当中的插件式 controller</h3><p>在<code>k8s.io/kubernetes/cmd/kube-controller-manager/app/controllermanager.go </code> 中的<code>NewControllerInitializers</code> 函数有大部分 controller 的列表，<code>bootstrapsigner</code> 和 <code>tokencleaner</code> 是默认关闭的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ControllersDisabledByDefault = sets.NewString(</span><br><span class="line">	<span class="string">&quot;bootstrapsigner&quot;</span>,</span><br><span class="line">	<span class="string">&quot;tokencleaner&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>需要特殊初始化的是 <code>serviceaccount-tok</code>，另外的是 <code>NewControllerInitializers</code> 当中的 controller 了。所有的 controller 初始化函数都要满足如下接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InitFunc is used to launch a particular controller.  It may run additional &quot;should I activate checks&quot;.</span></span><br><span class="line"><span class="comment">// Any error returned will cause the controller process to `Fatal`</span></span><br><span class="line"><span class="comment">// The bool indicates whether the controller was enabled.</span></span><br><span class="line"><span class="keyword">type</span> InitFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx ControllerContext)</span></span> (<span class="type">bool</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h4 id="node-controller"><a href="#node-controller" class="headerlink" title="node controller"></a>node controller</h4><p>接下来看一个具体的 controller，<code>startNodeController</code>。</p>
<p><code>startNodeController</code> 首先解析 <code>ClusterCIDR</code> 和 <code>ServiceCIDR</code> 两个子网范围，下面是 <code>NodeController</code> 初始化需要的参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">nodeController, err := nodecontroller.NewNodeController(</span><br><span class="line">	ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">	ctx.InformerFactory.Core().V1().Nodes(),</span><br><span class="line">	ctx.InformerFactory.Extensions().V1beta1().DaemonSets(),</span><br><span class="line">	ctx.Cloud,</span><br><span class="line">	ctx.ClientBuilder.ClientOrDie(<span class="string">&quot;node-controller&quot;</span>),</span><br><span class="line">	ctx.Options.PodEvictionTimeout.Duration,</span><br><span class="line">	ctx.Options.NodeEvictionRate,</span><br><span class="line">	ctx.Options.SecondaryNodeEvictionRate,</span><br><span class="line">	ctx.Options.LargeClusterSizeThreshold,</span><br><span class="line">	ctx.Options.UnhealthyZoneThreshold,</span><br><span class="line">	ctx.Options.NodeMonitorGracePeriod.Duration,</span><br><span class="line">	ctx.Options.NodeStartupGracePeriod.Duration,</span><br><span class="line">	ctx.Options.NodeMonitorPeriod.Duration,</span><br><span class="line">	clusterCIDR,</span><br><span class="line">	serviceCIDR,</span><br><span class="line">	<span class="type">int</span>(ctx.Options.NodeCIDRMaskSize),</span><br><span class="line">	ctx.Options.AllocateNodeCIDRs,</span><br><span class="line">	ipam.CIDRAllocatorType(ctx.Options.CIDRAllocatorType),</span><br><span class="line">	ctx.Options.EnableTaintManager,</span><br><span class="line">	utilfeature.DefaultFeatureGate.Enabled(features.TaintBasedEvictions),</span><br><span class="line">	utilfeature.DefaultFeatureGate.Enabled(features.TaintNodesByCondition),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>InformerFactory 是用来构造具体 resource 的 informer 的工厂类型，构造了 pods, nodes, daemonsets 的 informer, 说明 node controller 需要 watch 这几种 resource 的变化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts an asynchronous loop that monitors the status of cluster nodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nc *Controller)</span></span> Run(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;) &#123;</span><br><span class="line">        <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">        glog.Infof(<span class="string">&quot;Starting node controller&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> glog.Infof(<span class="string">&quot;Shutting down node controller&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !controller.WaitForCacheSync(<span class="string">&quot;node&quot;</span>, stopCh, nc.nodeInformerSynced, nc.podInformerSynced, nc.daemonSetInformerSynced) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Incorporate the results of node status pushed from kubelet to master.</span></span><br><span class="line">        <span class="keyword">go</span> wait.Until(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := nc.monitorNodeStatus(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        glog.Errorf(<span class="string">&quot;Error monitoring node status: %v&quot;</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;, nc.nodeMonitorPeriod, wait.NeverStop)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nc.runTaintManager &#123;</span><br><span class="line">                <span class="keyword">go</span> nc.taintManager.Run(wait.NeverStop)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nc.useTaintBasedEvictions &#123;</span><br><span class="line">                <span class="comment">// Handling taint based evictions. Because we don&#x27;t want a dedicated logic in TaintManager for NC-originated</span></span><br><span class="line">                <span class="comment">// taints and we normally don&#x27;t rate limit evictions caused by taints, we need to rate limit adding taints.</span></span><br><span class="line">                <span class="keyword">go</span> wait.Until(nc.doNoExecuteTaintingPass, scheduler.NodeEvictionPeriod, wait.NeverStop)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Managing eviction of nodes:</span></span><br><span class="line">                <span class="comment">// When we delete pods off a node, if the node was not empty at the time we then</span></span><br><span class="line">                <span class="comment">// queue an eviction watcher. If we hit an error, retry deletion.</span></span><br><span class="line">                <span class="keyword">go</span> wait.Until(nc.doEvictionPass, scheduler.NodeEvictionPeriod, wait.NeverStop)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看一下运行的时候是如何做的，首先要调用 <code>controller.WaitForCacheSync</code> 等待 node，pod，daemonSet 的 inofrmer 同步，这是因为在 kube-controller-manager 当中使用的子 controller 使用的 informer 都是共享型的，也就是多个 controller 之间共享一个 informer  的 cache，所以在开始的时候需要保证所有的 sharedInformerFactory 创建的 informers 之间的 cache 先等待一次一致。controller 的读基本上是从 cache 读的，只要写才会打到 etcd 里面，然后等待 cache 的更新回调。</p>
<img data-src="/zh-CN/2017/11/27/kube-controller-%E5%88%86%E6%9E%90/monitor_node_status.png" class="">

<p>nodeController 主要分成两部分，一部分是 <code>monitorNodeStatus</code> , 它首先从 informer 的 cache 当中 list 新添加的节点和删除的节点，和 newZoneRepresentations。node 是分 zone 的，这在单可用区的 cluster 当中是个空字符串，但是如果 labels 中有 <code>failure-domain.beta.kubernetes.io/zone</code> 和 <code>failure-domain.beta.kubernetes.io/region</code> 就会构成不同的可用区的划分, 这个适用于仅仅在一家云厂商分不同可用区的时候可以用到。<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/admin/multiple-zones/">这篇文档</a> 描述了多 zone 的 cluster 的内容，没有 zone 有相应的可用状态，如果某个 zone 变成不可用需要把 pod 从这个 zone 当中剔除，所以 pod 的 failover 是以 zone 为单位的。</p>
<p>处理 node 比较啰嗦，<code>tryUpdateNodeStatus</code> 尝试获取当前的 conditions 更新并且获取 conditions。处理 node 过程主要是标记 node 为不可用的 node，或者把不可用的状态恢复过来。</p>
<p>接下来的就是处理 pod eviction 的部分，另外，<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/out-of-resource/">这篇文档</a>解释了一些 kubelet 支持的资源耗尽的情况下 kubelet 的剔除策略。</p>
<p><code>taintManager.Run</code> 处理 taint 的逻辑，<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/">这篇文档</a> 解释了 taint 和 toleration 的关系，以及基于 taint 的 eviction 策略。首先看 node 的更新，然后把上面不能 tolerate 的 pod 传给 handlePodUpdate，然后 pod 有更新也会 handlePodUpdate，在 pod 更新的时间中会让 node 抢占一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> nodeUpdate := &lt;-tc.nodeUpdateChannel:</span><br><span class="line">                tc.handleNodeUpdate(nodeUpdate)</span><br><span class="line">        <span class="keyword">case</span> podUpdate := &lt;-tc.podUpdateChannel:</span><br><span class="line">                <span class="comment">// If we found a Pod update we need to empty Node queue first.</span></span><br><span class="line">        priority:</span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                        <span class="keyword">select</span> &#123;</span><br><span class="line">                        <span class="keyword">case</span> nodeUpdate := &lt;-tc.nodeUpdateChannel:</span><br><span class="line">                                tc.handleNodeUpdate(nodeUpdate)</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span> priority</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// After Node queue is emptied we process podUpdate.</span></span><br><span class="line">                tc.handlePodUpdate(podUpdate)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是 eviction 的部分，基于 eviction 的会把 pod 直接删除，基于 taint 只是打上标记，然后通过上面的 tiantManager 剔除。和 pod eviction 不同，taint eviction 是通过限制加 taint 的速率控制 raltelimit 的。</p>
<h4 id="podGCController"><a href="#podGCController" class="headerlink" title="podGCController"></a>podGCController</h4><p>pod GC Controller 只 watch pod 一种资源，比较简单。</p>
<p>在 <code>k8s.io/kubernetes/pkg/controller/podgc/gc_controller.go</code> 下。</p>
<p><code>gcc.gcOrphaned</code> 删除 node 不存在的 pod，<code>gcc.gcUnscheduledTerminating</code> 删除正在终止，但是没有调度的 pod，<code>gcc.gcTerminated</code> 删除已经被终止的 pod。</p>
<h4 id="其他-controller"><a href="#其他-controller" class="headerlink" title="其他 controller"></a>其他 controller</h4><p>其他 controller 也是类似的，从 apiserver 获取状态，并且向对应的状态迁移，这也是为什么 kubernetes 的命令和资源都是宣告式的原因。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Kubernetes API 分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-05 02:40:14" itemprop="dateCreated datePublished" datetime="2017-11-05T02:40:14+08:00">2017-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/11/05/Kubernetes-API-分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="kubernetes-概览"><a href="#kubernetes-概览" class="headerlink" title="kubernetes 概览"></a>kubernetes 概览</h2><p>以下是 k8s 的整体架构，在 master 节点上主要是 kube-apiserver（整合了 kube-aggregator），还有 kube-scheduler，以及 kube-controller-manager，包括后端存储 etcd。</p>
<img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/architecture.png" class="">

<p>其中 kube-apiserver 是一个比较关键的部分，而且前期写得坑很多，导致这一部分虽然看起来是一个 API server 其实代码很复杂，特别冗余，而且目前对 kube-apiserver 还要做拆分，能够支持插入第三方的 apiserver，也就是又一个 aggregated apiserver 的 feature，也是和 kube-apiserver 和里面包的一层 genericserver 揉合在一起了，感觉一个大的系统 API server 越写越挫是一个通病，还好现在 k8s 迷途知返正在调整。</p>
<h2 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h2><p>Kube-apiserver 可以是认为在 generic server 上封装的一层官方默认的 apiserver，有第三方需要的情况下，自己也可以在 generic server 上封装一层加入到集成模式中，这里主要介绍 kube-apiserver 的结构。</p>
<h3 id="restful-API"><a href="#restful-API" class="headerlink" title="restful API"></a>restful API</h3><p>kube-apiserver 是一个 restful 服务，请求直接通过 HTTP 请求发送，例如创建一个 ubuntu 的 pod，用以下的 <code>pod.yaml</code> 文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ubuntu1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ubuntu1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ubuntu1</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;1d&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>执行命令 <code>kubectl create -f ./pod.yaml -v=8</code>，可以看到对应的 POST 请求如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Request Body: &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Pod&quot;,&quot;metadata&quot;:&#123;&quot;labels&quot;:&#123;&quot;name&quot;:&quot;ubuntu1&quot;&#125;,&quot;name&quot;:&quot;ubuntu1&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;containers&quot;:[&#123;&quot;command&quot;:[&quot;sleep&quot;,&quot;1d&quot;],&quot;image&quot;:&quot;ubuntu&quot;,&quot;name&quot;:&quot;ubuntu1&quot;&#125;],&quot;schedulerName&quot;:&quot;default-scheduler&quot;&#125;&#125;</span><br><span class="line">curl -k -v -XPOST  -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;User-Agent: kubectl/v1.7.5 (linux/amd64) kubernetes/17d7182&quot; https://localhost:6443/api/v1/namespaces/default/pods</span><br><span class="line">POST https://localhost:6443/api/v1/namespaces/default/pods 201 Created in 6 milliseconds</span><br><span class="line">Response Headers:</span><br><span class="line">    Content-Type: application/json</span><br><span class="line">    Content-Length: 1208</span><br><span class="line">    Date: Wed, 18 Oct 2017 15:04:17 GMT</span><br><span class="line">Response Body: &#123;&quot;kind&quot;:&quot;Pod&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;metadata&quot;:&#123;&quot;name&quot;:&quot;ubuntu1&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;selfLink&quot;:&quot;/api/v1/namespaces/default/pods/ubuntu1&quot;,&quot;uid&quot;:&quot;9c9af581-b415-11e7-8033-024d1ba659e8&quot;,&quot;resourceVersion&quot;:&quot;486154&quot;,&quot;creationTimestamp&quot;:&quot;2017-10-18T15:04:17Z&quot;,&quot;labels&quot;:&#123;&quot;name&quot;:&quot;ubuntu1&quot;&#125;&#125;,&quot;spec&quot;:&#123;&quot;volumes&quot;:[&#123;&quot;name&quot;:&quot;default-token-p0980&quot;,&quot;secret&quot;:&#123;&quot;secretName&quot;:&quot;default-token-p0980&quot;,&quot;defaultMode&quot;:420&#125;&#125;],&quot;containers&quot;:[&#123;&quot;name&quot;:&quot;ubuntu1&quot;,&quot;image&quot;:&quot;ubuntu&quot;,&quot;command&quot;:[&quot;sleep&quot;,&quot;1d&quot;],&quot;resources&quot;:&#123;&#125;,&quot;volumeMounts&quot;:[&#123;&quot;name&quot;:&quot;default-token-p0980&quot;,&quot;readOnly&quot;:true,&quot;mountPath&quot;:&quot;/var/run/secrets/kubernetes.io/serviceaccount&quot;&#125;],&quot;terminationMessagePath&quot;:&quot;/dev/termination-log&quot;,&quot;terminationMessagePolicy&quot;:&quot;File&quot;,&quot;imagePullPolicy&quot;:&quot;Always&quot;&#125;],&quot;restartPolicy&quot;:&quot;Always&quot;,&quot;terminationGracePeriodSeconds&quot;:30,&quot;dnsPolicy&quot;:&quot;ClusterFirst&quot;,&quot;serviceAccountName&quot;:&quot;default&quot;,&quot;serviceAccount&quot;:&quot;default&quot;,&quot;securityContext&quot;:&#123;&#125;,&quot;schedulerName&quot;:&quot;default-scheduler&quot;,&quot;tolerations&quot;:[&#123;&quot;key&quot;:&quot;node.kubernetes.io/not-ready&quot;,&quot;operator&quot;:&quot;Exists&quot;,&quot;effect&quot;:&quot;NoExecute&quot;,&quot;tolerationSeconds&quot;:300&#125;,&#123;&quot;key&quot;:&quot;node.alpha.kubernetes.io/unreachable&quot;,&quot;operator&quot;:&quot;Exists&quot;,&quot;effect&quot;:&quot;NoExecute&quot;,&quot;tolerationSeconds&quot;:300&#125;]&#125;,&quot;status&quot;:&#123;&quot;phase&quot;:&quot;Pending&quot;,&quot;qosClass&quot;:&quot;BestEffort&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>从 url path 里面可以看到几个划分，path 的分类大概有下面这几种。</p>
<img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/api-path.png" class="">

<p>路径上整体分成 group, version, resource, 作为核心 API group 的 core（包括 pod, node 之类的 resource)，不带 group，直接接在 /api/ 后面，其他的 api group 则接在 /apis 后面。以 pod 为例，pod 对应的数据类型如下，这个数据结构和 POST 请求中的结构的参数是一致的。</p>
<img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/pod.png" class="">

<p>如果是 job 的话则是在，<code>pkg/apis/batch/v2alpha1/types.go</code>，和 API 路径是对应的。例子当中 <code>kubectl</code> 加上 level 大于 8 的 log 就会打印请求和相应的 body，可以看到 request body 和上面的数据结构是一致的。这个请求会发送到 apiserver 进行处理并且返回存储之后的 pod。</p>
<h3 id="重要结构体"><a href="#重要结构体" class="headerlink" title="重要结构体"></a>重要结构体</h3><h4 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h4><p>父结构，主要的配置内容，其中有一个结构 <code>RESTOptionsGetter genericregistry.RESTOptionsGetter</code> 是和 API 初始化相关的，这个接口的实现是在 <code>k8s.io/apiserver/pkg/server/options/etcd.go</code> 中的 <code>storageFactoryRestOptionsFactory</code> 实现的，对应的实现函数是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *storageFactoryRestOptionsFactory)</span></span> GetRESTOptions(resource schema.GroupResource) (generic.RESTOptions, <span class="type">error</span>) &#123;</span><br><span class="line">	storageConfig, err := f.StorageFactory.NewConfig(resource)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> generic.RESTOptions&#123;&#125;, fmt.Errorf(<span class="string">&quot;unable to find storage destination for %v, due to %v&quot;</span>, resource, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret := generic.RESTOptions&#123;</span><br><span class="line">		StorageConfig:           storageConfig,</span><br><span class="line">		Decorator:               generic.UndecoratedStorage,</span><br><span class="line">		DeleteCollectionWorkers: f.Options.DeleteCollectionWorkers,</span><br><span class="line">		EnableGarbageCollection: f.Options.EnableGarbageCollection,</span><br><span class="line">		ResourcePrefix:          f.StorageFactory.ResourcePrefix(resource),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> f.Options.EnableWatchCache &#123;</span><br><span class="line">		sizes, err := ParseWatchCacheSizes(f.Options.WatchCacheSizes)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> generic.RESTOptions&#123;&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		cacheSize, ok := sizes[resource]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			cacheSize = f.Options.DefaultWatchCacheSize</span><br><span class="line">		&#125;</span><br><span class="line">		ret.Decorator = genericregistry.StorageWithCacher(cacheSize)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="APIGroupInfo"><a href="#APIGroupInfo" class="headerlink" title="APIGroupInfo"></a>APIGroupInfo</h4><img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/APIGroupInfo.png" class="">

<p>APIGroupInfo 主要定义了一个 API 组的相关信息，观察一下 APIGroupInfo 是如何初始化的。</p>
<p>在 <code>k8s.io/pkg/master/master.go</code> 当中，每个 Resource 都要提供自己的 Provider，比如说 <code>storagerest</code> 就在 <code>k8s.io/kubernetes/pkg/registry/storage/rest/storage_storage.go </code> 定义了 <code>NewRESTStorage</code> 方法。而默认的 resource 的 legacy provider 单独处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c.ExtraConfig.APIResourceConfigSource.AnyResourcesForVersionEnabled(apiv1.SchemeGroupVersion) &#123;</span><br><span class="line">	legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider&#123;</span><br><span class="line">		StorageFactory:       c.ExtraConfig.StorageFactory,</span><br><span class="line">		ProxyTransport:       c.ExtraConfig.ProxyTransport,</span><br><span class="line">		KubeletClientConfig:  c.ExtraConfig.KubeletClientConfig,</span><br><span class="line">		EventTTL:             c.ExtraConfig.EventTTL,</span><br><span class="line">		ServiceIPRange:       c.ExtraConfig.ServiceIPRange,</span><br><span class="line">		ServiceNodePortRange: c.ExtraConfig.ServiceNodePortRange,</span><br><span class="line">		LoopbackClientConfig: c.GenericConfig.LoopbackClientConfig,</span><br><span class="line">	&#125;</span><br><span class="line">	m.InstallLegacyAPI(&amp;c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后通过调用 <code>k8s.io/kubernetes/pkg/registry/core/rest.LegacyRESTStorageProvider</code> 的 <code>NewLegacyRESTStorage</code> 来初始化基础对象的 apigroup info，比如初始化 podStorage，serviceStorage 和 nodeStorage 等等。legacy ApiGrouInfo 的 Scheme, ParamaterCodec, NegotiatedSerializer 都是用 <code>    &quot;k8s.io/kubernetes/pkg/api&quot;</code> 包下的全局变量初始化的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scheme:                      api.Scheme,</span><br><span class="line">ParameterCodec:              api.ParameterCodec,</span><br><span class="line">NegotiatedSerializer:        api.Codecs,</span><br></pre></td></tr></table></figure>

<p>然后合并成一个 <code>restStorage</code> 存入 apiGroupInfo 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">restStorageMap := map[string]rest.Storage&#123;</span><br><span class="line">	&quot;pods&quot;:             podStorage.Pod,</span><br><span class="line">	&quot;pods/attach&quot;:      podStorage.Attach,</span><br><span class="line">	&quot;pods/status&quot;:      podStorage.Status,</span><br><span class="line">	&quot;pods/log&quot;:         podStorage.Log,</span><br><span class="line">	&quot;pods/exec&quot;:        podStorage.Exec,</span><br><span class="line">	&quot;pods/portforward&quot;: podStorage.PortForward,</span><br><span class="line">	&quot;pods/proxy&quot;:       podStorage.Proxy,</span><br><span class="line">	&quot;pods/binding&quot;:     podStorage.Binding,</span><br><span class="line">	&quot;bindings&quot;:         podStorage.Binding,</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>举个例子 podStorage 就是用的 <code>genericregistry.Store</code>，这是一个通用的 etc 辅助结构，把 etcd 抽象成存储结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// REST implements a RESTStorage for pods</span><br><span class="line">type REST struct &#123;</span><br><span class="line">	*genericregistry.Store</span><br><span class="line">	proxyTransport http.RoundTripper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="serialization"><a href="#serialization" class="headerlink" title="serialization"></a>serialization</h3><p><code>pkg/api.Codecs</code> 是全局默认的 codec 来自下面这段代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCodecFactory</span><span class="params">(scheme *runtime.Scheme)</span></span> CodecFactory &#123;</span><br><span class="line">	serializers := newSerializersForScheme(scheme, json.DefaultMetaFactory)</span><br><span class="line">	<span class="keyword">return</span> newCodecFactory(scheme, serializers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认具体定义了这几种 serilizer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func newSerializersForScheme(scheme *runtime.Scheme, mf json.MetaFactory) []serializerType &#123;</span><br><span class="line">	jsonSerializer := json.NewSerializer(mf, scheme, scheme, false)</span><br><span class="line">	jsonPrettySerializer := json.NewSerializer(mf, scheme, scheme, true)</span><br><span class="line">	yamlSerializer := json.NewYAMLSerializer(mf, scheme, scheme)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>而且标准库的 json 有很严重的性能问题，换用了 json-iter 但是有很多标准库不兼容的问题，性能提升了大概 20% 但是没办法和进主线，我尝试在上面工作的了一段时间，改了两个问题还是有错，由于时间关系，暂时放弃了这个工作，相关的 issue 在<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/54289">这里</a></p>
<h3 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h3><p>首先通过 <code>./staging/src/k8s.io/apiserver/pkg/server/config.go  </code> 下的 <code>DefaultBuildHandlerChain</code>  构建 filters。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func DefaultBuildHandlerChain(apiHandler http.Handler, c *Config) http.Handler &#123;</span><br><span class="line">	handler := genericapifilters.WithAuthorization(apiHandler, c.RequestContextMapper, c.Authorizer, c.Serializer)</span><br><span class="line">	handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.RequestContextMapper, c.LongRunningFunc)</span><br><span class="line">	handler = genericapifilters.WithImpersonation(handler, c.RequestContextMapper, c.Authorizer, c.Serializer)</span><br><span class="line">	if utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) &#123;</span><br><span class="line">		handler = genericapifilters.WithAudit(handler, c.RequestContextMapper, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		handler = genericapifilters.WithLegacyAudit(handler, c.RequestContextMapper, c.LegacyAuditWriter)</span><br><span class="line">	&#125;</span><br><span class="line">	failedHandler := genericapifilters.Unauthorized(c.RequestContextMapper, c.Serializer, c.SupportsBasicAuth)</span><br><span class="line">	if utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) &#123;</span><br><span class="line">		failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.RequestContextMapper, c.AuditBackend, c.AuditPolicyChecker)</span><br><span class="line">	&#125;</span><br><span class="line">	handler = genericapifilters.WithAuthentication(handler, c.RequestContextMapper, c.Authenticator, failedHandler)</span><br><span class="line">	handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, nil, nil, nil, &quot;true&quot;)</span><br><span class="line">	handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.RequestContextMapper, c.LongRunningFunc, c.RequestTimeout)</span><br><span class="line">	handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver, c.RequestContextMapper)</span><br><span class="line">	handler = apirequest.WithRequestContext(handler, c.RequestContextMapper)</span><br><span class="line">	handler = genericfilters.WithPanicRecovery(handler)</span><br><span class="line">	return handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic recover"></a>panic recover</h5><p><code>genericfilters.WithPanicRecovery</code> 在 handler 的最外层对出现的 panic 恢复，并且打印每次请求的 log，所以你想观察 API 请求的情况可以 <code>grep wrap.go</code> 就能看到。</p>
<h5 id="request-context"><a href="#request-context" class="headerlink" title="request context"></a>request context</h5><p><code>apirequest.WithRequestContext</code> 给 request 绑定一个 Context</p>
<h5 id="RequestInfo"><a href="#RequestInfo" class="headerlink" title="RequestInfo"></a>RequestInfo</h5><p>跟路 url 提取后续请求需要的 group, version, namespace, verb, resource 等信息。</p>
<h5 id="WithTimeoutForNonLongRunningRequests"><a href="#WithTimeoutForNonLongRunningRequests" class="headerlink" title="WithTimeoutForNonLongRunningRequests"></a>WithTimeoutForNonLongRunningRequests</h5><p>限制 API 调用时间，超时处理提前终止 write。</p>
<h5 id="WithCORS"><a href="#WithCORS" class="headerlink" title="WithCORS"></a>WithCORS</h5><p>允许跨域访问。</p>
<h5 id="authentication"><a href="#authentication" class="headerlink" title="authentication"></a>authentication</h5><p>在 <code>k8s.io/apiserver/pkg/endpoints/filters/authentication.go</code> 下。<code>WithAuthentication</code> 插入鉴权信息，例如证书鉴权，token 鉴权等，并且从鉴权信息当中获取 user 信息（可能是 service account 也可能是外部用户）user 身份是由<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/admin/authentication/">这</a> 里面的几种方式确认的</p>
<h5 id="authorization"><a href="#authorization" class="headerlink" title="authorization"></a>authorization</h5><p>检查是否有权限进行对应资源的操作。一种是 RBAC 一种是 Node。具体这两种方式可以看这个<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/admin/authorization/">介绍</a>，RBAC 主要是针对服务的，而 Node 模式主要是针对 kubelet 的。</p>
<h5 id="impersonation"><a href="#impersonation" class="headerlink" title="impersonation"></a>impersonation</h5><p>让用户伪装成其他用户，比如 admin 可以用普通用户的身份创建资源。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>通过 genericapiserver 的 <code>InstallLegacyAPIGroup</code> 就注册到路由当中。具体的做法就是根据 version, resource, sub resource, verb 等信息构造路由，然后用 <code>go-restful </code> 注册处理函数。比如说 GET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">route := ws.GET(action.Path).To(handler).</span><br><span class="line">	Doc(doc).</span><br><span class="line">	Param(ws.QueryParameter(&quot;pretty&quot;, &quot;If &#x27;true&#x27;, then the output is pretty printed.&quot;)).</span><br><span class="line">	Operation(&quot;read&quot;+namespaced+kind+strings.Title(subresource)+operationSuffix).</span><br><span class="line">	Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).</span><br><span class="line">	Returns(http.StatusOK, &quot;OK&quot;, producedObject).</span><br><span class="line">	Writes(producedObject)</span><br></pre></td></tr></table></figure>

<p>handler 里面做的内容就是序列化，然后根据具体的要求（GET DELETE 等）到 etcd 中操作，当然本身还有一层缓存，这取决于 API 的 options 是希望更新还是直接读缓存（缓存会比 etcd 旧一些），比如对于 kubelet 会不断查询 node 信息，但是 kubelet 本身并不需要最新的信息，这个时候就会从缓存中读取。</p>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>开启代理 <code>kubectl proxy</code>，就可以通过 localhost 直接访问 kube-apiserver HTTP 服务。然后执行 <code>go tool pprof http://localhost:8001/debug/pprof/profile</code> 可以获得 profile 结果，下图红色的部分就是调用耗时最多的部分。</p>
<img data-src="/zh-CN/2017/11/05/Kubernetes-API-%E5%88%86%E6%9E%90/prof.png" class="">

<p>除此之外，kube-apiserver 本身也暴露了很多 prometheus 的 metrics 但是往上现在没有现成的模板，只能根据自己的需求来在 prometheus 当作做 query。可以在 <code>k8s.io/apiserver/pkg/endpoints/metrics/metrics.go</code> 里面看到。</p>
<p>之前也说过，超时间调用时会打 log 的，在代码中保存了一些 trace 日志，可以通过 <code>grep Trace</code>来过滤。Trace[%d] 这样开头, %d 是一个 id 可以看到具体的 trace 信息。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/" class="post-title-link" itemprop="url">kubernetes 调度器指北</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-26 00:45:56" itemprop="dateCreated datePublished" datetime="2017-09-26T00:45:56+08:00">2017-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/09/26/kubernetes-指北/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近因为 k8s 的默认调度器功能太丰富，太“高级”了，一些屌丝特性没有满足，所以前段时间自己魔改了一下满足了一些屌丝特性，暂时叫做乞丐调度器，顺便把默认的调度器代码翻了一下，这里对默认的代码做一下总结。</p>
<h2 id="CreateScheduler"><a href="#CreateScheduler" class="headerlink" title="CreateScheduler"></a>CreateScheduler</h2><img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/CreateScheduler.png" class="">

<p>CreateScheduler 会从 policy file 当中获取算法的配置信息。接口<code>k8s.io/kubernetes/plugin/pkg/scheduler.Configurator</code> 定义了构造一个 scheduler 的配置信息。<code>k8s.io/kubernetes/plugin/pkg/scheduler/factor.ConfigFactory</code> 是这个接口的一个实现。<code>c.Create</code> 会把 <code>AlgorithmProvider</code> 配置的 <code>Predicate</code> 和 <code>Priority</code> 的 key 当作参数传给，<code>f.CreateFromKeys</code> 这样主要对应的 key 注册了的话就会有对应的算法绑定到 scheduler 上面。目前有两种 Provider，一种是用默认 predicate 和 默认 priority 的 AlgorithmProvider，另一种是把 <code>LeastRequestedPriority</code> 换成 <code>MostRequestedPriority</code> 的自动伸缩友好的 AlgorithmProvider。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Registers algorithm providers. By default we use &#x27;DefaultProvider&#x27;, but user can specify one to be used</span></span><br><span class="line"><span class="comment">// by specifying flag.</span></span><br><span class="line">factory.RegisterAlgorithmProvider(factory.DefaultProvider, defaultPredicates(), defaultPriorities())</span><br><span class="line"><span class="comment">// Cluster autoscaler friendly scheduling algorithm.</span></span><br><span class="line">factory.RegisterAlgorithmProvider(ClusterAutoscalerProvider, defaultPredicates(),</span><br><span class="line">	copyAndReplace(defaultPriorities(), <span class="string">&quot;LeastRequestedPriority&quot;</span>, <span class="string">&quot;MostRequestedPriority&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Scheduler-Server"><a href="#Scheduler-Server" class="headerlink" title="Scheduler Server"></a>Scheduler Server</h2><p><code>options.ScheduleServer</code> 是服务端对应的配置结构，其中有几个成员。</p>
<ol>
<li> KubeSchedulerConfiguration 调度器的配置</li>
<li> Master 表示 API server 的地址</li>
<li> Kubeconfig k8s 配置文件的路径</li>
</ol>
<p><code>func Run(s *options.SchedulerServer) error</code> 会根据 <code>Sechduler Server</code> 来运行。<code>EventBroadcaster</code> 接受事件，并且把事件发送给事件处理者（ EventSink watcher, log)，<code>startHTTP</code> 主要是是 profiling 接口，心跳检测接口和 prometheus 的 instrumenting 接口。<code>informerFactory</code>，看起来是一个异步同步信息的 cache，平时调度是直接走 cache，更新的时候才会走 API。最后配置了选主的话会从 Etcd 拿到锁，并且拿到 Master 的锁。</p>
<img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/scheduler-init.png" class="">

<h2 id="k8s-io-kubernetes-plugin-pkg-scheduler-Scheduler-Run"><a href="#k8s-io-kubernetes-plugin-pkg-scheduler-Scheduler-Run" class="headerlink" title="k8s.io/kubernetes/plugin/pkg/scheduler.Scheduler.Run"></a>k8s.io/kubernetes/plugin/pkg/scheduler.Scheduler.Run</h2><p>初始化以后，Run 对应的是一个 0 秒循环的大 loop（相当于每次 loop 等于主动调用一次 Go runtime.Sched())，在每次循环当中都会调用 <code>sched.scheduleOne</code>，首先 <code>NextPod</code> 会同步等待一个 pod 变成 available 的状态，并且跳过正在被删除的 pod，然后调用 <code>sched.schedule</code> 走到具体的调度算法当中，整个过程是串行，没有批量调度 pod 的操作。在进行具体的调度算法之后，会得到一个可行的 node，如果调度失败的话会，并且调度失败的原因是找不到合适的 node 的话，就尝试 <code>sched.preempt</code>，这个的作用就是尝试在替换现有 pod 的情况下能够获得调度机会的策略，那么就抢占已经被调度的 pod，标记目标 pod 的 Annotation 然后踢出权重最低的那个 pod。如果成果获得一个可调度的节点，就通过把本地 cache 先更新到已经调度之后的状态，标记 pod 已经在要调度的 node 上，也就是调用 <code>sched.assume</code> 假设 pod 已经调度到了节点上，再异步的通过 ApiServer 的接口，<code>sched.bind</code> 让 pod 正在运行到 node 上。</p>
<img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/scheduleOne.png" class="">

<h2 id="sched-schedule"><a href="#sched-schedule" class="headerlink" title="sched.schedule"></a>sched.schedule</h2><p>schedule 调用 <em>algorithm/scheduler_interface.go</em>下面定义的调度器的接口 <code>Schedule</code>。对应的实现在 <em>core/generic_scheduler.go</em> 下面。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScheduleAlgorithm is an interface implemented by things that know how to schedule pods</span></span><br><span class="line"><span class="comment">// onto machines.</span></span><br><span class="line"><span class="keyword">type</span> ScheduleAlgorithm <span class="keyword">interface</span> &#123;</span><br><span class="line">	Schedule(*v1.Pod, NodeLister) (selectedMachine <span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Preempt receives scheduling errors for a pod and tries to create room for</span></span><br><span class="line">	<span class="comment">// the pod by preempting lower priority pods if possible.</span></span><br><span class="line">	<span class="comment">// It returns the node where preemption happened, a list of preempted pods, and error if any.</span></span><br><span class="line">	Preempt(*v1.Pod, NodeLister, <span class="type">error</span>) (selectedNode *v1.Node, preemptedPods []*v1.Pod, err <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Predicates() returns a pointer to a map of predicate functions. This is</span></span><br><span class="line">	<span class="comment">// exposed for testing.</span></span><br><span class="line">	Predicates() <span class="keyword">map</span>[<span class="type">string</span>]FitPredicate</span><br><span class="line">	<span class="comment">// Prioritizers returns a slice of priority config. This is exposed for</span></span><br><span class="line">	<span class="comment">// testing.</span></span><br><span class="line">	Prioritizers() []PriorityConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Schedule</code> 会根据调度算法得到一个合适的节点，而 <code>Preempt</code> 则是尝试抢占一个 pod 以获得调度到节点上的机会。<code>Predicates</code> 和 <code>Priorities</code> 则是两个重要的部分，<code>Predicates</code> 类似一个过滤器，对节点进行筛选，而 <code>Priorities</code> 则是对筛选出来的节点进行权重的排序，最后得到一个合适的调度节点。</p>
<h3 id="算法工厂"><a href="#算法工厂" class="headerlink" title="算法工厂"></a>算法工厂</h3><p>算法工厂就是注册 <code>Preciate</code> 和 <code>Priority</code> 的地方，之前已经说了可以通过 <code>AlgorithmProvider</code> 获得一组 <code>Predicate</code> 和 <code>Priority</code>，比如 DefaultProvider 提供了默认的一套，如果不用 Provider，需要在 <a target="_blank" rel="noopener" href="https://github.com/kubernetes/examples/blob/master/staging/scheduler-policy-config.json">policy file</a> 当中另外指定要使用的 <code>Predicate</code> 和 <code>Priority</code>，不过目前好像没有用这种方式，还是通过 Provider 指定了一套要使用的算法 。注册 <code>AlgorithmProvider  </code>是通过<code>factory.RegisterAlgorithmProvider</code>，然后调用 <code>NewGenericScheduler</code> (在 <em>k8s.io/kubernetes/plugin/pkg/scheduler/core/generic_scheduler.go</em> 当中)，初始化要用到的 predicates 和 priorities。</p>
<h3 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h3><p><code>Schedule</code> 其实很简单，就是通过 <code>findNodesThatFit</code>，先根据 <code>Predicate</code> 过滤出合适的 Node，然后调用 <code>PrioritizeNodes</code>，用 <code>Priorities</code> 对 Node 根据算法的权重进行排序，因为每个 node 要走的流程是一样的并且最终结果相互没有影响，所以这个过程是并发的，<a target="_blank" rel="noopener" href="http://blog.csdn.net/waltonwang/article/details/54409917">这篇文章</a>的图画的很好，示意很明显。</p>
<img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/Schedule.jpeg" class="">

<p>最后会得到一个最理想的节点，再通过 bing 告诉 API server 这个节点被选中了。</p>
<h2 id="sched-preempt"><a href="#sched-preempt" class="headerlink" title="sched.preempt"></a>sched.preempt</h2><p>抢占过程是在 pod 没有找到合适的节点情况下，如果能在踢出一个 pod 获得调度机会的情况下进行抢占。抢占算是一个比较新的特性，在 1.8 里面都是默认关掉的，要打开的话需要指定<code>kube-scheduler</code> 的 <code>--feature-gates=PodPriority=true</code> 还有 apiserver 的 <code>--runtime-config=scheduling.k8s.io/v1alpha1=true</code>。可以通过添加 <code>PriorityClass</code> 把 pod 分权重，现在这个特性算是给 pod 也加上的权重。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">high-priority</span></span><br><span class="line"><span class="attr">value:</span> <span class="number">1000000</span></span><br><span class="line"><span class="attr">globalDefault:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;This priority class should be used for XYZ service pods only.&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后可以在<code>spec</code>当中指定 <code>priorityClassName: high-priority</code>，这样这么大的权重，这个 pod 就很难被抢占了，具体流程如下图。</p>
<img data-src="/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/schedule-preempt.png" class="">

<p><code>podEligibleToPreemptOthers</code> 主要判断如果 目标 pod 被标记为（通过 pod 的 annotation 标记）已经要抢占其他 pod，并且有一个优先级小于 目标 pod 的 pod 即将被删除 (<code>p.DeletionTimestamp != nil </code>)，就直接退出，因为这个时候这个被删除的 pod 其实在为目标 pod 腾出空间了，在下次调度的时候就会获得调度机会。<code>nodesWherePreemptionMightHelp</code>，类似于 schedule 的时候的 predicate 阶段，只不过多了一步是通过尝试移除 pod 跑一遍 predicates 看看这个节点能不能被通过。 <code>selectNodesForPreemption</code> 则和 priority 的阶段类似，把删除 pod 之后的可以通过的节点进行排序选出一个排名最高的节点。再通过 <code>selectVictimsOnNode</code> 把节点上的 pod 按照节点的 priority 排序选出“受害者”，越高越难被抢占。可以在 spec 里面设置这个值，选出了节点上的受害者以后，通过<code>pickOneNodeForPreemption</code>，主要的依据是拥有最低的最高 pod 权重的节点先被选出来，比如 node1 上 pod 的最高权重是 10，node2 上 pod 的最高权重是 8，那么 node2 被选中，如果有平局的话，最少的“受害者”先选，如果还平局，随机选一个。最后得到一个要被抢占的节点。</p>
<h2 id="自定义调度器的方式"><a href="#自定义调度器的方式" class="headerlink" title="自定义调度器的方式"></a>自定义调度器的方式</h2><p>自定义调度器有三种方法。</p>
<p>第一种是通过添加 <code>Predicate</code> 和 <code>Priority</code> 的方式，做微调，这种方式比较简单，只要定义好对应的函数并且通过函数工厂注册就可以。</p>
<p>第二种是使用自定义的调度器，具体的方法可以看<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/">官方文档</a>，通过把 pod 的 spec.schedulerName 指向自定义的调度器就可以把调度任务转到自己实现的服务。</p>
<p>第三种是使用 extender，extender 本身和调度器的过程类似，接口是如下定义的，主要是针对一些不算受集群本身控制的资源，需要通过外部调用来进行调度的情况，相关文档在<a href="blog.kubernetes.io/2017/03/advanced-scheduling-in-kubernetes.html">这里</a>。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>目前单机简单的测试条件下，1s 钟可以调度成功 450 左右的 pod，具体的性能参数还要慢慢挖掘。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">flannel 网络架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-21 00:15:27" itemprop="dateCreated datePublished" datetime="2017-09-21T00:15:27+08:00">2017-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/09/21/flannel-网络架构/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>flannel 是一个中心化的 overlay 容器网络，设计简单，容易理解，对于 k8s 来说，有一个假设：所有容器都可以和集群里任意其他容器或者节点通信，并且通信双方看到的对方的 IP 地址就是实际的地址，主要的好处就是不需要任何的端口映射和地址转换，拥有一张扁平的网络更容易管理，而且由于是基于 Etcd 的中心化的管理，所以对于一些 IP 变化异常频繁的场景来说，比一些去中心化的方案能够较及时同步网络拓扑关系。</p>
<h2 id="IP-地址的管理"><a href="#IP-地址的管理" class="headerlink" title="IP 地址的管理"></a>IP 地址的管理</h2><p>flannel 的 IP 地址是通过 Etcd 管理的，在 k8s 初始化的时候指定 pod 大网的网段 <code>--pod-network-cidr=10.244.0.0/16</code>，flanneld 可以直接通过 Etcd 管理，如果启动的时候指定了 <code>--kube-subnet-mgr</code>，可以直接通过 k8s 的 apiserver 来获得一个小网段的租期，通过 <code>kubectl get &lt;NodeName&gt; -o jsonpath=&#39;&#123;.spec.podCIDR&#125;&#39;</code> 可以获取对应节点的 CIDR 表示的网段，flannel 是以节点为单元划分小网段的，每个节点上的 pod 在这个例子当中是划分一个 10.244.x.0/24 的网段，所以总共能分配 255 个节点，每个节点上可以分配 253 个 pod。结构如下图所示，每个节点上都会有一个 flanneld 用于管理自己网段的租期。</p>
<img data-src="/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/flannel-02.png" class="">

<p>可以通过在 host 上 <code>cat /run/flannel/subnet.env</code> 查看同步下来的信息，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FLANNEL_NETWORK=10.244.0.0/16</span><br><span class="line">FLANNEL_SUBNET=10.244.0.1/24</span><br><span class="line">FLANNEL_MTU=8951</span><br><span class="line">FLANNEL_IPMASQ=true</span><br></pre></td></tr></table></figure>

<p>说明当前节点分配的网段是 <code>10.244.0.1/24</code>。在每个节点上因为已经确定了网段，用 ipam 就可以管理这一范围 ip 地址的分配，所以本身 pod 的 IP 分配和中心 Etcd 没有太多联系。</p>
<h2 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h2><p>简单来说就是通过建立 VXLAN  隧道，通过 UDP 把 IP 封装一层直接送到对应的节点，实现了一个大的 VLAN。没有使用 IPoIP 或者 GRE 主要是因为一些云厂商比如 AWS 的安全策略只能支持 TCP/UDP/ICMP。</p>
<p>flannel 本身会创建一个类似下面这样配置的 CNI bridge 设备。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mtu&quot;</span> <span class="punctuation">:</span> <span class="number">8973</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipMasq&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isGateway&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipam&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;10.244.0.1/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;routes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;dst&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;10.244.0.0/16&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>具体的网络拓扑图如下，所用的网段开头是 10.1，但是划分是一致的，图里面的 docker0 应该是 cni0，flannel0 应该是 flannel.1，这个命名的区别主要是不带点的是 UDP 封装，带点的是 vxlan 封装，图片比较早。</p>
<img data-src="/zh-CN/2017/09/21/flannel-%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/flannel-01.png" class="">

<p>第一步，首先是从容器中(10.1.20.3)出来，走桥接去到 cni0 (10.1.20.1)，通过<code>brctl show</code> 可以看到 <code>cni0</code> 接了两个容器的 veth。</p>
<p>第二步，然后根据路由规则，在宿主机上能够用<code>ip route</code>，找到一条走到大网段的路由。<code>10.15.0.0/16 dev flannel.1</code>，到达 <code>flannel.1</code>。</p>
<p>第三步，<code>flannel.1</code> 会走 vxlan，这个是在内核实现的，如果用 UDP 封装就是在用户态实现的，用户态实现的等于把包从内核过了两遍，没有直接用 vxlan 封装的直接走内核效率高，所以基本上不会使用 UDP 封装。对应的 vxlan 配置可以通过 <code>bridge fdb flannel.1</code> 看到，没有一条隧道就会有一条这样的转发表。因为到达每个对应网段的信息是在 Etcd 上分配的 flannel.1 只要 watch 然后发现有更改的时候对应配置隧道指向对应容器网段的宿主机 IP 就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8a:55:a7:e2:e9:18 dev flannel.1 dst 192.168.0.100 self permanent</span><br></pre></td></tr></table></figure>

<p>第四步，走宿主机的网络到达对端，对端的 vxlan 收到以后会拆开封装，丢到协议栈里面。</p>
<p>第五步，根据路由 <code>ip route</code>，中的一条<code>10.1.15.0/24 dev cni0  proto kernel  scope link  src 10.1.15.1</code>，送到 <code>cni0</code> 然后再转发给容器 <code>10.1.15.2</code>, 最后就能完成 pod 跨界点的互通了。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>因为整个的网段分配是存在 Etcd 里面的，节点只要 watch 然后根据网段建隧道就可以，相对来说中心化的系统设计比较简单，而且对于 IP 地址变动能够及时反应，特别是节点和容器都有剧烈变化的时候（别问我为啥物理节点会有剧烈变化，创业公司玩法怎么省钱怎么来……），相比于去中心化的一些设计能够更快同步一些。当然建隧道是一个点对点的规模，也就是如果有 n 个节点建隧道的话，每个节点上都要建 n-1 条隧道。</p>
<p>一种改进方式是使用 host-gw 的后端方式，以及 ipvlan，不过目前 ipvlan 还没有支持，<a target="_blank" rel="noopener" href="http://machinezone.github.io/research/networking-solutions-for-kubernetes/">这里</a>有一个各种后端实现的比较，vxlan 表现很最差，host-gw 的做法是不用隧道的方式，而是把路由信息直接写到节点上，直接打平到节点上，等于是节点之间是一个大网，每个节点上的小网段通过路由的方式和大网互通，将到达各个节点的网段的路由刷到节点上，而不是建 vxlan 隧道的方式，比如文中的例子，会有这样的路由。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.1.15.0/24 via 192.168.0.100 dev eth0 </span><br><span class="line">10.1.15.0/24 dev cni0  proto kernel  scope link  src 10.1.20.1</span><br></pre></td></tr></table></figure>

<p>然而，由于 flannel 只能够修改各个主机的路由表，一旦主机直接隔了个其他路由设备，比如三层路由器，这个包就会在路由设备上被丢掉。这样一来，host-gw 的模式就只能用于二层直接可达的网络。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">LC-trie 快速路由查找算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-05 00:46:17" itemprop="dateCreated datePublished" datetime="2017-09-05T00:46:17+08:00">2017-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/09/05/LC-trie-快速路由查找算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一般来说我们把字典树称作 trie，这是一个用于查找字符串的数据结构，举个简单的例子。下面就是一个把 b，abc，abd，bcd，abcd，efg，hii 这 6 个单词构造成字典树的例子。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/1.jpg" class="">

<p>在路由表中我们可以把子网看作一个二进制字符串，对于 IPv4 来说，字符串的长度就有 32 位。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/2.jpg" class="">

<p>以上面这个为例子，有编号 0 到 14 这几个二进制的字符串（字符集和只有 0 和 1），右边是他们的具体字符串，这样的字典树有一点像二叉树。如果把它画出来是这样的。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/3.jpg" class="">

<p>对这个树做压缩有一个办法就是把单节点作压缩，形成下面这个树，这个就是路径压缩，path compressed trie。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/4.jpg" class="">

<p>我们需要在压缩的地方进行标记，比如 skip 4 那里把一段 1011 压缩掉了。而 LC-trie 指的是 Level Compressed trie，这个树会把层级进行压缩，因为我们得到的这个字典树实际上是一个稀疏树，高度并不是平衡的，所以为了达到平衡，需要做的一件事情是把高度进行压缩，压缩之后变成下面这个形式，这样整棵树就会更加扁平。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/5.jpg" class="">

<p>这个树是有两种类型的节点，一种是 leaf，保存了路由具体的信息的叶子结点，一种是 trie node（tnode）保存了中间节点，子节点可能是 tnode 或者 leaf。trie 上有几个数据要存储，一个是 bits，这个表示的是子节点的选择度（这个怎么理解呢，就是我接下来的子节点是八叉了，因为我把原来的树压缩了，所以现在不需要二选一，现在直接来个八选一就可以），对于一个八叉的压缩来说，就要有一个 3 位的数字来存储，也就是 log(8)，当然也可以能是 7 叉，但是必须是 2 的指数。而 pos 表示的是从那个 bit 开始，它的作用和 skip 类似只不过不是一个相对值，而是一个累加值，表示我们要从哪开始（从字符串的起始位置开始数）。</p>
<p>我们先看一下搜索的代码，其实很简单，就是不断匹配公共前缀直到直到找到叶子节点（ bits == 0）。匹配前缀的方式比较 tricky，用异或进行确认。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rcu_read_lock needs to be hold by caller from readside */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> key_vector *<span class="title function_">fib_find_node</span><span class="params">(<span class="keyword">struct</span> trie *t,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> key_vector **tp, u32 key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key_vector</span> *<span class="title">pn</span>, *<span class="title">n</span> =</span> t-&gt;kv;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		pn = n;</span><br><span class="line">		n = get_child_rcu(n, index);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!n)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		index = get_cindex(key, n);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* This bit of code is a bit tricky but it combines multiple</span></span><br><span class="line"><span class="comment">		 * checks into a single check.  The prefix consists of the</span></span><br><span class="line"><span class="comment">		 * prefix plus zeros for the bits in the cindex. The index</span></span><br><span class="line"><span class="comment">		 * is the difference between the key and this value.  From</span></span><br><span class="line"><span class="comment">		 * this we can actually derive several pieces of data.</span></span><br><span class="line"><span class="comment">		 *   if (index &gt;= (1ul &lt;&lt; bits))</span></span><br><span class="line"><span class="comment">		 *     we have a mismatch in skip bits and failed</span></span><br><span class="line"><span class="comment">		 *   else</span></span><br><span class="line"><span class="comment">		 *     we know the value is cindex</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * This check is safe even if bits == KEYLENGTH due to the</span></span><br><span class="line"><span class="comment">		 * fact that we can only allocate a node with 32 bits if a</span></span><br><span class="line"><span class="comment">		 * long is greater than 32 bits.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (index &gt;= (<span class="number">1ul</span> &lt;&lt; n-&gt;bits)) &#123;</span><br><span class="line">			n = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* keep searching until we find a perfect match leaf or NULL */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (IS_TNODE(n));</span><br><span class="line"></span><br><span class="line">	*tp = pn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体看一下 <code>get_cindex</code> 匹配的方式，<code>#define get_cindex(key, kv) (((key) ^ (kv)-&gt;key) &gt;&gt; (kv)-&gt;pos)</code>，对 tnode 和 被比较的 key 做异或，这个怎么理解呢，看下面的图的例子这是正确匹配以后的结果，灰色代表 0，蓝色代表 1，两个值进行异或的话，首先 pos 会被右移掉，然后 bits 的部分会原样保留，因为 tnode 的这部分都是 0。然后亲址的部分如果完全匹配的话结果就都是 0 ，但是如果不完全匹配的话，结果就会比 index 还要大，因为高位还有 1，所以这就是为什么 <code>index &gt;= (1ul &lt;&lt; n-&gt;bits</code> 能判断是否匹配的前缀的原因。</p>
<img data-src="/zh-CN/2017/09/05/LC-trie-%E5%BF%AB%E9%80%9F%E8%B7%AF%E7%94%B1%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/6.jpg" class="">

<p>然后我们再看一下插入的流程。首先算出匹配到当前节点的子节点（有可能有，有可能没有）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fib_insert_node</span><span class="params">(<span class="keyword">struct</span> trie *t, <span class="keyword">struct</span> key_vector *tp,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> fib_alias *new, t_key key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key_vector</span> *<span class="title">n</span>, *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">	l = leaf_new(key, new);</span><br><span class="line">	<span class="keyword">if</span> (!l)</span><br><span class="line">		<span class="keyword">goto</span> noleaf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* retrieve child from parent node */</span></span><br><span class="line">	n = get_child(tp, get_index(key, tp));</span><br></pre></td></tr></table></figure>
<p>如果有子节点，就要创建一个新的 tnode，再把这个 key 给插入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Case 2: n is a LEAF or a TNODE and the key doesn&#x27;t match.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Add a new tnode here</span></span><br><span class="line"><span class="comment"> *  first tnode need some special handling</span></span><br><span class="line"><span class="comment"> *  leaves us in position for handling as case 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (n) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key_vector</span> *<span class="title">tn</span>;</span></span><br></pre></td></tr></table></figure>
<p><code>__fls</code> find last set bit，就是找到 pos，然后扩展出有两个选择（2 的 1 次方）的 tnode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tn = tnode_new(key, __fls(key ^ n-&gt;key), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!tn)</span><br><span class="line">	<span class="keyword">goto</span> notnode;</span><br></pre></td></tr></table></figure>
<p>设置 tn 的 父节点为 tp，然后把 key 插入到 tn 当中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* initialize routes out of node */</span></span><br><span class="line">	NODE_INIT_PARENT(tn, tp);</span><br><span class="line">	put_child(tn, get_index(key, tn) ^ <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start adding routes into the node */</span></span><br><span class="line">	put_child_root(tp, key, tn);</span><br><span class="line">	node_set_parent(n, tn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parent now has a NULL spot where the leaf can go */</span></span><br><span class="line">	tp = tn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Case 3: n is NULL, and will just insert a new leaf */</span></span><br><span class="line">node_push_suffix(tp, new-&gt;fa_slen);</span><br><span class="line">NODE_INIT_PARENT(l, tp);</span><br><span class="line">put_child_root(tp, key, l);</span><br></pre></td></tr></table></figure>
<p>开始进行平衡调整树形。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	trie_rebalance(t, tp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">notnode:</span><br><span class="line">	node_free(l);</span><br><span class="line">noleaf:</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下树的高度是如何进行调整的，从当前节点一直向上压缩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">trie_rebalance</span><span class="params">(<span class="keyword">struct</span> trie *t, <span class="keyword">struct</span> key_vector *tn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!IS_TRIE(tn))</span><br><span class="line">		tn = resize(t, tn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_WORK 10</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> key_vector *<span class="title function_">resize</span><span class="params">(<span class="keyword">struct</span> trie *t, <span class="keyword">struct</span> key_vector *tn)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IP_FIB_TRIE_STATS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">trie_use_stats</span> __<span class="title">percpu</span> *<span class="title">stats</span> =</span> t-&gt;stats;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>利用 <code>container_of</code> 获取父节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_vector</span> *<span class="title">tp</span> =</span> node_parent(tn);</span><br></pre></td></tr></table></figure>
<p>获取子节点，初始化 <code>max_work</code> 为 10。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cindex = get_index(tn-&gt;key, tp);</span><br><span class="line"><span class="type">int</span> max_work = MAX_WORK;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;In tnode_resize %p inflate_threshold=%d threshold=%d\n&quot;</span>,</span><br><span class="line">	 tn, inflate_threshold, halve_threshold);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* track the tnode via the pointer from the parent instead of</span></span><br><span class="line"><span class="comment"> * doing it ourselves.  This way we can let RCU fully do its</span></span><br><span class="line"><span class="comment"> * thing without us interfering</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BUG_ON(tn != get_child(tp, cindex));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Double as long as the resulting node has a number of</span></span><br><span class="line"><span class="comment"> * nonempty nodes that are above the threshold.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><code>should_inflate</code> 决定要不要压缩的依据是根据动态压缩算法来的（引用4），直观的来说就是高度超过了一个动态计算的阈值，并且还没压缩超过十次就会继续压缩。这个动态阈值的算法是用非空子节点的数目如果超过压缩之后子节点数目的一半就值得压缩。而 <code>inflate</code> 做的事情就把层级压缩一层，也就是把 children 的 children 按照 bits 的匹配放到 parent 的 new_children 当中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">while</span> (should_inflate(tp, tn) &amp;&amp; max_work) &#123;</span><br><span class="line">		tp = inflate(t, tn);</span><br><span class="line">		<span class="keyword">if</span> (!tp) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IP_FIB_TRIE_STATS</span></span><br><span class="line">			this_cpu_inc(stats-&gt;resize_node_skipped);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		max_work--;</span><br><span class="line">		tn = get_child(tp, cindex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update parent in case inflate failed */</span></span><br><span class="line">	tp = node_parent(tn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Return if at least one inflate is run */</span></span><br><span class="line">	<span class="keyword">if</span> (max_work != MAX_WORK)</span><br><span class="line">		<span class="keyword">return</span> tp;</span><br></pre></td></tr></table></figure>
<p>到这里说明一次调整都没有发生，说明节点很稀疏，也就是把节点分开。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Halve as long as the number of empty children in this</span></span><br><span class="line"><span class="comment">	 * node is above threshold.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (should_halve(tp, tn) &amp;&amp; max_work) &#123;</span><br><span class="line">		tp = halve(t, tn);</span><br><span class="line">		<span class="keyword">if</span> (!tp) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IP_FIB_TRIE_STATS</span></span><br><span class="line">			this_cpu_inc(stats-&gt;resize_node_skipped);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		max_work--;</span><br><span class="line">		tn = get_child(tp, cindex);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个孩子，可以进行 path compress，没必要再多一个中间节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Only one child remains */</span></span><br><span class="line">	<span class="keyword">if</span> (should_collapse(tn))</span><br><span class="line">		<span class="keyword">return</span> collapse(t, tn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update parent in case halve failed */</span></span><br><span class="line">	<span class="keyword">return</span> node_parent(tn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个的 LC-trie 的结构大致如此，主要用于路由表中路由规则的快速匹配，是在 3.6 之后引进的，摒弃了之前用哈希来查找路由表的算法。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/06.09.md">The-Art-Of-Programming-By-July</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nada.kth.se/~snilsson/publications/IP-address-lookup-using-LC-tries/">Fast address lookup for Internet routers</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/fib_trie.txt">LC-trie implementation notes</a></li>
<li><a target="_blank" rel="noopener" href="https://pdfs.semanticscholar.org/e880/05c8801983758917bf6e647da97f1027c86b.pdf">Implementing a dynamic compressed trie</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/08/07/neighboring-subsystem-%E6%B5%85%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/08/07/neighboring-subsystem-%E6%B5%85%E6%9E%90/" class="post-title-link" itemprop="url">neighboring subsystem 浅析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-08-07 00:11:36" itemprop="dateCreated datePublished" datetime="2017-08-07T00:11:36+08:00">2017-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/08/07/neighboring-subsystem-%E6%B5%85%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/08/07/neighboring-subsystem-浅析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>neighbor 在协议栈里指的是同一个 LAN 下面的邻居，也就是他们在 L3 上通过媒介或者点对点连接在了一起。邻居子系统同时也可以理解为一个 L2 和 L3 地址的转换器。邻居子系统的目的就在于上层协议不应该关心下层的地址信息，我发送过来的 IP 地址应该让下层来决定发送到哪个 MAC 地址。neighbor solicitation and neighbor advertisement，可以分别对应 ARP 的 request 请求和 ARP 的 reply 请求。</p>
<p>邻居子系统主要缓存两大块的内容，一个是 L3 到 L2 的映射解析的缓存，一个是 L2 头的缓存，缓存 L2 头的原因是大部分 L2 的头基本上是重复的，所以通过缓存头部可以加快协议的封装。</p>
<p>以下有几个相关结构体需要介绍一下。</p>
<p><code>struct neighbour</code> 代表的是一个邻居的信息，比如 L2 和 L3 地址等。</p>
<p><code>struct neigh_table</code> 代表的是一种邻居协议的接口(比如 ARP)。</p>
<p><code>struct neigh_params</code> 代表的是邻居协议在每个设备上的不同参数。</p>
<p><code>struct neigh_ops</code>  邻居对应的一些操作函数。</p>
<p><code>struct hh_cache</code> 缓存 L2 的头部，不是所有的设备都支持头部缓存。</p>
<p><code>struct rttable</code> 和 <code>struct dst_enry</code>， IPv4 的路由缓存信息是通过 <code>struct rttable</code> 缓存的。</p>
<img data-src="/zh-CN/2017/08/07/neighboring-subsystem-%E6%B5%85%E6%9E%90/p1.jpg" class="">

<p>这是 <code>dst_entry</code>, <code>hh_cache</code> 和 <code>neighbour</code> 之间的关系。</p>
<p>neighbor 结构是用 hash 存储的，key 是 L3 地址加设备（对应的 device 结构体）加一个随机值。hash 表通过 <code>neigh_hash_alloc</code> 和 <code>neigh_hash_free</code> 来分配和释放。<code>neigh_lookup</code> 就是通过 key 从 hash table 中找到对应的 neighbour 结构体，实现都不复杂，这里理解就可以了。</p>
<img data-src="/zh-CN/2017/08/07/neighboring-subsystem-%E6%B5%85%E6%9E%90/p2.jpg" class="">


<p>一般邻居子系统的缓存流程是这样的，如果 L3 的请求到达，地址解析缓存没有命中，把 L3 packet 入队，开始neighbor solicitation 等收到 neighbor advertisement 之后再出队并且发送。</p>
<h2 id="邻居状态信息-NUD-Netowork-Unreachablility-状态"><a href="#邻居状态信息-NUD-Netowork-Unreachablility-状态" class="headerlink" title="邻居状态信息 NUD(Netowork Unreachablility) 状态"></a>邻居状态信息 NUD(Netowork Unreachablility) 状态</h2><p>NUD state 本来是 IPv6 协议里的邻居关系的定义，但是在内核中沿用到了 IPv4 里面。</p>
<ul>
<li>NUD_NONE 这个 neighbour 刚开始建立，没有相关状态</li>
<li>NUD_INCOMPLETE 发送了获取 L2 地址的请求（通过 ARP 或者其他协议），但是没收到回复，并且之前不存在老缓存</li>
<li>NUD_REACHABLE neighbour 地址被缓存了，并且是可达的</li>
<li>NUD_FAILED 因为发送地址解析请求失败了，标志邻居不可达</li>
<li>NUD_STALE NUD_DELAY NUD_PROBE 是解析请求确认邻居可达的过程中的中间状态</li>
<li>NUD_NOARP 标志不需要用解析协议（虽然是 NOARP，但是别的协议也用这个标记），这是一个特殊情况。</li>
<li>NUD_PERMANET 标志邻居的地址解析是静态配置的</li>
</ul>
<p>这些是基本状态，根据这些基本状态组合了几个相对有语义的状态。</p>
<ul>
<li><p>NUD_VALID 表示该地址会是一个有效的地址</p>
<p> NUD_PERMANENT NUD_NOARP NUD_REACHABLE NUD_PROBE NUD_STALE NUD_DELAY</p>
</li>
<li><p>NUD_CONNECTED 是 NUD_VALID 的子集，去除了待决的中间状态</p>
<p> NUD_PERMANENT NUD_NOARP NUD_REACHABLE</p>
</li>
<li><p>NUD_IN_TIMER 表示在这个状态下正在执行一个定时任务，一般是状态不明了的时候</p>
<p> NUD_INCOMPLETE NUD_DELAY NUD_PROBE</p>
</li>
</ul>
<p>邻居的可达性可以通过两点来确认，收到了一个地址解析协议的单播回复，或者通过外部信息确认（比如收到了这个邻居的 TCP 报文，当然这个 IP 可能不是自己的邻居，但是可以可以确定对应网关『作为邻居』的可达性）。</p>
<h2 id="确认邻居信息"><a href="#确认邻居信息" class="headerlink" title="确认邻居信息"></a>确认邻居信息</h2><p>IP 层会调用<code>ipv4_confirm_neigh</code> 来确认映射地址，如果有 gateway 用 gateway，没有 gateway 开始查缓存。在 <code>net/ipv4/ip_output.c</code> 中的对应代码，就是查缓存的 neighbour 结构体，如果这个结构体不存在的话就要开始<code>confirm</code> 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">neigh = __ipv4_neigh_lookup_noref(dev, nexthop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!neigh))</span><br><span class="line">	neigh = __neigh_create(&amp;arp_tbl, &amp;nexthop, dev, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(neigh)) &#123;</span><br><span class="line">	<span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">	sock_confirm_neigh(skb, neigh);</span><br><span class="line">	res = neigh_output(neigh, skb);</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock_bh();</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 TCP 收到报文（比如对端的 SYN/ACK 时），这种外部信息说明其实这个节点是可达的（不是来自 gateway），也可以更新缓存。</p>
<p>另外，<code>neigh_connect</code> 和 <code>neigh_suspect</code> 是两个状态转换时会调用的函数。</p>
<p>当 neigh 进入 <code>NUD_REACHABLE</code> ， <code>neigh_connect</code> 把 <code>neigh-&gt;output</code> 的函数指向 <code>connected_output</code> 这个函数，它会在调用 <code>dev_queue_xmit</code> 之前填充 L2 头部，把包直接发出去。</p>
<p>当从 <code>NUD_REACHBLE</code> 转换成 <code>NUD_STALE</code> 或者 <code>NUD_DELAY</code>，<code>neigh_suspect</code> 会强制进行可达性的确认，通过把 <code>neighbor-&gt;output</code> 指向 <code>neigh_ops-&gt;output</code>， 也就是 <code>neigh_resolve_output</code>，它会在调用 <code>dev_queue_xmit</code> 之前先把地址解析出来，等把地址解析完成以后再把缓存的包发送出去。</p>
<h2 id="更新邻居信息"><a href="#更新邻居信息" class="headerlink" title="更新邻居信息"></a>更新邻居信息</h2><p>邻居信息更新的入口函数就是 <code>neigh_update</code>，这个函数定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">neigh_update</span><span class="params">(<span class="keyword">struct</span> neighbour *neigh, <span class="type">const</span> u8 *lladdr, u8 new,</span></span><br><span class="line"><span class="params">		 u32 flags, u32 nlmsg_pid)</span></span><br></pre></td></tr></table></figure>

<p>首先做一些预先检查，如果是管理员配置，原来的配置就不能是 PERMANENT 或者 NOARP 的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(flags &amp; NEIGH_UPDATE_F_ADMIN) &amp;&amp;</span><br><span class="line">    (old &amp; (NUD_NOARP | NUD_PERMANENT)))</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>标记为 dead，然后 goto out</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (neigh-&gt;dead)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>
<p>如果更新为无效的标记的话，删除 timer，并且 supect 一下，如果是 NUD_CONNECTED 状态。<br>如果是需要标记为失败的 neigh(之前是 INCOMPLETE|NUD_PROBE)，则调用 <code>neigh_invalidate</code>，让这个 neigh 无效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(new &amp; NUD_VALID)) &#123;</span><br><span class="line">	neigh_del_timer(neigh);</span><br><span class="line">	<span class="keyword">if</span> (old &amp; NUD_CONNECTED)</span><br><span class="line">		neigh_suspect(neigh);</span><br><span class="line">	neigh-&gt;nud_state = new;</span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	notify = old &amp; NUD_VALID;</span><br><span class="line">	<span class="keyword">if</span> ((old &amp; (NUD_INCOMPLETE | NUD_PROBE)) &amp;&amp;</span><br><span class="line">	    (new &amp; NUD_FAILED)) &#123;</span><br><span class="line">		neigh_invalidate(neigh);</span><br><span class="line">		notify = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是三个条件，一个是 device 没有硬件地址，用 neigh-&gt;ha，如果 lladdr 提供了并且老的是有效的，使用老的地址，如果 lladdr 没有提供，直接使用老的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare new lladdr with cached one */</span></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;addr_len) &#123;</span><br><span class="line">	<span class="comment">/* First case: device needs no address. */</span></span><br><span class="line">	lladdr = neigh-&gt;ha;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (lladdr) &#123;</span><br><span class="line">	<span class="comment">/* The second case: if something is already cached</span></span><br><span class="line"><span class="comment">	   and a new address is proposed:</span></span><br><span class="line"><span class="comment">	   - compare new &amp; old</span></span><br><span class="line"><span class="comment">	   - if they are different, check override flag</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((old &amp; NUD_VALID) &amp;&amp;</span><br><span class="line">	    !<span class="built_in">memcmp</span>(lladdr, neigh-&gt;ha, dev-&gt;addr_len))</span><br><span class="line">		lladdr = neigh-&gt;ha;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* No address is supplied; if we know something,</span></span><br><span class="line"><span class="comment">	   use it, otherwise discard the request.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!(old &amp; NUD_VALID))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	lladdr = neigh-&gt;ha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>NUD_CONNECTED</code> 更新 confirm 的时间，更新『更新』的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new &amp; NUD_CONNECTED)</span><br><span class="line">	neigh-&gt;confirmed = jiffies;</span><br><span class="line">neigh-&gt;updated = jiffies;</span><br></pre></td></tr></table></figure>
<p><code>NEIGH_UPDATE_F_OVERRIDE_ISROUTER</code> 标记的是当前 neigh 是一个 router。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If entry was valid and address is not changed,</span></span><br><span class="line"><span class="comment">   do not change entry state, if new one is STALE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line">update_isrouter = flags &amp; NEIGH_UPDATE_F_OVERRIDE_ISROUTER;</span><br><span class="line"><span class="keyword">if</span> (old &amp; NUD_VALID) &#123;</span><br><span class="line">	<span class="keyword">if</span> (lladdr != neigh-&gt;ha &amp;&amp; !(flags &amp; NEIGH_UPDATE_F_OVERRIDE)) &#123;</span><br><span class="line">		update_isrouter = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; NEIGH_UPDATE_F_WEAK_OVERRIDE) &amp;&amp;</span><br><span class="line">		    (old &amp; NUD_CONNECTED)) &#123;</span><br><span class="line">			lladdr = neigh-&gt;ha;</span><br><span class="line">			new = NUD_STALE;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (lladdr == neigh-&gt;ha &amp;&amp; new == NUD_STALE &amp;&amp;</span><br><span class="line">		    !(flags &amp; NEIGH_UPDATE_F_ADMIN))</span><br><span class="line">			new = old;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是更新操作，删除老的 timer，如果需要 timer，更新新的 timer，并且设置新状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new != old) &#123;</span><br><span class="line">	neigh_del_timer(neigh);</span><br><span class="line">	<span class="keyword">if</span> (new &amp; NUD_PROBE)</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;neigh-&gt;probes, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (new &amp; NUD_IN_TIMER)</span><br><span class="line">		neigh_add_timer(neigh, (jiffies +</span><br><span class="line">					((new &amp; NUD_REACHABLE) ?</span><br><span class="line">					 neigh-&gt;parms-&gt;reachable_time :</span><br><span class="line">					 <span class="number">0</span>)));</span><br><span class="line">	neigh-&gt;nud_state = new;</span><br><span class="line">	notify = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新 <code>neigh-&gt;ha</code>，如果 <code>lladdr</code> 和 <code>neigh-&gt;ha</code> 不同的话。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lladdr != neigh-&gt;ha) &#123;</span><br><span class="line">	write_seqlock(&amp;neigh-&gt;ha_lock);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;neigh-&gt;ha, lladdr, dev-&gt;addr_len);</span><br><span class="line">	write_sequnlock(&amp;neigh-&gt;ha_lock);</span><br><span class="line">	neigh_update_hhs(neigh);</span><br><span class="line">	<span class="keyword">if</span> (!(new &amp; NUD_CONNECTED))</span><br><span class="line">		neigh-&gt;confirmed = jiffies -</span><br><span class="line">			      (NEIGH_VAR(neigh-&gt;parms, BASE_REACHABLE_TIME) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	notify = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (new == old)</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>
<p>根据状态调用 connect 和 suspect</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new &amp; NUD_CONNECTED)</span><br><span class="line">	neigh_connect(neigh);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	neigh_suspect(neigh);</span><br></pre></td></tr></table></figure>
<p>如果之前老的不是 <code>NUD_VALID</code>，就会把 skb 从 arp_queue，并且释放 arp_queue。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(old &amp; NUD_VALID)) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Again: avoid dead loop if something went wrong */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (neigh-&gt;nud_state &amp; NUD_VALID &amp;&amp;</span><br><span class="line">	       (skb = __skb_dequeue(&amp;neigh-&gt;arp_queue)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span> =</span> skb_dst(skb);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">neighbour</span> *<span class="title">n2</span>, *<span class="title">n1</span> =</span> neigh;</span><br><span class="line">		write_unlock_bh(&amp;neigh-&gt;lock);</span><br><span class="line"></span><br><span class="line">		rcu_read_lock();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Why not just use &#x27;neigh&#x27; as-is?  The problem is that</span></span><br><span class="line"><span class="comment">		 * things such as shaper, eql, and sch_teql can end up</span></span><br><span class="line"><span class="comment">		 * using alternative, different, neigh objects to output</span></span><br><span class="line"><span class="comment">		 * the packet in the output path.  So what we need to do</span></span><br><span class="line"><span class="comment">		 * here is re-lookup the top-level neigh in the path so</span></span><br><span class="line"><span class="comment">		 * we can reinject the packet there.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		n2 = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (dst) &#123;</span><br><span class="line">			n2 = dst_neigh_lookup_skb(dst, skb);</span><br><span class="line">			<span class="keyword">if</span> (n2)</span><br><span class="line">				n1 = n2;</span><br><span class="line">		&#125;</span><br><span class="line">		n1-&gt;output(n1, skb);</span><br><span class="line">		<span class="keyword">if</span> (n2)</span><br><span class="line">			neigh_release(n2);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">		write_lock_bh(&amp;neigh-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line">	__skb_queue_purge(&amp;neigh-&gt;arp_queue);</span><br><span class="line">	neigh-&gt;arp_queue_len_bytes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新 flag，发送 notify 通过 rtnetlink 通知 nlmsg_pid 对应的进程，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (update_isrouter) &#123;</span><br><span class="line">	neigh-&gt;flags = (flags &amp; NEIGH_UPDATE_F_ISROUTER) ?</span><br><span class="line">		(neigh-&gt;flags | NTF_ROUTER) :</span><br><span class="line">		(neigh-&gt;flags &amp; ~NTF_ROUTER);</span><br><span class="line">&#125;</span><br><span class="line">write_unlock_bh(&amp;neigh-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (notify)</span><br><span class="line">	neigh_update_notify(neigh, nlmsg_pid);</span><br></pre></td></tr></table></figure>
<p>这就是邻居信息的更新流程。</p>
<p>当然还有一个缓存项是 L2 header 的缓存这里就简单略过了。</p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>接下来说一下 ARP 相关的内容，ARP 本身的格式其实很简单。</p>
<p>邻居子系统有一个比较关键的协议就是 ARP，这里简单介绍一下 ARP 协议，我们来看一下 ARP 的格式。</p>
<img data-src="/zh-CN/2017/08/07/neighboring-subsystem-%E6%B5%85%E6%9E%90/p3.jpg" class="">

<p>先是两个字节的 L2 类型，然后是两个字节的 L3 类型。一般 L2 是 1 (以太网)，L3 是 0x0800 (IPV4)，接着跟着的是 L2 类型的长度和 L3 类型的长度，这里 Ethernet 的 MAC 地址是 6 个字节，IPV4 的 IP 地址是 4 个字节，接着是两个字节的操作，1 表示请求，2 表示回复，然后是发送端 L2 的地址，L3 的地址，接着是接收端 L2 和 L3 的地址。整个翻译过来就是『我（MAC 是 0a:00:27:00:00:00 IP 是 192.168.56.1）广而告之（MAC 广播地址），问一下谁知道 192.168.56.102 的地址』。</p>
<h3 id="gARP-gratuitous-ARP"><a href="#gARP-gratuitous-ARP" class="headerlink" title="gARP (gratuitous ARP)"></a>gARP (gratuitous ARP)</h3><p>听起来像是一个无理由的 ARP 请求，实际上是一种主动通知的 ARP 请求。gARP 本身不是一个查询请求，而是一个通知请求，主要运用于主动通知 L2 地址改变，重复地址发现（请求解析自己的地址，如果收到回复说明有地址重复）。</p>
<p>还有就是 VIP，一般的作用是在本地网路中有两台机器，一台作为备机，一台作为主机，当主机 failover 的时候，备机可以继续『冒充』主机的 IP 地址，具体的做法就是主动发送请求，解析的 MAC 和 IP 都和 source 一样，老的 server 肯定不会回答这个 ARP，交换机上已经没有这个端口的缓存，会进行广播，让所有的接收者都会更新自己的缓存。也就是发送了一个一去不复返的请求，让所有的邻居更新了自己的 ARP 缓存，从而替代了老 server 的 IP，这就是 VIP 通过 ARP 实现的 failover。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>邻居子系统很大一部分的作用就是解析和缓存地址映射，主要是通过 ARP 来完成，而且 ARP 本身也有很多使用的姿势，也就上面说到的 gARP，邻居子系统是沟通路由子系统，以及 L2 和 L3 的桥梁。</p>
<p>参考：</p>
<ol>
<li> <em>Understanding Linux Network Internals</em></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/07/10/IP-%E7%9A%84%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/07/10/IP-%E7%9A%84%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84/" class="post-title-link" itemprop="url">IP 的分片与重组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-10 03:18:25" itemprop="dateCreated datePublished" datetime="2017-07-10T03:18:25+08:00">2017-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/07/10/IP-%E7%9A%84%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/07/10/IP-的分片与重组/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ip 分片的主体函数在 <code>ip_fragment</code> 当中，重组则在 <code>ip_defrag</code> 当中。第一个分片的标志 Offset 为 0，MF 为 1，之后的分片则是 Offset 非 0，MF 为 1，最后一个分片则是 Offset 非 0，但是 MF 为 0。以此来分别当前的 IP packet 是否是一个分片。从 IP 层向上层协议发送数据包的时候就会进行重组，比如在 <code>ip_local_deliver</code> 当中，调用了。说一句题外话， TCP 有 MSS ，保障 TCP message 不超过分片大小，这样是一种对底层协议有感知的行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;</span><br><span class="line">	<span class="keyword">if</span> (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h2><p><code>ip_is_fragment</code> 对应的条件就是 <code>(iph-&gt;frag_off &amp; htons(IP_MF | IP_OFFSET)) != 0;</code>。</p>
<p>在 <code>ip_fragment</code> 当中会碰到几种情况，一种是不需要分片的 IP packet，这种很好，省心，一种是需要分片的 IP packet，这种最操心，还有一种是已经按分片负载的长度分配好了 buffer 只要加个头就相当于分片完成了就也非常棒。要从头开始进行分配的情况属于慢速路径，而已经有 buffer 准好的，直接加个头就完事的属于快速路径，快速路径的内存拷贝代价更低。</p>
<p><code>ip_fragment</code> 主要检查 IP 是否允许进行分片，不然的话就返回一个 ICMP 错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> ip_hdr(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((iph-&gt;frag_off &amp; htons(IP_DF)) == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> ip_do_fragment(net, sk, skb, output);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!skb-&gt;ignore_df ||</span><br><span class="line">	     (IPCB(skb)-&gt;frag_max_size &amp;&amp;</span><br><span class="line">	      IPCB(skb)-&gt;frag_max_size &gt; mtu))) &#123;</span><br><span class="line">	IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);</span><br><span class="line">	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,</span><br><span class="line">		  htonl(mtu));</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> -EMSGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip_do_fragment(net, sk, skb, output);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后进入到 <code>ip_do_fragment</code> 当中。我们先看一下慢速路径是如何处理。</p>
<p>首先知道 IP 头部的长度，已经负载 (left)，然后当前的指针，已经链路层需要预留的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slow_path:</span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">	left = skb-&gt;len - hlen;		<span class="comment">/* Space per frame */</span></span><br><span class="line">	ptr = hlen;		<span class="comment">/* Where to start from */</span></span><br><span class="line"></span><br><span class="line">	ll_rs = LL_RESERVED_SPACE(rt-&gt;dst.dev);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IP 的 offset，以及不是最后一个分片的标志位，这里是进行分片的，不知道为什么要获取一些重组时候需要的数据，TODO。</p>
<pre><code>/*
 *    Fragment the datagram.
 */

offset = (ntohs(iph-&gt;frag_off) &amp; IP_OFFSET) &lt;&lt; 3;
not_last_frag = iph-&gt;frag_off &amp; htons(IP_MF);
</code></pre>
<p>调整要分配的 skb_buff 的长度，首先不能超过 mtu，然后最后一段要按 8 对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Keep copying data until we run out.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	len = left;</span><br><span class="line">	<span class="comment">/* IF: it doesn&#x27;t fit, use &#x27;mtu&#x27; - the data space left */</span></span><br><span class="line">	<span class="keyword">if</span> (len &gt; mtu)</span><br><span class="line">		len = mtu;</span><br><span class="line">	<span class="comment">/* IF: we are not sending up to and including the packet end</span></span><br><span class="line"><span class="comment">	   then align the next start on an eight byte boundary */</span></span><br><span class="line">	<span class="keyword">if</span> (len &lt; left)	&#123;</span><br><span class="line">		len &amp;= ~<span class="number">7</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate buffer */</span></span><br><span class="line">	skb2 = alloc_skb(len + hlen + ll_rs, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!skb2) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>设置分片的元数据，<code>ip_copy_metadata</code> 会拷贝优先级，协议类型，等辅助信息。然后保留 L2 的头部空间，接着在保留 IP 层的长度，然后设置网络头部，接着设置传输层头部的位置，就是一些初始化的动作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Set up data on packet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">ip_copy_metadata(skb2, skb);</span><br><span class="line">skb_reserve(skb2, ll_rs);</span><br><span class="line">skb_put(skb2, len + hlen);</span><br><span class="line">skb_reset_network_header(skb2);</span><br><span class="line">skb2-&gt;transport_header = skb2-&gt;network_header + hlen;</span><br></pre></td></tr></table></figure>

<p>设置对应 sk 为 <code>owner</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Charge the memory for the fragment to any owner</span></span><br><span class="line"><span class="comment"> *	it might possess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;sk)</span><br><span class="line">	skb_set_owner_w(skb2, skb-&gt;sk);</span><br></pre></td></tr></table></figure>

<p>拷贝网络层的头部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Copy the packet header into the new buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">skb_copy_from_linear_data(skb, skb_network_header(skb2), hlen);</span><br></pre></td></tr></table></figure>

<p>然后拷贝真正的负载，这里没有直接用 memcpy 的原因是，对应的空间不一定是连续的，它可能含有 frag_list，甚至是之前检查没有通过的快速路径到达了这里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Copy a block of the IP datagram.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (skb_copy_bits(skb, ptr, skb_transport_header(skb2), len))</span><br><span class="line">	BUG();</span><br><span class="line">left -= len;</span><br></pre></td></tr></table></figure>

<p>设置 IP 头的偏移和分片标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Fill in the new header fields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">iph = ip_hdr(skb2);</span><br><span class="line">iph-&gt;frag_off = htons((offset &gt;&gt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IPCB(skb)-&gt;flags &amp; IPSKB_FRAG_PMTU)</span><br><span class="line">	iph-&gt;frag_off |= htons(IP_DF);</span><br></pre></td></tr></table></figure>

<p>如果是第一个分片就尝试更新 IP options。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ANK: dirty, but effective trick. Upgrade options only if</span></span><br><span class="line"><span class="comment"> * the segment to be fragmented was THE FIRST (otherwise,</span></span><br><span class="line"><span class="comment"> * options are already fixed) and make it ONCE</span></span><br><span class="line"><span class="comment"> * on the initial skb, so that all the following fragments</span></span><br><span class="line"><span class="comment"> * will inherit fixed options.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">	ip_options_fragment(skb);</span><br></pre></td></tr></table></figure>

<p>最后修改位移，更新标记位，计算 checksum，然后送到 output。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Added AC : If we are fragmenting a fragment that&#x27;s not the</span></span><br><span class="line"><span class="comment"> *		   last fragment then keep MF on each bit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; <span class="number">0</span> || not_last_frag)</span><br><span class="line">	iph-&gt;frag_off |= htons(IP_MF);</span><br><span class="line">ptr += len;</span><br><span class="line">offset += len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Put this fragment into the sending queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">iph-&gt;tot_len = htons(len + hlen);</span><br><span class="line"></span><br><span class="line">ip_send_check(iph);</span><br><span class="line"></span><br><span class="line">err = output(net, sk, skb2);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">IP_INC_STATS(net, IPSTATS_MIB_FRAGCREATES);</span><br></pre></td></tr></table></figure>
<p>这个就是慢速路径的分片过程，快速路径的分片过程其实更简单，因为比较麻烦的事情已经在 <code>ip_append_data</code> 里面处理过了，在我上一篇文章里面有介绍这个过程，就是在上层调用 <code>ip_append_data</code> 的时候，会在主动的进行分段式的缓存，而不使用连续空间，每个分段式的换粗也会不超过分片的大小，这样每个缓存就可以直接用来做分片了。</p>
<p>现在再回头看快速路径，快速路径主要检查有没有 <code>frag_list</code> 也就是之前分配好的 buffer 列表。获取第一个 buffer （存在 frags 里面，不是 frag_list）的长度，如果比 mtu 大，或者不是 8 的倍数，或者已经是分段了，或者是一段 shared skb_buff （因为快速路径不会拷贝内存，慢速路径会会分配新的内存，不影响之前有人引用）都不行，要进入慢速路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skb_has_frag_list(skb)) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag</span>, *<span class="title">frag2</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> first_len = skb_pagelen(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (first_len - hlen &gt; mtu ||</span><br><span class="line">	    ((first_len - hlen) &amp; <span class="number">7</span>) ||</span><br><span class="line">	    ip_is_fragment(iph) ||</span><br><span class="line">	    skb_cloned(skb))</span><br><span class="line">		<span class="keyword">goto</span> slow_path;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先保证每个 frag_list 里面 frag 不超过 mtu，然后不是最后一段需要是 8 的倍数，有足够的头部空间用来给新的 IP 分片用，然后 frag 的 buffer 也不能是 shared，最后绑定 sk 关系，减掉 skb 的 truesize。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">skb_walk_frags(skb, frag) &#123;</span><br><span class="line">	<span class="comment">/* Correct geometry. */</span></span><br><span class="line">	<span class="keyword">if</span> (frag-&gt;len &gt; mtu ||</span><br><span class="line">	    ((frag-&gt;len &amp; <span class="number">7</span>) &amp;&amp; frag-&gt;next) ||</span><br><span class="line">	    skb_headroom(frag) &lt; hlen)</span><br><span class="line">		<span class="keyword">goto</span> slow_path_clean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Partially cloned skb? */</span></span><br><span class="line">	<span class="keyword">if</span> (skb_shared(frag))</span><br><span class="line">		<span class="keyword">goto</span> slow_path_clean;</span><br><span class="line"></span><br><span class="line">	BUG_ON(frag-&gt;sk);</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;sk) &#123;</span><br><span class="line">		frag-&gt;sk = skb-&gt;sk;</span><br><span class="line">		frag-&gt;destructor = sock_wfree;</span><br><span class="line">	&#125;</span><br><span class="line">	skb-&gt;truesize -= frag-&gt;truesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就可以真的开始分片了，初始化头部信息，以及要用来分片的 frag。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">err = <span class="number">0</span>;</span><br><span class="line">offset = <span class="number">0</span>;</span><br><span class="line">frag = skb_shinfo(skb)-&gt;frag_list;</span><br><span class="line">skb_frag_list_init(skb);</span><br><span class="line">skb-&gt;data_len = first_len - skb_headlen(skb);</span><br><span class="line">skb-&gt;len = first_len;</span><br><span class="line">iph-&gt;tot_len = htons(first_len);</span><br><span class="line">iph-&gt;frag_off = htons(IP_MF);</span><br><span class="line">ip_send_check(iph);</span><br></pre></td></tr></table></figure>
<p>这个循环里面做的事情就更简单了，比起慢速路径来说，就是给每个原本没有头部的 buffer，加上头部变成真正的 fragment。保留空间，设置网络层头部，拷贝头部<code>memcpy(skb_network_header(frag), iph, hlen);</code>，拷贝原信息，如果是第一个分片更新 options，然后更新标记位，然后送到 output。直到 frag_list 被循环完，这就大功告成了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	<span class="comment">/* Prepare header of the next frame,</span></span><br><span class="line"><span class="comment">	 * before previous one went down. */</span></span><br><span class="line">	<span class="keyword">if</span> (frag) &#123;</span><br><span class="line">		frag-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">		skb_reset_transport_header(frag);</span><br><span class="line">		__skb_push(frag, hlen);</span><br><span class="line">		skb_reset_network_header(frag);</span><br><span class="line">		<span class="built_in">memcpy</span>(skb_network_header(frag), iph, hlen);</span><br><span class="line">		iph = ip_hdr(frag);</span><br><span class="line">		iph-&gt;tot_len = htons(frag-&gt;len);</span><br><span class="line">		ip_copy_metadata(frag, skb);</span><br><span class="line">		<span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">			ip_options_fragment(frag);</span><br><span class="line">		offset += skb-&gt;len - hlen;</span><br><span class="line">		iph-&gt;frag_off = htons(offset&gt;&gt;<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span> (frag-&gt;next)</span><br><span class="line">			iph-&gt;frag_off |= htons(IP_MF);</span><br><span class="line">		<span class="comment">/* Ready, complete checksum */</span></span><br><span class="line">		ip_send_check(iph);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = output(net, sk, skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!err)</span><br><span class="line">		IP_INC_STATS(net, IPSTATS_MIB_FRAGCREATES);</span><br><span class="line">	<span class="keyword">if</span> (err || !frag)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	skb = frag;</span><br><span class="line">	frag = skb-&gt;next;</span><br><span class="line">	skb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IP-重组"><a href="#IP-重组" class="headerlink" title="IP 重组"></a>IP 重组</h2><p>重组一般发生在向上层协议栈传输的时候，不过有的路由器也有可能进行重组，可能要对整个 IP packet 进行校验等，一般情况下，转发不太会对 IP 进行重组。IP 重组讲起来也有些麻烦。</p>
<p>每个正在被重组的 IP packet 都会用一个 ipq 表示，这个 ipq 使用的是 hash table (<code>inet_frags-&gt;hash</code>) 的搜索结构，没有 ipq 由 源地址，目的地址，协议和 ID 确定，所以存在重复的可能。<code>ip_defrag</code>依赖两个函数一个是<code>ip_find</code>用于寻找 <code>ipq</code> 如果没有找到的话会自动创建一个，其次是用于入队的 <code>ip_frag_queue</code> ，进行重组的工作。<code>sk_buff-&gt;cb</code> 用于保存当前的 offset。对于分片的重组也会有超时机制，防止一个 ipq 停留太长的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process an incoming IP datagram fragment. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_defrag</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sk_buff *skb, u32 user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb-&gt;dev ? : skb_dst(skb)-&gt;dev;</span><br><span class="line">	<span class="type">int</span> vif = l3mdev_master_ifindex_rcu(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">qp</span>;</span></span><br><span class="line"></span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_REASMREQDS);</span><br><span class="line">	skb_orphan(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lookup (or create) queue header */</span></span><br><span class="line">	qp = ip_find(net, ip_hdr(skb), user, vif);</span><br><span class="line">	<span class="keyword">if</span> (qp) &#123;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;qp-&gt;q.lock);</span><br><span class="line"></span><br><span class="line">		ret = ip_frag_queue(qp, skb);</span><br><span class="line"></span><br><span class="line">		spin_unlock(&amp;qp-&gt;q.lock);</span><br><span class="line">		ipq_put(qp);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ip_find</code> 主要两个功能，根据原信息计算 hash 值，从<code>net-&gt;ipv4.frags</code>  的 hash 表当中寻找到对应的 <code>ipq</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash = ipqhashfn(iph-&gt;id, iph-&gt;saddr, iph-&gt;daddr, iph-&gt;protocol);</span><br><span class="line"></span><br><span class="line">q = inet_frag_find(&amp;net-&gt;ipv4.frags, &amp;ip4_frags, &amp;arg, hash);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后进入到 <code>ip_frag_queue</code> 当中首先检查，如果出现错误，就把 ipq 标记为可以被之后的垃圾回收清扫。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (qp-&gt;q.flags &amp; INET_FRAG_COMPLETE)</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(IPCB(skb)-&gt;flags &amp; IPSKB_FRAG_COMPLETE) &amp;&amp;</span><br><span class="line">    unlikely(ip_frag_too_far(qp)) &amp;&amp;</span><br><span class="line">    unlikely(err = ip_frag_reinit(qp))) &#123;</span><br><span class="line">	ipq_kill(qp);</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取 offset，flags 和头部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ecn = ip4_frag_ecn(ip_hdr(skb)-&gt;tos);</span><br><span class="line">offset = ntohs(ip_hdr(skb)-&gt;frag_off);</span><br><span class="line">flags = offset &amp; ~IP_OFFSET;</span><br><span class="line">offset &amp;= IP_OFFSET;</span><br><span class="line">offset &lt;&lt;= <span class="number">3</span>;		<span class="comment">/* offset is in 8-byte chunks */</span></span><br><span class="line">ihl = ip_hdrlen(skb);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算这个追加的 fragment 会拷贝的位置的末尾在哪。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine the position of this fragment. */</span></span><br><span class="line">end = offset + skb-&gt;len - skb_network_offset(skb) - ihl;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是最后一个 fragment，那么不应该超过 <code>q.len</code>，或者已经有了最后一个了，但是 <code>end</code> 和 <code>q.len</code> 不一致，所以有一些 corruption。如果检查没问题，就更新<code>q.flasg</code> 标记为最后一个和把 end 赋值给<code>q.len</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Is this the final fragment? */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; IP_MF) == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* If we already have some bits beyond end</span></span><br><span class="line"><span class="comment">	 * or have different end, the segment is corrupted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (end &lt; qp-&gt;q.len ||</span><br><span class="line">	    ((qp-&gt;q.flags &amp; INET_FRAG_LAST_IN) &amp;&amp; end != qp-&gt;q.len))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	qp-&gt;q.flags |= INET_FRAG_LAST_IN;</span><br><span class="line">	qp-&gt;q.len = end;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不是最后一个，长度要与 8 对齐，然后更新 <code>q.len</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (end&amp;<span class="number">7</span>) &#123;</span><br><span class="line">		end &amp;= ~<span class="number">7</span>;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">			skb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (end &gt; qp-&gt;q.len) &#123;</span><br><span class="line">		<span class="comment">/* Some bits beyond end -&gt; corruption. */</span></span><br><span class="line">		<span class="keyword">if</span> (qp-&gt;q.flags &amp; INET_FRAG_LAST_IN)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		qp-&gt;q.len = end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>剩下的就是从链表 <code>q.fragments</code> 当中中根据<code>offset</code> 寻找到要插入的位置，会先看一下表尾，再进行遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (end == offset)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (!pskb_pull(skb, skb_network_offset(skb) + ihl))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	err = pskb_trim_rcsum(skb, end - offset);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find out which fragments are in front and at the back of us</span></span><br><span class="line"><span class="comment">	 * in the chain of fragments so far.  We must know where to put</span></span><br><span class="line"><span class="comment">	 * this fragment, right?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	prev = qp-&gt;q.fragments_tail;</span><br><span class="line">	<span class="keyword">if</span> (!prev || FRAG_CB(prev)-&gt;offset &lt; offset) &#123;</span><br><span class="line">		next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> found;</span><br><span class="line">	&#125;</span><br><span class="line">	prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (next = qp-&gt;q.fragments; next != <span class="literal">NULL</span>; next = next-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (FRAG_CB(next)-&gt;offset &gt;= offset)</span><br><span class="line">			<span class="keyword">break</span>;	<span class="comment">/* bingo! */</span></span><br><span class="line">		prev = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果和前面的分组有重叠，就把重叠的部分去掉，<code>CHECKSUM_NONE</code> 可以使当前的校验和失效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prev) &#123;</span><br><span class="line">	<span class="type">int</span> i = (FRAG_CB(prev)-&gt;offset + prev-&gt;len) - offset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		offset += i;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (end &lt;= offset)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">if</span> (!pskb_pull(skb, i))</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">			skb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后向后检查有没有重叠，并且把重叠的部分去掉，如果重叠的部分比 next 本身还要大，直接把 next 删掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (next &amp;&amp; FRAG_CB(next)-&gt;offset &lt; end) &#123;</span><br><span class="line">	<span class="type">int</span> i = end - FRAG_CB(next)-&gt;offset; <span class="comment">/* overlap is &#x27;i&#x27; bytes */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &lt; next-&gt;len) &#123;</span><br><span class="line">		<span class="comment">/* Eat head of the next overlapped fragment</span></span><br><span class="line"><span class="comment">		 * and leave the loop. The next ones cannot overlap.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!pskb_pull(next, i))</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		FRAG_CB(next)-&gt;offset += i;</span><br><span class="line">		qp-&gt;q.meat -= i;</span><br><span class="line">		<span class="keyword">if</span> (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">			next-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> sk_buff *free_it = next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Old fragment is completely overridden with</span></span><br><span class="line"><span class="comment">		 * new one drop it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		next = next-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (prev)</span><br><span class="line">			prev-&gt;next = next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			qp-&gt;q.fragments = next;</span><br><span class="line"></span><br><span class="line">		qp-&gt;q.meat -= free_it-&gt;len;</span><br><span class="line">		sub_frag_mem_limit(qp-&gt;q.net, free_it-&gt;truesize);</span><br><span class="line">		kfree_skb(free_it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>剩下的就是插入链表，并且更新 <code>ipq</code>  的信息了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">skb-&gt;next = next;</span><br><span class="line"><span class="keyword">if</span> (!next)</span><br><span class="line">	qp-&gt;q.fragments_tail = skb;</span><br><span class="line"><span class="keyword">if</span> (prev)</span><br><span class="line">	prev-&gt;next = skb;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	qp-&gt;q.fragments = skb;</span><br><span class="line"></span><br><span class="line">dev = skb-&gt;dev;</span><br><span class="line"><span class="keyword">if</span> (dev) &#123;</span><br><span class="line">	qp-&gt;iif = dev-&gt;ifindex;</span><br><span class="line">	skb-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">qp-&gt;q.stamp = skb-&gt;tstamp;</span><br><span class="line">qp-&gt;q.meat += skb-&gt;len;</span><br><span class="line">qp-&gt;ecn |= ecn;</span><br><span class="line">add_frag_mem_limit(qp-&gt;q.net, skb-&gt;truesize);</span><br><span class="line"><span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">	qp-&gt;q.flags |= INET_FRAG_FIRST_IN;</span><br><span class="line"></span><br><span class="line">fragsize = skb-&gt;len + ihl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fragsize &gt; qp-&gt;q.max_size)</span><br><span class="line">	qp-&gt;q.max_size = fragsize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip_hdr(skb)-&gt;frag_off &amp; htons(IP_DF) &amp;&amp;</span><br><span class="line">    fragsize &gt; qp-&gt;max_df_size)</span><br><span class="line">	qp-&gt;max_df_size = fragsize;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后如果，第一个包和最后一个包都收齐了的话，就尝试进行重组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (qp-&gt;q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &amp;&amp;</span><br><span class="line">    qp-&gt;q.meat == qp-&gt;q.len) &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> orefdst = skb-&gt;_skb_refdst;</span><br><span class="line"></span><br><span class="line">	skb-&gt;_skb_refdst = <span class="number">0UL</span>;</span><br><span class="line">	err = ip_frag_reasm(qp, prev, dev);</span><br><span class="line">	skb-&gt;_skb_refdst = orefdst;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外垃圾回收的过程，就是在内存超过阈值的时候，把超时的 <code>ipq</code> 从 hash 表当中剔除。内存阈值通过 <code>ip_frag_mem</code>获取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_frag_mem</span><span class="params">(<span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> sum_frag_mem_limit(&amp;net-&gt;ipv4.frags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IP 分片与重组的整体流程大致如此，IP 面临的覆盖的现象，是由于不同的 packet 但是 hash 元素一样导致的。另一方面重叠处理一个是防止出现重叠包攻击导致内存溢出。还有就是具体的校验过程会丢给上层的协议来控制。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2014 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ggaaooppeenngg</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"ggaaooppeenngg","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
