<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_85tctgPWrqH2EPVuuD5IT6KE-tW8nH0hTISJDMnShg">
  <meta name="baidu-site-verification" content="bb16c5b1fd3302c18e0015bef11eea42">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ggaaooppeenngg.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:type" content="website">
<meta property="og:title" content="ggaaooppeenngg">
<meta property="og:url" content="https://ggaaooppeenngg.github.io/page/6/index.html">
<meta property="og:site_name" content="ggaaooppeenngg">
<meta property="og:description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ggaaooppeenngg">
<meta property="article:tag" content="ggaaooppeenngg,kernel,sysml,golang,python,rust">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ggaaooppeenngg.github.io/page/6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ggaaooppeenngg</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-62096626-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-62096626-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?bb16c5b1fd3302c18e0015bef11eea42"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ggaaooppeenngg</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">为什么计算机科学是无限的但生命是有限的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">135</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">14</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">79</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ggaaooppeenngg</p>
  <div class="site-description" itemprop="description">为什么计算机科学是无限的但生命是有限的</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">135</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ggaaooppeenngg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ggaaooppeenngg" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:peng.gao.dut@gmail.com" title="E-Mail → mailto:peng.gao.dut@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/07/10/IP-%E7%9A%84%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/07/10/IP-%E7%9A%84%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84/" class="post-title-link" itemprop="url">IP 的分片与重组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-10 03:18:25" itemprop="dateCreated datePublished" datetime="2017-07-10T03:18:25+08:00">2017-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/07/10/IP-%E7%9A%84%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/07/10/IP-的分片与重组/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ip 分片的主体函数在 <code>ip_fragment</code> 当中，重组则在 <code>ip_defrag</code> 当中。第一个分片的标志 Offset 为 0，MF 为 1，之后的分片则是 Offset 非 0，MF 为 1，最后一个分片则是 Offset 非 0，但是 MF 为 0。以此来分别当前的 IP packet 是否是一个分片。从 IP 层向上层协议发送数据包的时候就会进行重组，比如在 <code>ip_local_deliver</code> 当中，调用了。说一句题外话， TCP 有 MSS ，保障 TCP message 不超过分片大小，这样是一种对底层协议有感知的行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;</span><br><span class="line">	<span class="keyword">if</span> (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h2><p><code>ip_is_fragment</code> 对应的条件就是 <code>(iph-&gt;frag_off &amp; htons(IP_MF | IP_OFFSET)) != 0;</code>。</p>
<p>在 <code>ip_fragment</code> 当中会碰到几种情况，一种是不需要分片的 IP packet，这种很好，省心，一种是需要分片的 IP packet，这种最操心，还有一种是已经按分片负载的长度分配好了 buffer 只要加个头就相当于分片完成了就也非常棒。要从头开始进行分配的情况属于慢速路径，而已经有 buffer 准好的，直接加个头就完事的属于快速路径，快速路径的内存拷贝代价更低。</p>
<p><code>ip_fragment</code> 主要检查 IP 是否允许进行分片，不然的话就返回一个 ICMP 错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> ip_hdr(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((iph-&gt;frag_off &amp; htons(IP_DF)) == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> ip_do_fragment(net, sk, skb, output);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!skb-&gt;ignore_df ||</span><br><span class="line">	     (IPCB(skb)-&gt;frag_max_size &amp;&amp;</span><br><span class="line">	      IPCB(skb)-&gt;frag_max_size &gt; mtu))) &#123;</span><br><span class="line">	IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);</span><br><span class="line">	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,</span><br><span class="line">		  htonl(mtu));</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> -EMSGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip_do_fragment(net, sk, skb, output);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后进入到 <code>ip_do_fragment</code> 当中。我们先看一下慢速路径是如何处理。</p>
<p>首先知道 IP 头部的长度，已经负载 (left)，然后当前的指针，已经链路层需要预留的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slow_path:</span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">	left = skb-&gt;len - hlen;		<span class="comment">/* Space per frame */</span></span><br><span class="line">	ptr = hlen;		<span class="comment">/* Where to start from */</span></span><br><span class="line"></span><br><span class="line">	ll_rs = LL_RESERVED_SPACE(rt-&gt;dst.dev);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IP 的 offset，以及不是最后一个分片的标志位，这里是进行分片的，不知道为什么要获取一些重组时候需要的数据，TODO。</p>
<pre><code>/*
 *    Fragment the datagram.
 */

offset = (ntohs(iph-&gt;frag_off) &amp; IP_OFFSET) &lt;&lt; 3;
not_last_frag = iph-&gt;frag_off &amp; htons(IP_MF);
</code></pre>
<p>调整要分配的 skb_buff 的长度，首先不能超过 mtu，然后最后一段要按 8 对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Keep copying data until we run out.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	len = left;</span><br><span class="line">	<span class="comment">/* IF: it doesn&#x27;t fit, use &#x27;mtu&#x27; - the data space left */</span></span><br><span class="line">	<span class="keyword">if</span> (len &gt; mtu)</span><br><span class="line">		len = mtu;</span><br><span class="line">	<span class="comment">/* IF: we are not sending up to and including the packet end</span></span><br><span class="line"><span class="comment">	   then align the next start on an eight byte boundary */</span></span><br><span class="line">	<span class="keyword">if</span> (len &lt; left)	&#123;</span><br><span class="line">		len &amp;= ~<span class="number">7</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate buffer */</span></span><br><span class="line">	skb2 = alloc_skb(len + hlen + ll_rs, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!skb2) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>设置分片的元数据，<code>ip_copy_metadata</code> 会拷贝优先级，协议类型，等辅助信息。然后保留 L2 的头部空间，接着在保留 IP 层的长度，然后设置网络头部，接着设置传输层头部的位置，就是一些初始化的动作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Set up data on packet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">ip_copy_metadata(skb2, skb);</span><br><span class="line">skb_reserve(skb2, ll_rs);</span><br><span class="line">skb_put(skb2, len + hlen);</span><br><span class="line">skb_reset_network_header(skb2);</span><br><span class="line">skb2-&gt;transport_header = skb2-&gt;network_header + hlen;</span><br></pre></td></tr></table></figure>

<p>设置对应 sk 为 <code>owner</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Charge the memory for the fragment to any owner</span></span><br><span class="line"><span class="comment"> *	it might possess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;sk)</span><br><span class="line">	skb_set_owner_w(skb2, skb-&gt;sk);</span><br></pre></td></tr></table></figure>

<p>拷贝网络层的头部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Copy the packet header into the new buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">skb_copy_from_linear_data(skb, skb_network_header(skb2), hlen);</span><br></pre></td></tr></table></figure>

<p>然后拷贝真正的负载，这里没有直接用 memcpy 的原因是，对应的空间不一定是连续的，它可能含有 frag_list，甚至是之前检查没有通过的快速路径到达了这里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Copy a block of the IP datagram.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (skb_copy_bits(skb, ptr, skb_transport_header(skb2), len))</span><br><span class="line">	BUG();</span><br><span class="line">left -= len;</span><br></pre></td></tr></table></figure>

<p>设置 IP 头的偏移和分片标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Fill in the new header fields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">iph = ip_hdr(skb2);</span><br><span class="line">iph-&gt;frag_off = htons((offset &gt;&gt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IPCB(skb)-&gt;flags &amp; IPSKB_FRAG_PMTU)</span><br><span class="line">	iph-&gt;frag_off |= htons(IP_DF);</span><br></pre></td></tr></table></figure>

<p>如果是第一个分片就尝试更新 IP options。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ANK: dirty, but effective trick. Upgrade options only if</span></span><br><span class="line"><span class="comment"> * the segment to be fragmented was THE FIRST (otherwise,</span></span><br><span class="line"><span class="comment"> * options are already fixed) and make it ONCE</span></span><br><span class="line"><span class="comment"> * on the initial skb, so that all the following fragments</span></span><br><span class="line"><span class="comment"> * will inherit fixed options.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">	ip_options_fragment(skb);</span><br></pre></td></tr></table></figure>

<p>最后修改位移，更新标记位，计算 checksum，然后送到 output。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Added AC : If we are fragmenting a fragment that&#x27;s not the</span></span><br><span class="line"><span class="comment"> *		   last fragment then keep MF on each bit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; <span class="number">0</span> || not_last_frag)</span><br><span class="line">	iph-&gt;frag_off |= htons(IP_MF);</span><br><span class="line">ptr += len;</span><br><span class="line">offset += len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Put this fragment into the sending queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">iph-&gt;tot_len = htons(len + hlen);</span><br><span class="line"></span><br><span class="line">ip_send_check(iph);</span><br><span class="line"></span><br><span class="line">err = output(net, sk, skb2);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">	<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">IP_INC_STATS(net, IPSTATS_MIB_FRAGCREATES);</span><br></pre></td></tr></table></figure>
<p>这个就是慢速路径的分片过程，快速路径的分片过程其实更简单，因为比较麻烦的事情已经在 <code>ip_append_data</code> 里面处理过了，在我上一篇文章里面有介绍这个过程，就是在上层调用 <code>ip_append_data</code> 的时候，会在主动的进行分段式的缓存，而不使用连续空间，每个分段式的换粗也会不超过分片的大小，这样每个缓存就可以直接用来做分片了。</p>
<p>现在再回头看快速路径，快速路径主要检查有没有 <code>frag_list</code> 也就是之前分配好的 buffer 列表。获取第一个 buffer （存在 frags 里面，不是 frag_list）的长度，如果比 mtu 大，或者不是 8 的倍数，或者已经是分段了，或者是一段 shared skb_buff （因为快速路径不会拷贝内存，慢速路径会会分配新的内存，不影响之前有人引用）都不行，要进入慢速路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skb_has_frag_list(skb)) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag</span>, *<span class="title">frag2</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> first_len = skb_pagelen(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (first_len - hlen &gt; mtu ||</span><br><span class="line">	    ((first_len - hlen) &amp; <span class="number">7</span>) ||</span><br><span class="line">	    ip_is_fragment(iph) ||</span><br><span class="line">	    skb_cloned(skb))</span><br><span class="line">		<span class="keyword">goto</span> slow_path;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先保证每个 frag_list 里面 frag 不超过 mtu，然后不是最后一段需要是 8 的倍数，有足够的头部空间用来给新的 IP 分片用，然后 frag 的 buffer 也不能是 shared，最后绑定 sk 关系，减掉 skb 的 truesize。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">skb_walk_frags(skb, frag) &#123;</span><br><span class="line">	<span class="comment">/* Correct geometry. */</span></span><br><span class="line">	<span class="keyword">if</span> (frag-&gt;len &gt; mtu ||</span><br><span class="line">	    ((frag-&gt;len &amp; <span class="number">7</span>) &amp;&amp; frag-&gt;next) ||</span><br><span class="line">	    skb_headroom(frag) &lt; hlen)</span><br><span class="line">		<span class="keyword">goto</span> slow_path_clean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Partially cloned skb? */</span></span><br><span class="line">	<span class="keyword">if</span> (skb_shared(frag))</span><br><span class="line">		<span class="keyword">goto</span> slow_path_clean;</span><br><span class="line"></span><br><span class="line">	BUG_ON(frag-&gt;sk);</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;sk) &#123;</span><br><span class="line">		frag-&gt;sk = skb-&gt;sk;</span><br><span class="line">		frag-&gt;destructor = sock_wfree;</span><br><span class="line">	&#125;</span><br><span class="line">	skb-&gt;truesize -= frag-&gt;truesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就可以真的开始分片了，初始化头部信息，以及要用来分片的 frag。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">err = <span class="number">0</span>;</span><br><span class="line">offset = <span class="number">0</span>;</span><br><span class="line">frag = skb_shinfo(skb)-&gt;frag_list;</span><br><span class="line">skb_frag_list_init(skb);</span><br><span class="line">skb-&gt;data_len = first_len - skb_headlen(skb);</span><br><span class="line">skb-&gt;len = first_len;</span><br><span class="line">iph-&gt;tot_len = htons(first_len);</span><br><span class="line">iph-&gt;frag_off = htons(IP_MF);</span><br><span class="line">ip_send_check(iph);</span><br></pre></td></tr></table></figure>
<p>这个循环里面做的事情就更简单了，比起慢速路径来说，就是给每个原本没有头部的 buffer，加上头部变成真正的 fragment。保留空间，设置网络层头部，拷贝头部<code>memcpy(skb_network_header(frag), iph, hlen);</code>，拷贝原信息，如果是第一个分片更新 options，然后更新标记位，然后送到 output。直到 frag_list 被循环完，这就大功告成了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	<span class="comment">/* Prepare header of the next frame,</span></span><br><span class="line"><span class="comment">	 * before previous one went down. */</span></span><br><span class="line">	<span class="keyword">if</span> (frag) &#123;</span><br><span class="line">		frag-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">		skb_reset_transport_header(frag);</span><br><span class="line">		__skb_push(frag, hlen);</span><br><span class="line">		skb_reset_network_header(frag);</span><br><span class="line">		<span class="built_in">memcpy</span>(skb_network_header(frag), iph, hlen);</span><br><span class="line">		iph = ip_hdr(frag);</span><br><span class="line">		iph-&gt;tot_len = htons(frag-&gt;len);</span><br><span class="line">		ip_copy_metadata(frag, skb);</span><br><span class="line">		<span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">			ip_options_fragment(frag);</span><br><span class="line">		offset += skb-&gt;len - hlen;</span><br><span class="line">		iph-&gt;frag_off = htons(offset&gt;&gt;<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span> (frag-&gt;next)</span><br><span class="line">			iph-&gt;frag_off |= htons(IP_MF);</span><br><span class="line">		<span class="comment">/* Ready, complete checksum */</span></span><br><span class="line">		ip_send_check(iph);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = output(net, sk, skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!err)</span><br><span class="line">		IP_INC_STATS(net, IPSTATS_MIB_FRAGCREATES);</span><br><span class="line">	<span class="keyword">if</span> (err || !frag)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	skb = frag;</span><br><span class="line">	frag = skb-&gt;next;</span><br><span class="line">	skb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IP-重组"><a href="#IP-重组" class="headerlink" title="IP 重组"></a>IP 重组</h2><p>重组一般发生在向上层协议栈传输的时候，不过有的路由器也有可能进行重组，可能要对整个 IP packet 进行校验等，一般情况下，转发不太会对 IP 进行重组。IP 重组讲起来也有些麻烦。</p>
<p>每个正在被重组的 IP packet 都会用一个 ipq 表示，这个 ipq 使用的是 hash table (<code>inet_frags-&gt;hash</code>) 的搜索结构，没有 ipq 由 源地址，目的地址，协议和 ID 确定，所以存在重复的可能。<code>ip_defrag</code>依赖两个函数一个是<code>ip_find</code>用于寻找 <code>ipq</code> 如果没有找到的话会自动创建一个，其次是用于入队的 <code>ip_frag_queue</code> ，进行重组的工作。<code>sk_buff-&gt;cb</code> 用于保存当前的 offset。对于分片的重组也会有超时机制，防止一个 ipq 停留太长的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process an incoming IP datagram fragment. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_defrag</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sk_buff *skb, u32 user)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb-&gt;dev ? : skb_dst(skb)-&gt;dev;</span><br><span class="line">	<span class="type">int</span> vif = l3mdev_master_ifindex_rcu(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">qp</span>;</span></span><br><span class="line"></span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_REASMREQDS);</span><br><span class="line">	skb_orphan(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lookup (or create) queue header */</span></span><br><span class="line">	qp = ip_find(net, ip_hdr(skb), user, vif);</span><br><span class="line">	<span class="keyword">if</span> (qp) &#123;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;qp-&gt;q.lock);</span><br><span class="line"></span><br><span class="line">		ret = ip_frag_queue(qp, skb);</span><br><span class="line"></span><br><span class="line">		spin_unlock(&amp;qp-&gt;q.lock);</span><br><span class="line">		ipq_put(qp);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ip_find</code> 主要两个功能，根据原信息计算 hash 值，从<code>net-&gt;ipv4.frags</code>  的 hash 表当中寻找到对应的 <code>ipq</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash = ipqhashfn(iph-&gt;id, iph-&gt;saddr, iph-&gt;daddr, iph-&gt;protocol);</span><br><span class="line"></span><br><span class="line">q = inet_frag_find(&amp;net-&gt;ipv4.frags, &amp;ip4_frags, &amp;arg, hash);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后进入到 <code>ip_frag_queue</code> 当中首先检查，如果出现错误，就把 ipq 标记为可以被之后的垃圾回收清扫。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (qp-&gt;q.flags &amp; INET_FRAG_COMPLETE)</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(IPCB(skb)-&gt;flags &amp; IPSKB_FRAG_COMPLETE) &amp;&amp;</span><br><span class="line">    unlikely(ip_frag_too_far(qp)) &amp;&amp;</span><br><span class="line">    unlikely(err = ip_frag_reinit(qp))) &#123;</span><br><span class="line">	ipq_kill(qp);</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取 offset，flags 和头部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ecn = ip4_frag_ecn(ip_hdr(skb)-&gt;tos);</span><br><span class="line">offset = ntohs(ip_hdr(skb)-&gt;frag_off);</span><br><span class="line">flags = offset &amp; ~IP_OFFSET;</span><br><span class="line">offset &amp;= IP_OFFSET;</span><br><span class="line">offset &lt;&lt;= <span class="number">3</span>;		<span class="comment">/* offset is in 8-byte chunks */</span></span><br><span class="line">ihl = ip_hdrlen(skb);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算这个追加的 fragment 会拷贝的位置的末尾在哪。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine the position of this fragment. */</span></span><br><span class="line">end = offset + skb-&gt;len - skb_network_offset(skb) - ihl;</span><br><span class="line">err = -EINVAL;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是最后一个 fragment，那么不应该超过 <code>q.len</code>，或者已经有了最后一个了，但是 <code>end</code> 和 <code>q.len</code> 不一致，所以有一些 corruption。如果检查没问题，就更新<code>q.flasg</code> 标记为最后一个和把 end 赋值给<code>q.len</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Is this the final fragment? */</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; IP_MF) == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* If we already have some bits beyond end</span></span><br><span class="line"><span class="comment">	 * or have different end, the segment is corrupted.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (end &lt; qp-&gt;q.len ||</span><br><span class="line">	    ((qp-&gt;q.flags &amp; INET_FRAG_LAST_IN) &amp;&amp; end != qp-&gt;q.len))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	qp-&gt;q.flags |= INET_FRAG_LAST_IN;</span><br><span class="line">	qp-&gt;q.len = end;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不是最后一个，长度要与 8 对齐，然后更新 <code>q.len</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (end&amp;<span class="number">7</span>) &#123;</span><br><span class="line">		end &amp;= ~<span class="number">7</span>;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">			skb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (end &gt; qp-&gt;q.len) &#123;</span><br><span class="line">		<span class="comment">/* Some bits beyond end -&gt; corruption. */</span></span><br><span class="line">		<span class="keyword">if</span> (qp-&gt;q.flags &amp; INET_FRAG_LAST_IN)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		qp-&gt;q.len = end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>剩下的就是从链表 <code>q.fragments</code> 当中中根据<code>offset</code> 寻找到要插入的位置，会先看一下表尾，再进行遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (end == offset)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (!pskb_pull(skb, skb_network_offset(skb) + ihl))</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	err = pskb_trim_rcsum(skb, end - offset);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find out which fragments are in front and at the back of us</span></span><br><span class="line"><span class="comment">	 * in the chain of fragments so far.  We must know where to put</span></span><br><span class="line"><span class="comment">	 * this fragment, right?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	prev = qp-&gt;q.fragments_tail;</span><br><span class="line">	<span class="keyword">if</span> (!prev || FRAG_CB(prev)-&gt;offset &lt; offset) &#123;</span><br><span class="line">		next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> found;</span><br><span class="line">	&#125;</span><br><span class="line">	prev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (next = qp-&gt;q.fragments; next != <span class="literal">NULL</span>; next = next-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (FRAG_CB(next)-&gt;offset &gt;= offset)</span><br><span class="line">			<span class="keyword">break</span>;	<span class="comment">/* bingo! */</span></span><br><span class="line">		prev = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果和前面的分组有重叠，就把重叠的部分去掉，<code>CHECKSUM_NONE</code> 可以使当前的校验和失效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (prev) &#123;</span><br><span class="line">	<span class="type">int</span> i = (FRAG_CB(prev)-&gt;offset + prev-&gt;len) - offset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		offset += i;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (end &lt;= offset)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">if</span> (!pskb_pull(skb, i))</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">			skb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后向后检查有没有重叠，并且把重叠的部分去掉，如果重叠的部分比 next 本身还要大，直接把 next 删掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (next &amp;&amp; FRAG_CB(next)-&gt;offset &lt; end) &#123;</span><br><span class="line">	<span class="type">int</span> i = end - FRAG_CB(next)-&gt;offset; <span class="comment">/* overlap is &#x27;i&#x27; bytes */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &lt; next-&gt;len) &#123;</span><br><span class="line">		<span class="comment">/* Eat head of the next overlapped fragment</span></span><br><span class="line"><span class="comment">		 * and leave the loop. The next ones cannot overlap.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!pskb_pull(next, i))</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		FRAG_CB(next)-&gt;offset += i;</span><br><span class="line">		qp-&gt;q.meat -= i;</span><br><span class="line">		<span class="keyword">if</span> (next-&gt;ip_summed != CHECKSUM_UNNECESSARY)</span><br><span class="line">			next-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> sk_buff *free_it = next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Old fragment is completely overridden with</span></span><br><span class="line"><span class="comment">		 * new one drop it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		next = next-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (prev)</span><br><span class="line">			prev-&gt;next = next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			qp-&gt;q.fragments = next;</span><br><span class="line"></span><br><span class="line">		qp-&gt;q.meat -= free_it-&gt;len;</span><br><span class="line">		sub_frag_mem_limit(qp-&gt;q.net, free_it-&gt;truesize);</span><br><span class="line">		kfree_skb(free_it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>剩下的就是插入链表，并且更新 <code>ipq</code>  的信息了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">skb-&gt;next = next;</span><br><span class="line"><span class="keyword">if</span> (!next)</span><br><span class="line">	qp-&gt;q.fragments_tail = skb;</span><br><span class="line"><span class="keyword">if</span> (prev)</span><br><span class="line">	prev-&gt;next = skb;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	qp-&gt;q.fragments = skb;</span><br><span class="line"></span><br><span class="line">dev = skb-&gt;dev;</span><br><span class="line"><span class="keyword">if</span> (dev) &#123;</span><br><span class="line">	qp-&gt;iif = dev-&gt;ifindex;</span><br><span class="line">	skb-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">qp-&gt;q.stamp = skb-&gt;tstamp;</span><br><span class="line">qp-&gt;q.meat += skb-&gt;len;</span><br><span class="line">qp-&gt;ecn |= ecn;</span><br><span class="line">add_frag_mem_limit(qp-&gt;q.net, skb-&gt;truesize);</span><br><span class="line"><span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">	qp-&gt;q.flags |= INET_FRAG_FIRST_IN;</span><br><span class="line"></span><br><span class="line">fragsize = skb-&gt;len + ihl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fragsize &gt; qp-&gt;q.max_size)</span><br><span class="line">	qp-&gt;q.max_size = fragsize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip_hdr(skb)-&gt;frag_off &amp; htons(IP_DF) &amp;&amp;</span><br><span class="line">    fragsize &gt; qp-&gt;max_df_size)</span><br><span class="line">	qp-&gt;max_df_size = fragsize;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后如果，第一个包和最后一个包都收齐了的话，就尝试进行重组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (qp-&gt;q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &amp;&amp;</span><br><span class="line">    qp-&gt;q.meat == qp-&gt;q.len) &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> orefdst = skb-&gt;_skb_refdst;</span><br><span class="line"></span><br><span class="line">	skb-&gt;_skb_refdst = <span class="number">0UL</span>;</span><br><span class="line">	err = ip_frag_reasm(qp, prev, dev);</span><br><span class="line">	skb-&gt;_skb_refdst = orefdst;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外垃圾回收的过程，就是在内存超过阈值的时候，把超时的 <code>ipq</code> 从 hash 表当中剔除。内存阈值通过 <code>ip_frag_mem</code>获取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_frag_mem</span><span class="params">(<span class="keyword">struct</span> net *net)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> sum_frag_mem_limit(&amp;net-&gt;ipv4.frags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IP 分片与重组的整体流程大致如此，IP 面临的覆盖的现象，是由于不同的 packet 但是 hash 元素一样导致的。另一方面重叠处理一个是防止出现重叠包攻击导致内存溢出。还有就是具体的校验过程会丢给上层的协议来控制。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/07/01/%E5%8D%8F%E8%AE%AE%E6%A0%88-IP-%E5%B1%82%E4%B8%BB%E4%BD%93%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/07/01/%E5%8D%8F%E8%AE%AE%E6%A0%88-IP-%E5%B1%82%E4%B8%BB%E4%BD%93%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">协议栈 IP 层主体流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-01 23:03:57" itemprop="dateCreated datePublished" datetime="2017-07-01T23:03:57+08:00">2017-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/07/01/%E5%8D%8F%E8%AE%AE%E6%A0%88-IP-%E5%B1%82%E4%B8%BB%E4%BD%93%E6%B5%81%E7%A8%8B/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/07/01/协议栈-IP-层主体流程/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>IP 层主要的工作是头部验证，头部选项的处理，分片和重组，以及路由，本篇文章主要分析 IP 层的主体流程，路由和分片的具体细节暂时略解。</p>
<p>在 <code>ip_init</code> 注册 <code>ip_rcv</code> 处理函数，然后初始化路由子系统，和对端管理器。两个结构 <code>ip_tstamps</code> 和 <code>ip_idents</code>。<code>ip_rcv</code> 是 IP 的入口，主要是一些参数检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	Main IP Receive routine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt, <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">	u32 len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* When the interface is in promisc. mode, drop all the crap</span></span><br><span class="line"><span class="comment">	 * that it receives, do not try to analyse it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="comment">// 如果 L2 地址不是本机地址 pkt_type 就会被设置成 PACKET_OHTERHOST</span></span><br><span class="line">	 <span class="comment">// 然后进行丢包</span></span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;pkt_type == PACKET_OTHERHOST)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	net = dev_net(dev);</span><br><span class="line">	__IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb-&gt;len);</span><br><span class="line">	<span class="comment">// 检查引用计数，如果有人引用就复制一份自己的 skb。</span></span><br><span class="line">	skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!skb) &#123;</span><br><span class="line">		__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 保证有 iphdr 大小，如果没有，则可能尝试从 skb_shinfo(skb)-&gt;frags[] 中获取</span></span><br><span class="line">	<span class="keyword">if</span> (!pskb_may_pull(skb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr)))</span><br><span class="line">		<span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	RFC1122: 3.2.1.2 MUST silently discard any IP frame that fails the checksum.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	Is the datagram acceptable?</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *	1.	Length at least the size of an ip header</span></span><br><span class="line"><span class="comment">	 *	2.	Version of 4</span></span><br><span class="line"><span class="comment">	 *	3.	Checksums correctly. [Speed optimisation for later, skip loopback checksums]</span></span><br><span class="line"><span class="comment">	 *	4.	Doesn&#x27;t have a bogus length</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">// ip 头部长度至少 20 个字节</span></span><br><span class="line">	<span class="keyword">if</span> (iph-&gt;ihl &lt; <span class="number">5</span> || iph-&gt;version != <span class="number">4</span>)</span><br><span class="line">		<span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">	BUILD_BUG_ON(IPSTATS_MIB_ECT1PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_1);</span><br><span class="line">	BUILD_BUG_ON(IPSTATS_MIB_ECT0PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_0);</span><br><span class="line">	BUILD_BUG_ON(IPSTATS_MIB_CEPKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_CE);</span><br><span class="line">	__IP_ADD_STATS(net,</span><br><span class="line">		       IPSTATS_MIB_NOECTPKTS + (iph-&gt;tos &amp; INET_ECN_MASK),</span><br><span class="line">		       <span class="type">max_t</span>(<span class="type">unsigned</span> <span class="type">short</span>, <span class="number">1</span>, skb_shinfo(skb)-&gt;gso_segs));</span><br><span class="line">	<span class="comment">// 保证完整的头部大小</span></span><br><span class="line">	<span class="keyword">if</span> (!pskb_may_pull(skb, iph-&gt;ihl*<span class="number">4</span>))</span><br><span class="line">		<span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">	iph = ip_hdr(skb);</span><br><span class="line">	<span class="comment">// 做校验和</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ip_fast_csum((u8 *)iph, iph-&gt;ihl)))</span><br><span class="line">		<span class="keyword">goto</span> csum_error;</span><br><span class="line">	<span class="comment">// 保证 skb buffer 的大小比 packet 长度大，不然就丢包</span></span><br><span class="line">    <span class="comment">// 这个原因是 L2 有 padding? (TODO)</span></span><br><span class="line">    <span class="comment">// 并且 packet 长度至少有头部那么大</span></span><br><span class="line">	len = ntohs(iph-&gt;tot_len);</span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;len &lt; len) &#123;</span><br><span class="line">		__IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS);</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt; (iph-&gt;ihl*<span class="number">4</span>))</span><br><span class="line">		<span class="keyword">goto</span> inhdr_error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Our transport medium may have padded the buffer out. Now we know it</span></span><br><span class="line"><span class="comment">	 * is IP we can trim to the true length of the frame.</span></span><br><span class="line"><span class="comment">	 * Note this now means skb-&gt;len holds ntohs(iph-&gt;tot_len).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pskb_trim_rcsum(skb, len)) &#123;</span><br><span class="line">		__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	skb-&gt;transport_header = skb-&gt;network_header + iph-&gt;ihl*<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remove any debris in the socket control block */</span></span><br><span class="line">	<span class="built_in">memset</span>(IPCB(skb), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_skb_parm));</span><br><span class="line">	IPCB(skb)-&gt;iif = skb-&gt;skb_iif;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Must drop socket now because of tproxy. */</span></span><br><span class="line">	skb_orphan(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,</span><br><span class="line">		       net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">		       ip_rcv_finish);</span><br><span class="line"></span><br><span class="line">csum_error:</span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS);</span><br><span class="line">inhdr_error:</span><br><span class="line">	__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);</span><br><span class="line">drop:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但实际上，大部分的函数是分成两部分的，真正的行为都在 <code>_finish</code> 后缀当中，前期都是检查。在 netfilter 里面 <code>NF_HOOK</code> 这个宏是有个 <code>okfn</code> 如果通过了 netfilter 的检查就会调用这个函数。对应的就是  <code>ip_rcv_finish</code> 当中，要决定是否继续向上层传递还是要进行找到出口设备确定下一跳，进行转发。如果是从设备就交给主设备的 handler 处理（这个和 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/vrf.txt">VRF</a> 有关，主设备代表这些从设备表示的一个域，用于分配一个专有的 FIB 表等等，类似某种程度的隔离）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if ingress device is enslaved to an L3 master device pass the</span></span><br><span class="line"><span class="comment"> * skb to its handler for processing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">skb = l3mdev_ip_rcv(skb);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line">	<span class="keyword">return</span> NET_RX_SUCCESS;</span><br></pre></td></tr></table></figure>

<p>如果设置了 <code>ip_early_demux</code> 并且不是分片的 IP 包，就会提前调用 TCP 的 <code>early_demux</code> 提前解复用这个包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (net-&gt;ipv4.sysctl_ip_early_demux &amp;&amp;</span><br><span class="line">    !skb_dst(skb) &amp;&amp;</span><br><span class="line">    !skb-&gt;sk &amp;&amp;</span><br><span class="line">    !ip_is_fragment(iph)) &#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> *<span class="title">ipprot</span>;</span></span><br><span class="line">	<span class="type">int</span> protocol = iph-&gt;protocol;</span><br><span class="line"></span><br><span class="line">	ipprot = rcu_dereference(inet_protos[protocol]);</span><br><span class="line">	<span class="keyword">if</span> (ipprot &amp;&amp; (edemux = READ_ONCE(ipprot-&gt;early_demux))) &#123;</span><br><span class="line">		edemux(skb);</span><br><span class="line">		<span class="comment">/* must reload iph, skb-&gt;head might have changed */</span></span><br><span class="line">		iph = ip_hdr(skb);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在路由系统中找到 <code>dst</code> 指向的 <code>dst_entry</code>，接下来的处理函数也会存在 <code>dst</code> 当中，为一下三种。</p>
<ul>
<li> ip_forward() 转发到其他主机</li>
<li> ip_local_deliver() 传入传输层</li>
<li> ip_error() 出现了错误，可能会发送一个 ICMP</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Initialise the virtual path cache for the packet. It describes</span></span><br><span class="line"><span class="comment"> *	how the packet travels inside Linux networking.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!skb_valid_dst(skb)) &#123;</span><br><span class="line">	<span class="type">int</span> err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">				       iph-&gt;tos, dev);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(err)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (err == -EXDEV)</span><br><span class="line">			__NET_INC_STATS(net, LINUX_MIB_IPRPFILTER);</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编译选项带了 <code>CONFIG_IP_ROUTE_CLASSID</code> 那么有流量控制的 <code>classid</code> 的就会进行一些统计。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IP_ROUTE_CLASSID</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb_dst(skb)-&gt;tclassid)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ip_rt_acct</span> *<span class="title">st</span> =</span> this_cpu_ptr(ip_rt_acct);</span><br><span class="line">		u32 idx = skb_dst(skb)-&gt;tclassid;</span><br><span class="line">		st[idx&amp;<span class="number">0xFF</span>].o_packets++;</span><br><span class="line">		st[idx&amp;<span class="number">0xFF</span>].o_bytes += skb-&gt;len;</span><br><span class="line">		st[(idx&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xFF</span>].i_packets++;</span><br><span class="line">		st[(idx&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xFF</span>].i_bytes += skb-&gt;len;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先如果 IP 头部长度大于 5 说明有 options，调用 <code>ip_rcv_options</code> 进行处理，如果失败了就进行丢包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (iph-&gt;ihl &gt; <span class="number">5</span> &amp;&amp; ip_rcv_options(skb))</span><br><span class="line">	<span class="keyword">goto</span> drop;</span><br></pre></td></tr></table></figure>

<p>具体过程在 <code>ip_rcv_options</code> 当中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skb_cow(skb, skb_headroom(skb))) &#123;</span><br><span class="line">	__IP_INC_STATS(dev_net(dev), IPSTATS_MIB_INDISCARDS);</span><br><span class="line">	<span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先把 <code>skb_headroom</code> 等于 <code>skb-&gt;data - skb-&gt;head</code>，计算了头部的长度，如果这个头部有 <code>clone</code> 就会被复制一份来 <code>declone</code>。</p>
<p>然后根据把 IP option 存进结构化的 <code>inet_skb_parm</code> 当中，其中有个成员是 <code>struct ip_options</code> 。<code>IPCB</code></p>
<p>代表的是 <code>#define IPCB(skb) ((struct inet_skb_parm*)((skb)-&gt;cb))</code>，<code>skb-&gt;cb</code> 是一个缓冲区用于协议栈每层的处理函数存放一些临时的私有变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iph = ip_hdr(skb);</span><br><span class="line">opt = &amp;(IPCB(skb)-&gt;opt);</span><br><span class="line">opt-&gt;optlen = iph-&gt;ihl*<span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip_options_compile(dev_net(dev), opt, skb)) &#123;</span><br><span class="line">	__IP_INC_STATS(dev_net(dev), IPSTATS_MIB_INHDRERRORS);</span><br><span class="line">	<span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>in_device</code> 是和 IP 有关的设备信息，如果没有 source route 选项就直接跳过，不然处理 source route 选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(opt-&gt;srr)) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_device</span> *<span class="title">in_dev</span> =</span> __in_dev_get_rcu(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (in_dev) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!IN_DEV_SOURCE_ROUTE(in_dev)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (IN_DEV_LOG_MARTIANS(in_dev))</span><br><span class="line">				net_info_ratelimited(<span class="string">&quot;source route option %pI4 -&gt; %pI4\n&quot;</span>,</span><br><span class="line">						     &amp;iph-&gt;saddr,</span><br><span class="line">						     &amp;iph-&gt;daddr);</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ip_options_rcv_srr(skb))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>source route 是一个多字节选项。此选项中，发送节点会列出后续几跳的 IP 地址（不能超过 IP 报头的最大长度）。如果列表中有某台主机宕机了，则必须重新计算来源地路由，重新发送，而不是使用动态路由。<code>ip_options_rcv_srr</code> 的具体工作就是根据提取出的目的地在本地计算目的地是否可达，如果成功就反回 0， 不然就丢弃。</p>
<p>从<code>ip_rcv_options</code> 出来以后根据组播广播进行数据统计。下面的 <code>IN_DEV_ORCONF</code> 不太确定是啥 (TODO)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">rt = skb_rtable(skb);</span><br><span class="line"><span class="keyword">if</span> (rt-&gt;rt_type == RTN_MULTICAST) &#123;</span><br><span class="line">	__IP_UPD_PO_STATS(net, IPSTATS_MIB_INMCAST, skb-&gt;len);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rt-&gt;rt_type == RTN_BROADCAST) &#123;</span><br><span class="line">	__IP_UPD_PO_STATS(net, IPSTATS_MIB_INBCAST, skb-&gt;len);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (skb-&gt;pkt_type == PACKET_BROADCAST ||</span><br><span class="line">	   skb-&gt;pkt_type == PACKET_MULTICAST) &#123;</span><br><span class="line">	<span class="keyword">struct</span> in_device *in_dev = __in_dev_get_rcu(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* RFC 1122 3.3.6:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   When a host sends a datagram to a link-layer broadcast</span></span><br><span class="line"><span class="comment">	 *   address, the IP destination address MUST be a legal IP</span></span><br><span class="line"><span class="comment">	 *   broadcast or IP multicast address.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *   A host SHOULD silently discard a datagram that is received</span></span><br><span class="line"><span class="comment">	 *   via a link-layer broadcast (see Section 2.4) but does not</span></span><br><span class="line"><span class="comment">	 *   specify an IP multicast or broadcast destination address.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * This doesn&#x27;t explicitly say L2 *broadcast*, but broadcast is</span></span><br><span class="line"><span class="comment">	 * in a way a form of multicast and the most common use case for</span></span><br><span class="line"><span class="comment">	 * this is 802.11 protecting against cross-station spoofing (the</span></span><br><span class="line"><span class="comment">	 * so-called &quot;hole-196&quot; attack) so do it for both.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (in_dev &amp;&amp;</span><br><span class="line">	    IN_DEV_ORCONF(in_dev, DROP_UNICAST_IN_L2_MULTICAST))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst_input(skb);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进入 <code>dst_input</code>  就会交给 <code>skb­&gt;dst ­&gt;input</code> 来处理。</p>
<p>转发会分成两部分处理 <code>ip_forward</code> 和 <code>ip_forward_finish</code> IP 转发分成几个步骤</p>
<ol>
<li> 处理 IP options，可能会要求记录本地 IP 地址和时间戳</li>
<li> 基于 IP 头，确保这个 pakcet 可以发出去</li>
<li> 减 1 TTL，到达 0 就丢弃</li>
<li> 根据 MTU 进行分组</li>
<li> 发送至出口设备</li>
</ol>
<p>期间如果出错了，会通过 ICMP 告知。<code>xfrm4_xxx</code> 是 IPsec 相关的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IPCB(skb)-&gt;opt.router_alert &amp;&amp; ip_call_ra_chain(skb))</span><br><span class="line">	<span class="keyword">return</span> NET_RX_SUCCESS;</span><br></pre></td></tr></table></figure>

<p>首先是检查 IP 选项当中有没有 Router Alert，如果有的话就交给  <code>ip_ra_chain</code> 中对此感兴趣的 <code>raw socket</code> 来处理，并且就次结束。</p>
<p>在这里检查 TTL 是否耗尽</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip_hdr(skb)-&gt;ttl &lt;= <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">goto</span> too_many_hops;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是严格的源路由，下一条是网关而不是直接连接的路由就丢包。</p>
<p><code>rt_uses_gateway</code> 代表两种意思</p>
<ul>
<li>   1 的时候表示网关</li>
<li>   0 的时候表示直接路由</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_uses_gateway)</span><br><span class="line">	<span class="keyword">goto</span> sr_failed;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果超出 MTU 进行丢包</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IPCB(skb)-&gt;flags |= IPSKB_FORWARDED;</span><br><span class="line">mtu = ip_dst_mtu_maybe_forward(&amp;rt-&gt;dst, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_exceeds_mtu(skb, mtu)) &#123;</span><br><span class="line">	IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);</span><br><span class="line">	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,</span><br><span class="line">		  htonl(mtu));</span><br><span class="line">	<span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>declone 这个 skb 并且确保预留 L2 的空间，然后减少 TTL。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* We are about to mangle packet. Copy it! */</span><br><span class="line">if (skb_cow(skb, LL_RESERVED_SPACE(rt-&gt;dst.dev)+rt-&gt;dst.header_len))</span><br><span class="line">	goto drop;</span><br><span class="line">iph = ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">/* Decrease ttl after skb cow done */</span><br><span class="line">ip_decrease_ttl(iph);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果被标记为 <code>IPSKB_DOREDIRECT</code> 发送 redirect ICMP，接着设置优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	We now generate an ICMP HOST REDIRECT giving the route</span></span><br><span class="line"><span class="comment"> *	we calculated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (IPCB(skb)-&gt;flags &amp; IPSKB_DOREDIRECT &amp;&amp; !opt-&gt;srr &amp;&amp;</span><br><span class="line">    !skb_sec_path(skb))</span><br><span class="line">	ip_rt_send_redirect(skb);</span><br><span class="line"></span><br><span class="line">skb-&gt;priority = rt_tos2priority(iph-&gt;tos);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后进入 <code>ip_forward_finish</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,</span><br><span class="line">	       net, <span class="literal">NULL</span>, skb, skb-&gt;dev, rt-&gt;dst.dev,</span><br><span class="line">	       ip_forward_finish);</span><br></pre></td></tr></table></figure>

<p>在 <code>ip_forward_finish</code> 当中会进入 <code>dst_output</code>，<code>ip_forward_options</code> 会处理一些 IP 选项并且重新计算 IP 头的校验和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(opt-&gt;optlen))</span><br><span class="line">	ip_forward_options(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst_output(net, sk, skb);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在内部有两种情况，一种是单播，一种是广播，对应的处理函数分别是 <code>ip_output</code> 喝 <code>ip_mc_output</code> 两种处理函数，会进行分组操作，然后在 <code>ip_finish_output</code> 当中进入邻居系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skb_dst(skb)-&gt;output(net, sk, skb);</span><br></pre></td></tr></table></figure>

<p><code>ip_local_deliver</code> 主要的工作是对分片进行重组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_local_deliver</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Reassemble IP fragments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(skb-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,</span><br><span class="line">		       net, <span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">		       ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是 3 层接收端的一个大体结构，下面看一下 3 层发送端的一些内容。发送的入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_queue_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> ipfragok)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先会检查是否已经有了路由信息，这个在 SCTP 的情况下会发生。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rt = skb_rtable(skb);</span><br><span class="line"><span class="keyword">if</span> (rt)</span><br><span class="line">	<span class="keyword">goto</span> packet_routed;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>检查是否缓存了 route 如果有的话却是路由信息的有效性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make sure we can route this packet. */</span></span><br><span class="line">rt = (<span class="keyword">struct</span> rtable *)__sk_dst_check(sk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><code>ip_route_output_ports</code> 确保 <code>source route list</code> 的 下一跳和 <code>daddr</code> 一致，并且将路由设置在 skb 里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!rt) &#123;</span><br><span class="line">	__be32 daddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use correct destination address if we have options. */</span></span><br><span class="line">	daddr = inet-&gt;inet_daddr;</span><br><span class="line">	<span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.srr)</span><br><span class="line">		daddr = inet_opt-&gt;opt.faddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If this fails, retransmit mechanism of transport layer will</span></span><br><span class="line"><span class="comment">	 * keep trying until route appears or the connection times</span></span><br><span class="line"><span class="comment">	 * itself out.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	rt = ip_route_output_ports(net, fl4, sk,</span><br><span class="line">				   daddr, inet-&gt;inet_saddr,</span><br><span class="line">				   inet-&gt;inet_dport,</span><br><span class="line">				   inet-&gt;inet_sport,</span><br><span class="line">				   sk-&gt;sk_protocol,</span><br><span class="line">				   RT_CONN_FLAGS(sk),</span><br><span class="line">				   sk-&gt;sk_bound_dev_if);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(rt))</span><br><span class="line">		<span class="keyword">goto</span> no_route;</span><br><span class="line">	sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line">&#125;</span><br><span class="line">skb_dst_set_noref(skb, &amp;rt-&gt;dst);</span><br></pre></td></tr></table></figure>

<p>接下来就需要构建 IP 头了，先调用空出需要的 IP 头部空间，并且重置我的大脑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* OK, we know where to send it, allocate and build IP header. */</span></span><br><span class="line">skb_push(skb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr) + (inet_opt ? inet_opt-&gt;opt.optlen : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>重置 IP 头长度其实就是设置了 <code>network_header</code> 等于  <code>data - head</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skb_reset_network_header(skb);</span><br></pre></td></tr></table></figure>
<p>转换成 16 位的指针并且把 IP 协议号，IP 头长度，<code>inet-&gt;tos</code> TOS 写入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iph = ip_hdr(skb);</span><br><span class="line">*((__be16 *)iph) = htons((<span class="number">4</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">5</span> &lt;&lt; <span class="number">8</span>) | (inet-&gt;tos &amp; <span class="number">0xff</span>));</span><br></pre></td></tr></table></figure>

<p>初始化 <code>iph</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;dst) &amp;&amp; !skb-&gt;ignore_df)</span><br><span class="line">	iph-&gt;frag_off = htons(IP_DF);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	iph-&gt;frag_off = <span class="number">0</span>;</span><br><span class="line">iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;dst);</span><br><span class="line">iph-&gt;protocol = sk-&gt;sk_protocol;</span><br><span class="line">ip_copy_addrs(iph, fl4);</span><br></pre></td></tr></table></figure>

<p>如果有选项长度更新选项长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Transport layer set skb-&gt;h.foo itself. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.optlen) &#123;</span><br><span class="line">	iph-&gt;ihl += inet_opt-&gt;opt.optlen &gt;&gt; <span class="number">2</span>;</span><br><span class="line">	ip_options_build(skb, &amp;inet_opt-&gt;opt, inet-&gt;inet_daddr, rt, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于是否分片给 packet 分配 ID，然后进入 <code>ip_local_out</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ip_select_ident_segs(net, skb, sk,</span><br><span class="line">		     skb_shinfo(skb)-&gt;gso_segs ?: <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO : should we use skb-&gt;sk here instead of sk ? */</span></span><br><span class="line">skb-&gt;priority = sk-&gt;sk_priority;</span><br><span class="line">skb-&gt;mark = sk-&gt;sk_mark;</span><br><span class="line"></span><br><span class="line">res = ip_local_out(net, sk, skb);</span><br></pre></td></tr></table></figure>

<p>当这里先告一段落，再来看一下 <code>ip_append_data</code> 这个函数的作用是缓存进合理的结构以便之后进行分片然后发送。<code>ip_push_pending_frames</code>  就可以触发这个动作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_append_data</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> flowi4 *fl4,</span></span><br><span class="line"><span class="params">		   <span class="type">int</span> getfrag(<span class="type">void</span> *from, <span class="type">char</span> *to, <span class="type">int</span> offset, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">			       <span class="type">int</span> odd, <span class="keyword">struct</span> sk_buff *skb),</span></span><br><span class="line"><span class="params">		   <span class="type">void</span> *from, <span class="type">int</span> len, <span class="type">int</span> protolen,</span></span><br><span class="line"><span class="params">		   <span class="keyword">struct</span> ipcm_cookie *ipc,</span></span><br><span class="line"><span class="params">		   <span class="keyword">struct</span> rtable **rt,</span></span><br><span class="line"><span class="params">		   <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一件事情，检查是否有 <code>MSG_PROBE</code> 的标志，有了这个标志的话，表示请求并不真的是需要向下调用。这个在测试对应 IP 地址的 PMTU 的时候会用到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags&amp;MSG_PROBE)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 <code>sock</code> 相关联的 <code>sk_write_queue</code> 队列为空，说明这个是第一个 IP fragment ，如果不是第一个那么就把 <code>transhdrlen</code> 设置成 0，因为只有第一个 IP fragment 才有头部长度的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (skb_queue_empty(&amp;sk-&gt;sk_write_queue)) &#123;</span><br><span class="line">	err = ip_setup_cork(sk, &amp;inet-&gt;cork.base, ipc, rtp);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	transhdrlen = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ip_setup_cork</code> 主要是初始化了 <code>net-&gt;cork</code>，<code>cork</code>  保存了 IP options 和 路由信息。</p>
<p>进入 <code>__append_ip_data</code> 之后可以看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   skb = skb_peek_tail(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">exthdrlen = !skb ? rt-&gt;dst.header_len : <span class="number">0</span>;</span><br><span class="line">mtu = cork-&gt;fragsize;</span><br><span class="line"><span class="keyword">if</span> (cork-&gt;tx_flags &amp; SKBTX_ANY_SW_TSTAMP &amp;&amp;</span><br><span class="line">    sk-&gt;sk_tsflags &amp; SOF_TIMESTAMPING_OPT_ID)</span><br><span class="line">	tskey = sk-&gt;sk_tskey++;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算 L2 头部长度，fragment 头部长度，最大可以容纳的 fragment 长度，还有不分片的情况下的最大长度。（如果忽略分片就直接默认最大值，64KB 就是 0xFFFF，否则使用 mtu）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hh_len = LL_RESERVED_SPACE(rt-&gt;dst.dev);</span><br><span class="line"></span><br><span class="line">fragheaderlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr) + (opt ? opt-&gt;optlen : <span class="number">0</span>);</span><br><span class="line">maxfraglen = ((mtu - fragheaderlen) &amp; ~<span class="number">7</span>) + fragheaderlen;</span><br><span class="line">maxnonfragsize = ip_sk_ignore_df(sk) ? <span class="number">0xFFFF</span> : mtu;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先累加的 buffer 长度不能超过最大的 IP 包长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cork-&gt;length + length &gt; maxnonfragsize - fragheaderlen) &#123;</span><br><span class="line">	ip_local_error(sk, EMSGSIZE, fl4-&gt;daddr, inet-&gt;inet_dport,</span><br><span class="line">		       mtu - (opt ? opt-&gt;optlen : <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> -EMSGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是第一个包，并且不会有新的分片，并且硬件支持 checksum 就可以标志为 <code>CHECKSUM_PARTIAL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * transhdrlen &gt; 0 means that this is the first fragment and we wish</span></span><br><span class="line"><span class="comment"> * it won&#x27;t be fragmented in the future.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (transhdrlen &amp;&amp;</span><br><span class="line">    length + fragheaderlen &lt;= mtu &amp;&amp;</span><br><span class="line">    rt-&gt;dst.dev-&gt;features &amp; (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM) &amp;&amp;</span><br><span class="line">    !(flags &amp; MSG_MORE) &amp;&amp;</span><br><span class="line">    !exthdrlen)</span><br><span class="line">	csummode = CHECKSUM_PARTIAL;</span><br></pre></td></tr></table></figure>

<p>下面如果满足下面条件就进入 <code>UDP Fragment Offload </code>例程。是硬件网卡提供的一种特性，由内核和驱动配合完成相关功能。其目的是由网卡硬件来完成本来需要软件进行的分段（分片）操作用于提升效率和性能。如大家所知，在网络上传输的数据包不能大于 mtu，当用户发送大于 mtu 的数据报文时，通常会在传输层（或者在特殊情况下在 IP 层分片，比如 ip 转发或 ipsec 时）就会按 mtu 大小进行分段，防止发送出去的报文大于 mtu，为提升该操作的性能，新的网卡硬件基本都实现了 UFO 功能，可以使分段（或分片）操作在网卡硬件完成，此时用户态就可以发送长度大于 mtu 的包，而且不必在协议栈中进行分段（或分片）。如果硬件支持，是 UDP 协议，并且是大于 mtu 的可以直接用这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((((length + fragheaderlen) &gt; mtu) || (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;</span><br><span class="line">    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;</span><br><span class="line">    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !dst_xfrm(&amp;rt-&gt;dst) &amp;&amp;</span><br><span class="line">    (sk-&gt;sk_type == SOCK_DGRAM) &amp;&amp; !sk-&gt;sk_no_check_tx) &#123;</span><br><span class="line">	err = ip_ufo_append_data(sk, <span class="built_in">queue</span>, getfrag, from, length,</span><br><span class="line">				 hh_len, fragheaderlen, transhdrlen,</span><br><span class="line">				 maxfraglen, flags);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>剩下的代码有点啰嗦，总体来说就是把 buff 拆分成可以直接发送的 IP fragment，但是需要先把道理讲清楚，不然看代码有点复杂。</p>
<p>确定剩余可以用来拷贝的空间，不能超过 mtu 和 maxfraglen</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the remaining data fits into current packet. */</span></span><br><span class="line">	copy = mtu - skb-&gt;len;</span><br><span class="line">	<span class="keyword">if</span> (copy &lt; length)</span><br><span class="line">		copy = maxfraglen - skb-&gt;len;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不够，就需要分配一个新的 skb，这里面的几个变量具体解释一下，首先是</p>
<p><code>fraggap</code> 表示的是 mtu 不是 8 的倍数，在最后那个比 8 的倍数多，又小于 mtu 的部分就是 <code>fraggap</code> 了，所以 <code>datalen</code> 是 <code>length + fraggap</code>，<code>fraggap</code> 这部分会从 <code>prev_skb</code> 尾部移动到新<code> skb</code> 的头部。<code>fraglen</code> 是带上 frag 头部的长度 <code>fraglen = datalen + fragheaderlen</code>。如果 flag 包含了 <code>MSG_MORE</code> 那么会尽量分配一个 mtu，当然这是在不支持 SG(Scatter/Gather I/O) 的情况下。因为支持 SG 的话，就可以直接分散的分配这些内存，最后进行 skb 的分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> (copy &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">char</span> *data;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> datalen;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> fraglen;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> fraggap;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> alloclen;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb_prev</span>;</span></span><br><span class="line">alloc_new_skb:</span><br><span class="line">			skb_prev = skb;</span><br><span class="line">			<span class="keyword">if</span> (skb_prev)</span><br><span class="line">				fraggap = skb_prev-&gt;len - maxfraglen;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				fraggap = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If remaining data exceeds the mtu,</span></span><br><span class="line"><span class="comment">			 * we know we need more fragment(s).</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			datalen = length + fraggap;</span><br><span class="line">			<span class="keyword">if</span> (datalen &gt; mtu - fragheaderlen)</span><br><span class="line">				datalen = maxfraglen - fragheaderlen;</span><br><span class="line">			fraglen = datalen + fragheaderlen;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((flags &amp; MSG_MORE) &amp;&amp;</span><br><span class="line">			    !(rt-&gt;dst.dev-&gt;features&amp;NETIF_F_SG))</span><br><span class="line">				alloclen = mtu;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				alloclen = fraglen;</span><br><span class="line"></span><br><span class="line">			alloclen += exthdrlen;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* The last fragment gets additional space at tail.</span></span><br><span class="line"><span class="comment">			 * Note, with MSG_MORE we overallocate on fragments,</span></span><br><span class="line"><span class="comment">			 * because we have no idea what fragment will be</span></span><br><span class="line"><span class="comment">			 * the last.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (datalen == length + fraggap)</span><br><span class="line">				alloclen += rt-&gt;dst.trailer_len;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (transhdrlen) &#123;</span><br><span class="line">				skb = sock_alloc_send_skb(sk,</span><br><span class="line">						alloclen + hh_len + <span class="number">15</span>,</span><br><span class="line">						(flags &amp; MSG_DONTWAIT), &amp;err);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				skb = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;sk-&gt;sk_wmem_alloc) &lt;=</span><br><span class="line">				    <span class="number">2</span> * sk-&gt;sk_sndbuf)</span><br><span class="line">					skb = sock_wmalloc(sk,</span><br><span class="line">							   alloclen + hh_len + <span class="number">15</span>, <span class="number">1</span>,</span><br><span class="line">							   sk-&gt;sk_allocation);</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!skb))</span><br><span class="line">					err = -ENOBUFS;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!skb)</span><br><span class="line">				<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>length</code> 表示需要传输的长度，在循环不断进行中这个 <code>length</code> 就会变成 0。</p>
<p>接下来的部分是初始化 <code>csum</code> 和 <code>ip_summed</code> 保留硬件头部长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Fill in the control structures</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">skb-&gt;ip_summed = csummode;</span><br><span class="line">skb-&gt;csum = <span class="number">0</span>;</span><br><span class="line">skb_reserve(skb, hh_len);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置 <code>tx_flags</code> 和 <code>tskey</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* only the initial fragment is time stamped */</span></span><br><span class="line">			skb_shinfo(skb)-&gt;tx_flags = cork-&gt;tx_flags;</span><br><span class="line">			cork-&gt;tx_flags = <span class="number">0</span>;</span><br><span class="line">			skb_shinfo(skb)-&gt;tskey = tskey;</span><br><span class="line">			tskey = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保留数据空间，并且把指针移动到头部后面，指向负载的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> *	Find where to start putting bytes.</span><br><span class="line"> */</span><br><span class="line">data = skb_put(skb, fraglen + exthdrlen);</span><br><span class="line">skb_set_network_header(skb, exthdrlen);</span><br><span class="line">skb-&gt;transport_header = (skb-&gt;network_header +</span><br><span class="line">			 fragheaderlen);</span><br><span class="line">data += fragheaderlen + exthdrlen;</span><br></pre></td></tr></table></figure>
<p>这部分就是把上个 skb 的 fraggap 移到当前这个，并且重新获取 checksum。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fraggap) &#123;</span><br><span class="line">	skb-&gt;csum = skb_copy_and_csum_bits(</span><br><span class="line">		skb_prev, maxfraglen,</span><br><span class="line">		data + transhdrlen, fraggap, <span class="number">0</span>);</span><br><span class="line">	skb_prev-&gt;csum = csum_sub(skb_prev-&gt;csum,</span><br><span class="line">				  skb-&gt;csum);</span><br><span class="line">	data += fraggap;</span><br><span class="line">	pskb_trim_unique(skb_prev, maxfraglen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来调用 <code>getfrag</code> 拷贝数据，加入到队尾。</p>
<p>getfrag 对应的 4 个 routine 分别是</p>
<ul>
<li>ICMP  icmp_glue_bits</li>
<li>UDP.   ip_generic_getfrag</li>
<li>RAW   iP ip_generic_getfrag</li>
<li>TCP.    Ip_reply_glue_bits</li>
</ul>
<p>getfrag 的功能就是从 from 拷贝到 to ，因为可能是用户态的数据，所以包含了地址转换的功能并且在比好的时候重新计算校验和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	copy = datalen - transhdrlen - fraggap;</span><br><span class="line">	<span class="keyword">if</span> (copy &gt; <span class="number">0</span> &amp;&amp; getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err = -EFAULT;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	offset += copy;</span><br><span class="line">	length -= datalen - fraggap;</span><br><span class="line">	transhdrlen = <span class="number">0</span>;</span><br><span class="line">	exthdrlen = <span class="number">0</span>;</span><br><span class="line">	csummode = CHECKSUM_NONE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; MSG_CONFIRM) &amp;&amp; !skb_prev)</span><br><span class="line">		skb_set_dst_pending_confirm(skb, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Put the packet on the pending queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__skb_queue_tail(<span class="built_in">queue</span>, skb);</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>剩下的就是 copy 足够，不需要分配新的 skb 的条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy &gt; length)</span><br><span class="line">	copy = length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(rt-&gt;dst.dev-&gt;features&amp;NETIF_F_SG)) &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> off;</span><br><span class="line"></span><br><span class="line">	off = skb-&gt;len;</span><br><span class="line">	<span class="keyword">if</span> (getfrag(from, skb_put(skb, copy),</span><br><span class="line">			offset, copy, off, skb) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		__skb_trim(skb, off);</span><br><span class="line">		err = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = skb_shinfo(skb)-&gt;nr_frags;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (!sk_page_frag_refill(sk, pfrag))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!skb_can_coalesce(skb, i, pfrag-&gt;page,</span><br><span class="line">			      pfrag-&gt;offset)) &#123;</span><br><span class="line">		err = -EMSGSIZE;</span><br><span class="line">		<span class="keyword">if</span> (i == MAX_SKB_FRAGS)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">		__skb_fill_page_desc(skb, i, pfrag-&gt;page,</span><br><span class="line">				     pfrag-&gt;offset, <span class="number">0</span>);</span><br><span class="line">		skb_shinfo(skb)-&gt;nr_frags = ++i;</span><br><span class="line">		get_page(pfrag-&gt;page);</span><br><span class="line">	&#125;</span><br><span class="line">	copy = <span class="type">min_t</span>(<span class="type">int</span>, copy, pfrag-&gt;size - pfrag-&gt;offset);</span><br><span class="line">	<span class="keyword">if</span> (getfrag(from,</span><br><span class="line">		    page_address(pfrag-&gt;page) + pfrag-&gt;offset,</span><br><span class="line">		    offset, copy, skb-&gt;len, skb) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error_efault;</span><br><span class="line"></span><br><span class="line">	pfrag-&gt;offset += copy;</span><br><span class="line">	skb_frag_size_add(&amp;skb_shinfo(skb)-&gt;frags[i - <span class="number">1</span>], copy);</span><br><span class="line">	skb-&gt;len += copy;</span><br><span class="line">	skb-&gt;data_len += copy;</span><br><span class="line">	skb-&gt;truesize += copy;</span><br><span class="line">	<span class="type">atomic_add</span>(copy, &amp;sk-&gt;sk_wmem_alloc);</span><br><span class="line">&#125;</span><br><span class="line">offset += copy;</span><br><span class="line">length -= copy;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/06/05/VFIO-%E2%80%94%E2%80%94%E5%B0%86-DMA-%E6%98%A0%E5%B0%84%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/06/05/VFIO-%E2%80%94%E2%80%94%E5%B0%86-DMA-%E6%98%A0%E5%B0%84%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81/" class="post-title-link" itemprop="url">VFIO ——将 DMA 映射暴露给用户态</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-06-05 01:16:11" itemprop="dateCreated datePublished" datetime="2017-06-05T01:16:11+08:00">2017-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/06/05/VFIO-%E2%80%94%E2%80%94%E5%B0%86-DMA-%E6%98%A0%E5%B0%84%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/06/05/VFIO-——将-DMA-映射暴露给用户态/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="VFIO——将设备暴露到用户态"><a href="#VFIO——将设备暴露到用户态" class="headerlink" title="VFIO——将设备暴露到用户态"></a>VFIO——将设备暴露到用户态</h1><p>在开始之前我们先要说一个东西就是 DMA，直接让设备访问内存，可以不通过 CPU 搬运数据。</p>
<img data-src="/zh-CN/2017/06/05/VFIO-%E2%80%94%E2%80%94%E5%B0%86-DMA-%E6%98%A0%E5%B0%84%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81/p1.jpg" class="">

<p>这是一个比较简单的体系结构图，设备 和 CPU 通过存储控制器访问存储器。一个简单的 case 是 CPU 向存储器写数据，然后设备从存储器读数据。这么快来一切都很正常。但是实际上 CPU 是有一层缓存的，例如下面这样的。</p>
<img data-src="/zh-CN/2017/06/05/VFIO-%E2%80%94%E2%80%94%E5%B0%86-DMA-%E6%98%A0%E5%B0%84%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81/p2.jpg" class="">

<p>CPU 想内存写数据，但是先要清空到不一致的缓存，然后设备再去读数据，不然设备读到的数据和 CPU 实际的数据会不一致（因为缓存里的数据可能和存储器的不一致），而且实际上缓存也不只是一层，所以需要一个中间层来保证 从 CPU 的角度和从设备的角度内存都是一致的，所以就有了下面这个结构。</p>
<img data-src="/zh-CN/2017/06/05/VFIO-%E2%80%94%E2%80%94%E5%B0%86-DMA-%E6%98%A0%E5%B0%84%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81/p3.jpg" class="">

<p>CPU 和 设备都会走缓存验证一遍以后，再落到存储器上，这样带上缓存以后大家的一致性都是一样的了。所以从设备的角度，设备也拥有了缓存，实际上这个和 IOMMU 关系不是很大，接下来设备其实也可以和 CPU 一样有一层 MMU，也就是地址到存储器物理地址的转换。注意，这里我用了地址，因为对 CPU 来说是虚拟地址，但是对设备来说是一个总线域的地址。<strong>这里要明确区分一下，一个是总线地址，是从设备的角度来看的，一个是 CPU 的虚拟地址，这是从 CPU 角度来看的，两个是不同的东西。将总线域地址转换成存储器物理地址的设备就叫 IOMMU。</strong></p>
<img data-src="/zh-CN/2017/06/05/VFIO-%E2%80%94%E2%80%94%E5%B0%86-DMA-%E6%98%A0%E5%B0%84%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81/p4.jpg" class="">


<p>如果没有 IOMMU，DMA 也能照常工作，IOMMU 的主要作用就是保护功能，防止使用 DMA 的设备访问任意存储器的物理地址。</p>
<p>IOMMU 在不同架构上名字不太一样，AMD 叫 AMD-Vi，最开始针对的设备只是显卡，Intel 叫 VT-d，arm 叫 SMMU，具体对应的手册也不太一样，但是主要解决的问题是一致的。在 VTd 中，dmar (DMA remapping) 就是那个 IOMMU 设备，通过中断的方式实现类似 page fault 一样的内存分配行为。DMA 传输是由 CPU 发起的：CPU 会告诉 DMA 控制器，帮忙将 xxx 地方的数据搬到 xxx 地方。CPU 发完指令之后，就当甩手掌柜了。IOMMU 有点像 MMU 是一个将设备地址翻译到内存地址的页表体系，也会有对应的页表，这个东西在虚拟化中也非常有用，可以将原本有软件模拟的设备，用直接的硬件替代，而原本的隔离通过 IOMMU 来完成。如下图所示，原本需要通过软件模拟的驱动设备可以通过 IOMMU 以__安全__的方式来直接把硬件设备分配个用户态的 Guest OS。</p>
<img data-src="/zh-CN/2017/06/05/VFIO-%E2%80%94%E2%80%94%E5%B0%86-DMA-%E6%98%A0%E5%B0%84%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81/p5.jpg" class="">

<p>理论上讲没有 IOMMU 实际上是可以工作的，但是硬件的角度，设备就拥有了整个存储器的全局视图，这是无论如何都非常不合理的事情，不应该让设备拥有访问任意物理内存的能力。</p>
<p>这里要提的另外一个功能就是对中断的隔离，类似于下面的通过在中断请求中添加标识来重定向中断到对应的中断回调上。</p>
<img data-src="/zh-CN/2017/06/05/VFIO-%E2%80%94%E2%80%94%E5%B0%86-DMA-%E6%98%A0%E5%B0%84%E6%9A%B4%E9%9C%B2%E7%BB%99%E7%94%A8%E6%88%B7%E6%80%81/p6.jpg" class="">

<p>VFIO 的作用就是通过 IOMMU 以安全的方式来将设备的访问直接暴露到用户空间，而不用专门完成某个驱动等待合并到上游或者使用之前的对 IOMMU 没有感知的 UIO 的框架。通过 VFIO 向用户态开放 IOMMU 的功能，编写用户态的驱动。</p>
<p>对于 IOMMU 来说，隔离的级别不一定是单个设备，比如一个后面有几个设备的 PCI 桥，从 PCI 桥角度来说，都是来自 PCI 桥的总线事务。所以 IOMMU 有一个 <code>iommu_group</code>的概念，代表一组与其他设备隔离的设备的集合。</p>
<p>IOMMU 根据手册上讲还有一个域的概念，可以简单理解为一段物理地址的抽象。</p>
<p>在 <code>iommu_group </code>的层级上，VFIO 封装了一层 <code>container class</code>，这个的作用对应于希望能够在不同的<code>iommu_group</code> 之间共享 <code>TLB</code> 和 <code>page tables</code>，这个就是一个集合的概念，跟容器的那个概念没啥关系，一个集合总归要有个名字。通过把 host 的 device 和 driver 解绑，然后绑定到 VFIO 的 driver 上，就会有个<code>/dev/vfio/$GROUP/</code> 出现，然后这个 <code>$GROUP</code>代表的就是这个 device 的 <code>iommu_group</code>号，如果要使用 VFIO 就要把这个 group 下的所有 device 都解绑才可以。</p>
<p>通过打开<code>/dev/vfio/vfio</code>就能创建一个 VFIO 的 container，然后再打开<code>/dev/vfio/$GROUP</code>用<code>VFIO_GROUP_SET_CONTAINER</code> ioctl 把文件描述传进去，就把 group 加进去了，如果支持多个 group 共享页表等结构，还可以把相应的 group 也加进去。（<strong>再强调一遍这个页表是总线地址到存储器物理地址，IOMMU 管理的那个页表</strong>）。</p>
<p>下面举个官方的栗子，获取 PCI 设备 0000:06:0d.0 的 <code>group_id</code> （PCI 命名的规则是 <code>domain:bus:slot.func</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ readlink /sys/bus/pci/devices/0000:06:0d.0/iommu_group</span><br><span class="line">../../../../kernel/iommu_groups/26</span><br></pre></td></tr></table></figure>

<p>使用之前需要你已经加载了 VFIO 模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe vfio-pci</span><br></pre></td></tr></table></figure>

<p>解绑 PCI 设备，然后创建一个 container id</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lspci -n -s 0000:06:0d.0</span><br><span class="line">06:0d.0 0401: 1102:0002 (rev 08)</span><br><span class="line"># echo 0000:06:0d.0 &gt; /sys/bus/pci/devices/0000:06:0d.0/driver/unbind</span><br><span class="line"># echo 1102 0002 &gt; /sys/bus/pci/drivers/vfio-pci/new_id</span><br></pre></td></tr></table></figure>

<p>然后寻找其他同属于一个 group 的设备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /sys/bus/pci/devices/0000:06:0d.0/iommu_group/devices</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 Apr 23 16:13 0000:00:1e.0 -&gt;</span><br><span class="line">	../../../../devices/pci0000:00/0000:00:1e.0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 Apr 23 16:13 0000:06:0d.0 -&gt;</span><br><span class="line">	../../../../devices/pci0000:00/0000:00:1e.0/0000:06:0d.0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 Apr 23 16:13 0000:06:0d.1 -&gt;</span><br><span class="line">	../../../../devices/pci0000:00/0000:00:1e.0/0000:06:0d.1</span><br></pre></td></tr></table></figure>

<p>PCI 桥 <code>0000:00:1e.0</code> 后面挂了两个设备，一个是刚才加进去的 <code>0000:06:0d.0</code>，还有一个是 <code>0000:06:0d.1</code>，通过上面的步奏加进去就可以。</p>
<p>最后一步是让用户有权限使用这个 group。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chown user:user /dev/vfio/26</span><br></pre></td></tr></table></figure>

<p>下面就是一个样例，从用户态使用 VFIO，整个的使用方式是通过 <code>ioctl</code>来获取中断相关信息，以及注册中断处理函数，然后也是通过 <code>ioctl</code>来获取<code>region</code>信息，然后调用相应的<code>mmap</code>函数，让 CPU 可以访问内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">int container, group, device, i;</span><br><span class="line">struct vfio_group_status group_status =</span><br><span class="line">				&#123; .argsz = sizeof(group_status) &#125;;</span><br><span class="line">struct vfio_iommu_type1_info iommu_info = &#123; .argsz = sizeof(iommu_info) &#125;;</span><br><span class="line">struct vfio_iommu_type1_dma_map dma_map = &#123; .argsz = sizeof(dma_map) &#125;;</span><br><span class="line">struct vfio_device_info device_info = &#123; .argsz = sizeof(device_info) &#125;;</span><br><span class="line"></span><br><span class="line">/* Create a new container */</span><br><span class="line">container = open(&quot;/dev/vfio/vfio&quot;, O_RDWR);</span><br><span class="line"></span><br><span class="line">if (ioctl(container, VFIO_GET_API_VERSION) != VFIO_API_VERSION)</span><br><span class="line">	/* Unknown API version */</span><br><span class="line"></span><br><span class="line">if (!ioctl(container, VFIO_CHECK_EXTENSION, VFIO_TYPE1_IOMMU))</span><br><span class="line">	/* Doesn&#x27;t support the IOMMU driver we want. */</span><br><span class="line"></span><br><span class="line">/* Open the group */</span><br><span class="line">group = open(&quot;/dev/vfio/26&quot;, O_RDWR);</span><br><span class="line"></span><br><span class="line">/* Test the group is viable and available */</span><br><span class="line">ioctl(group, VFIO_GROUP_GET_STATUS, &amp;group_status);</span><br><span class="line"></span><br><span class="line">if (!(group_status.flags &amp; VFIO_GROUP_FLAGS_VIABLE))</span><br><span class="line">	/* Group is not viable (ie, not all devices bound for vfio) */</span><br><span class="line"></span><br><span class="line">/* Add the group to the container */</span><br><span class="line">ioctl(group, VFIO_GROUP_SET_CONTAINER, &amp;container);</span><br><span class="line"></span><br><span class="line">/* Enable the IOMMU model we want */</span><br><span class="line">ioctl(container, VFIO_SET_IOMMU, VFIO_TYPE1_IOMMU);</span><br><span class="line"></span><br><span class="line">/* Get addition IOMMU info */</span><br><span class="line">ioctl(container, VFIO_IOMMU_GET_INFO, &amp;iommu_info);</span><br><span class="line"></span><br><span class="line">/* Allocate some space and setup a DMA mapping */</span><br><span class="line">dma_map.vaddr = mmap(0, 1024 * 1024, PROT_READ | PROT_WRITE,</span><br><span class="line">		     MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);</span><br><span class="line">dma_map.size = 1024 * 1024;</span><br><span class="line">dma_map.iova = 0; /* 1MB starting at 0x0 from device view */</span><br><span class="line">dma_map.flags = VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE;</span><br><span class="line"></span><br><span class="line">ioctl(container, VFIO_IOMMU_MAP_DMA, &amp;dma_map);</span><br><span class="line"></span><br><span class="line">/* Get a file descriptor for the device */</span><br><span class="line">device = ioctl(group, VFIO_GROUP_GET_DEVICE_FD, &quot;0000:06:0d.0&quot;);</span><br><span class="line"></span><br><span class="line">/* Test and setup the device */</span><br><span class="line">ioctl(device, VFIO_DEVICE_GET_INFO, &amp;device_info);</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; device_info.num_regions; i++) &#123;</span><br><span class="line">	struct vfio_region_info reg = &#123; .argsz = sizeof(reg) &#125;;</span><br><span class="line"></span><br><span class="line">	reg.index = i;</span><br><span class="line"></span><br><span class="line">	ioctl(device, VFIO_DEVICE_GET_REGION_INFO, &amp;reg);</span><br><span class="line"></span><br><span class="line">	/* Setup mappings... read/write offsets, mmaps</span><br><span class="line">	 * For PCI devices, config space is a region */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; device_info.num_irqs; i++) &#123;</span><br><span class="line">	struct vfio_irq_info irq = &#123; .argsz = sizeof(irq) &#125;;</span><br><span class="line"></span><br><span class="line">	irq.index = i;</span><br><span class="line"></span><br><span class="line">	ioctl(device, VFIO_DEVICE_GET_IRQ_INFO, &amp;irq);</span><br><span class="line"></span><br><span class="line">	/* Setup IRQs... eventfds, VFIO_DEVICE_SET_IRQS */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Gratuitous device reset and go... */</span><br><span class="line">ioctl(device, VFIO_DEVICE_RESET);</span><br></pre></td></tr></table></figure>

<p>在<code>include/linux/vfio.h</code>里面有完整的 API，这里就简单略过。</p>
<p>在理解了一些基本原理和使用方式之后再来看 VFIO 的代码应该叫就比较容易理解了。</p>
<p>首先是作为 PCI 设备的 <code>probe</code>。主要是通过 <code>vfio_iommu_group_get </code>分配 <code>iommu_group</code>，然后调用<code>vfio_add_group_dev</code>初始化设备回调接口<code>vfio_pci_ops</code>，而<code>remove</code>就是反过来把对应的结构释放掉就可以。然后再看注册的回调函数结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static const struct vfio_device_ops vfio_pci_ops = &#123;</span><br><span class="line">	.name		= &quot;vfio-pci&quot;,</span><br><span class="line">	.open		= vfio_pci_open,</span><br><span class="line">	.release	= vfio_pci_release,</span><br><span class="line">	.ioctl		= vfio_pci_ioctl,</span><br><span class="line">	.read		= vfio_pci_read,</span><br><span class="line">	.write		= vfio_pci_write,</span><br><span class="line">	.mmap		= vfio_pci_mmap,</span><br><span class="line">	.request	= vfio_pci_request,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里分析几个关键的函数，他们会通过<code>file_operations vfio_fops</code>被间接的调用。</p>
<p>首先是 mmap，就是在调用<code>vfio_pci_mmap</code>的时候最终调用<code>remap_pfn_range(vma, vma-&gt;vm_start, vma-&gt;vm_pgoff, req_len, vma-&gt;vm_page_prot);</code> 来将物理内存映射到用户态空间，这就是上面的栗子中 mmap 系统调用的入口，而具体要映射的物理内存是通过一系列<code>pci_resource_xxx</code>宏从 PCI bar 空间读出来的配置。</p>
<p>然后是 ioctl 接口，这个接口比较丰富，也简单的看一下。比如 <code>VFIO_DEVICE_SET_IRQS</code>会通过使用用户态传进来的结构体，调用<code>vfio_pci_set_irqs_ioctl</code>注册中断处理函数。而通过<code>vfio_ioctl_set_iommu</code>会设置 container 的 iommu_group 以及对应的 driver。<code>read/write</code>接口都是用于修改 PCI 配置信息的。</p>
<p>简单的来说，VFIO 的主要工作是把设备通过 IOMMU 映射的 DMA 物理内存地址映射到用户态中，让用户态程序可以自行操纵设备的传输，并且可以保证一定程度的<strong>安全</strong>，另外可以自行注册中断处理函数，从而在用户态实现设备的驱动程序，通过这样的框架，可以在 DPDK 中充分发挥用户态协议栈的威力。</p>
<p>参考文献</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://lambda.hk/linux_kernel/2014/11/28/pci-arch/">PCI 基本概念</a></li>
<li><a target="_blank" rel="noopener" href="http://linuxperf.com/?p=67">dmar 和 iommu</a></li>
<li><a target="_blank" rel="noopener" href="http://mcit.xjtu.edu.cn/wlkj/wykj/ch2/ch2_3_1.htm#2.3.1_%E6%80%BB%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">总线基本概念</a></li>
<li>《PCI Express 体系结构导读》王齐著</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=n07zPcbdX_w&t=887s">mastering the dma and iommu apis</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/vfio.txt">VFIO - “Virtual Function I/O”</a></li>
<li><a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/embedded/technology/virtualization/vt-directed-io-spec.html">Intel® Virtualization Technology for Directed I/O: Spec</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-pci/">Linux 下 PCI 设备驱动程序开发</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/05/19/cgroup-%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B9%8B-net-cls-%E5%92%8C-net-prio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/05/19/cgroup-%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B9%8B-net-cls-%E5%92%8C-net-prio/" class="post-title-link" itemprop="url">cgroup 子系统之 net_cls 和 net_prio</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-05-19 02:21:03" itemprop="dateCreated datePublished" datetime="2017-05-19T02:21:03+08:00">2017-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/05/19/cgroup-%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B9%8B-net-cls-%E5%92%8C-net-prio/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/05/19/cgroup-子系统之-net-cls-和-net-prio/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在分析<code>net_cls</code>和<code>net_prio</code>之前先要解释几个东西，一个是网络的 QoS 以及 netfilter。</p>
<h2 id="网络-QoS"><a href="#网络-QoS" class="headerlink" title="网络 QoS"></a>网络 QoS</h2><p>IP 服务模型是尽力而为的，这样的模型不能体现某些流量的重要性，所以诞生了<code>QOS</code>技术，Linux 很早就提供了流量控制接口，命令行工具是<code>tc</code>。</p>
<p>协议栈的 QoS 主要由三部分组成。</p>
<p>qdisc 队列规则（queueing discipline)，class 控制策略，filter 根据 filter 划入具体的控制策略（class）。</p>
<p>一般由流程是这样的，当一个 qdisc 被入队的时候，会循环匹配其中的 filter 如果匹配到了的话，就会将 packet 入队到对应的 class 当中，大部分情况下被 class 的“所有者”代表的 qdisc 入队。一些没有匹配的 packet 会进入默认的 class。下面将会介绍几种常用的 queue discpline。</p>
<h3 id="pfifo"><a href="#pfifo" class="headerlink" title="pfifo"></a>pfifo</h3><p>默认 qdisc 就是 pfifo，实现在 <code>net/sched/sch_prio.c</code>。</p>
<p>设有三个优先级的队列，优先级由高到低分别是</p>
<ol start="0">
<li>“interactive”</li>
<li>“best effort”</li>
<li>“bulk”</li>
</ol>
<p>先消费 0 队列再消费 1 队列，依次类推，一般的<code>packet</code>都是属于 1。</p>
<p><img data-src="http://linux-ip.net/articles/Traffic-Control-HOWTO/images/pfifo_fast-qdisc.png" alt="pfifo"></p>
<p>用 IP 的 ToS 可以映射到这些队列，对应的关系如图。</p>
<p><img data-src="http://www.cisco.com/c/dam/en/us/support/docs/quality-of-service-qos/qos-link-efficiency-mechanisms/24906-152-n.gif" alt="tos"></p>
<img data-src="/zh-CN/2017/05/19/cgroup-%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B9%8B-net-cls-%E5%92%8C-net-prio/map.jpg" class="">

<p>他的实现依赖下面这个结构，bands 一般是 3 个，代表三个不同优先级的队列，然后<code>filter_list</code>是他的过滤器列表，最后<code>prio2band</code>就是上图的<code>ToS To Queue</code> 的映射中的<code>Linux priority 到 Band</code>的那部分，<code>queues</code>保存的是三个<code>fifo</code>的<code>qdisc</code>，也就是三个最简单的队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct prio_sched_data &#123;</span><br><span class="line">	int bands;</span><br><span class="line">	struct tcf_proto __rcu *filter_list;</span><br><span class="line">	u8  prio2band[TC_PRIO_MAX+1];</span><br><span class="line">	struct Qdisc *queues[TCQ_PRIO_BANDS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里虽然和 IP 的 ToS 暂时没有关系，但是最后<code>cgroup</code>的部分会提到怎么联系起来的。</p>
<p>pfifo enqueue 的时候会调用<code>prio_classify</code>根据<code>skb-&gt;priority</code>来选择队列进行入队，dequeue 的时候则 round robin 每次依次从优先级高到低取出一个 packet。</p>
<h3 id="HTB-Hierarchical-Token-Bucket"><a href="#HTB-Hierarchical-Token-Bucket" class="headerlink" title="HTB (Hierarchical Token Bucket)"></a>HTB (Hierarchical Token Bucket)</h3><p>HTB 是一个层级令牌桶的 qdisc，而且可以加入 class，HTB 的整体结构如下，HTB 的作者在<a target="_blank" rel="noopener" href="http://luxik.cdi.cz/~devik/qos/htb/manual/theory.htm">这里</a> 解释了他的设计。</p>
<p>这里简单解释一下，每个 class 有一个 AR（保障速率）CR（最大速率），P（优先级），level（在树中的层次），quantum（量子，一个动态参数），和实际的速率 R，中间层的 class 通过计算子层的速率获得。</p>
<p>Leaf 没有子节点，并且只有 Leaf 有传输功能的 queue，其他只是帮助构造层级关系。</p>
<p>Mode class 的状态</p>
<ol>
<li><p> Red ( R &gt; CR ) 也就是超速</p>
</li>
<li><p> Yellow (R &lt;= CR &amp;&amp; R &gt; AR) 也就是合理超速</p>
</li>
<li><p> Green 就是没有超过保障速率</p>
</li>
</ol>
<p>下面我们有几个等式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rc = min(CRc, ARc + Bc)        [eq1]</span><br></pre></td></tr></table></figure>

<p>Bc 表示从祖先那里借到的速率，下面这段公式表示的意思是，如果我是当前 prio 最小的，从优先级的兄弟节点中加权平均借到父节点的速率，其他的 prio 更大的节点都不能借到速率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       Qc Rp</span><br><span class="line">Bc = -----------------------------  iff min[Pi over D(p)]&gt;=Pc  [eq2]</span><br><span class="line">     sum[Qi over D(p) where Pi=Pc]</span><br><span class="line"></span><br><span class="line">Bc = 0   otherwise      [eq3]</span><br></pre></td></tr></table></figure>

<p>如果没有父节点的话，Bc 就是 0。这样算出来代表的意义是什么呢，就是说先服务优先级更高的节点，并且按照量子的大小在同优先级的节点中分配速率。</p>
<p>然后我们具体看一下 HTB 调度器是如何工作的。</p>
<p><img data-src="http://luxik.cdi.cz/~devik/qos/htb/manual/feed1.gif" alt="htb_sch_1"></p>
<p><img data-src="http://luxik.cdi.cz/~devik/qos/htb/manual/feed2.gif" alt="htb_sch_2"></p>
<p>每个 class 有个 slot 包含不同的 prio 级别，指向 yellow 的子节点，然后每个层级包含一个 slot 也有不同的 prio 级别指向这一层中 green 的节点，上图展示了的是有两个 prio 的 slot，右边的 self slot 有个白色的是用于 yellow red 的 wait list。</p>
<p>假设当前如图 1 的状态，所有节点都是绿的没有 packet 到来，现在有有两个包到达 C 和 D，然后激活它们，并且它们现在都是绿的，所以 self slot 指向他们，然后因为 D 的优先级更高，所以先把 D 出队。所以你可以发现，出队的顺序很简答，就是按照优先级从 self slot 里面把绿色的包按顺序取出来就可以。</p>
<p><img data-src="http://luxik.cdi.cz/~devik/qos/htb/manual/feed3.gif" alt="feed3"></p>
<p><img data-src="http://luxik.cdi.cz/~devik/qos/htb/manual/feed4.gif" alt="feed4"></p>
<p>然后我们看一下更复杂的情况，在图 3 中，我们从 D 中出队一个 packet(<code>htb_dequeue</code>)，然后<code>htb_charge_class</code>会增加 D 的速率，导致 D 变成 yellow，离开 self slot （通过<code>htb_deactivate_prios</code>和<code>htb_remove_class_from_row</code>)，然后添加到 B 的 slot 里面 (<code>htb_activate_prios</code>)，并且递归向上添加<code>htb_add_class_to_row</code>，D 会在一段时间后进入 self slot 的白色等待区，然后 D 又会变回绿色。现在如果选择的话，就会从 C 出队，因为虽然 C 的优先级低但是 C 不需要借别人的速率。</p>
<p>在图 4，假设 C 已经完全消耗了速率达到了最大限速，这个时候 D 就会开始工作然后把 B 消耗完，B 被消耗了以后就会去消耗 A，从这里就可以看到一个借取的过程。</p>
<p><img data-src="http://luxik.cdi.cz/~devik/qos/htb/manual/feed5.gif" alt="htb_sch_5"></p>
<p><img data-src="http://luxik.cdi.cz/~devik/qos/htb/manual/feed6.gif" alt="htb_sch_6"></p>
<p>现在说一个更复杂一点的例子，在图 5 中，A 已经被消耗光了，E 开始工作，然后 C 也能开始工作，变成图 6 的样子。注意即使 D 没有被使用但是他的优先级还会被 class slot 维持，也就是红线。但是 C 和 E 都是同一个优先级，这样的话，就要使用 DRR 算法（也就是在 RR 算法上给每个变量加一个权重，也就是之前的那个量子 quantom)。然后也可以发现一个 class 可以对不同的优先级（红色和蓝色）保持 active。</p>
<p>下面是一个 HTB 的全貌图，抽象的可以理解成一个从父 class 中根据优先级带权重的分享令牌的一个算法。</p>
<p><img data-src="http://linux-ip.net/articles/Traffic-Control-HOWTO/images/htb-class.png" alt="htb arch"></p>
<p>下面三个值对应的就是三种颜色。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* used internaly to keep status of single class */</span><br><span class="line">enum htb_cmode &#123;</span><br><span class="line">	HTB_CANT_SEND,		/* class can&#x27;t send and can&#x27;t borrow */</span><br><span class="line">	HTB_MAY_BORROW,		/* class can&#x27;t send but may borrow */</span><br><span class="line">	HTB_CAN_SEND		/* class can send */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>HTB 的实现依赖于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct htb_sched &#123;</span><br><span class="line">	struct Qdisc_class_hash clhash;</span><br><span class="line">	int			defcls;		/* class where unclassified flows go to */</span><br><span class="line">	int			rate2quantum;	/* quant = rate / rate2quantum */</span><br><span class="line"></span><br><span class="line">	/* filters for qdisc itself */</span><br><span class="line">	struct tcf_proto __rcu	*filter_list;</span><br><span class="line"></span><br><span class="line">#define HTB_WARN_TOOMANYEVENTS	0x1</span><br><span class="line">	unsigned int		warned;	/* only one warning */</span><br><span class="line">	int			direct_qlen;</span><br><span class="line">	struct work_struct	work;</span><br><span class="line"></span><br><span class="line">	/* non shaped skbs; let them go directly thru */</span><br><span class="line">	struct qdisc_skb_head	direct_queue;</span><br><span class="line">	long			direct_pkts;</span><br><span class="line"></span><br><span class="line">	struct qdisc_watchdog	watchdog;</span><br><span class="line"></span><br><span class="line">	s64			now;	/* cached dequeue time */</span><br><span class="line">	struct list_head	drops[TC_HTB_NUMPRIO];/* active leaves (for drops) */</span><br><span class="line"></span><br><span class="line">	/* time of nearest event per level (row) */</span><br><span class="line">	s64			near_ev_cache[TC_HTB_MAXDEPTH];</span><br><span class="line"></span><br><span class="line">	int			row_mask[TC_HTB_MAXDEPTH];</span><br><span class="line"></span><br><span class="line">	struct htb_level	hlevel[TC_HTB_MAXDEPTH];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中<code>hlevel</code>对应的就是<code>self slot</code>，而<code>clhash</code> 可以通过 classid 找到 <code>hub_class</code>，其中的<code>-&gt;un.inner</code>就是对应的<code>class slot</code>，<code>-&gt;un.leaf</code>对应的就是叶子结点。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>qdisc 参数</p>
<p>parent major:minor  或者 <em>root</em>。</p>
<p>一个 qdisc 是根节点就是 root，否则其他的情况指定 parent。其中 major:minor 是 class 的 handle id，每个 class 都要指定一个 id 用于标识。</p>
<p><em>handle major:</em> ，这个语法有点奇怪，是可选的，如果 qdisc 下面还要分类（多个 class)，则需要指定这个 hanlde。对于 root，通常是”1:”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// handle 是一组用户指定的标示符，格式为 major:minor。</span><br><span class="line">// 如果是一条 queueing discipline，minor 需要一直为 0。</span><br><span class="line"># tc qdisc add dev eth0 root handle 1: htb</span><br><span class="line"></span><br><span class="line">// parent 指明该新增的 class 添加到那一个父 handle 上去</span><br><span class="line">// classid 指明该 class handle 的唯一 ID，minor 需要是非零值</span><br><span class="line">// ceil 定义 rate 的上界</span><br><span class="line"># tc class add dev eth0 parent 1:1 classid 1:6 htb rate 256kbit ceil 512kbit</span><br><span class="line"></span><br><span class="line">// 新建一个带宽为 100kbps 的 root class, 其 classid 为 1:1</span><br><span class="line"># tc class add dev eth0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps</span><br><span class="line">// 接着建立两个子 class，指定其 parent 为 1:1，ceil 用来限制子类最大的带宽</span><br><span class="line"># tc class add dev eth0 parent 1:1 classid 1:10 htb rate 40kbps ceil 100kbps</span><br><span class="line"># tc class add dev eth0 parent 1:1 classid 1:11 htb rate 60kbps ceil 100kbps</span><br><span class="line">// 随后建立 filter 指定哪些类型的 packet 进入那个 class</span><br><span class="line"># tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 match ip dport 80 0xffff flowid 1:10</span><br><span class="line"># tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 flow 1:11</span><br><span class="line">// 最后为这些 class 添加 queuing disciplines</span><br><span class="line"># tc qdisc add dev eth0 parent 1:10 handle 20: pfifo limit 5</span><br><span class="line"># tc qdisc add dev eth0 parent 1:11 handle 30: sfq perturb 10</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>用 rtnetlink 接口实现 API。</p>
<p>在<code>include/net/sch_generic.h</code>下有<code>Qdisc_ops</code>,<code>Qdisc_class_ops</code>,<code>tcf_proto_ops</code>的定义。</p>
<p>同一个文件下还有<code>Qdisc_class_ops</code>的定义。</p>
<p><code>qdisc_run</code>首先检查设备的运行状态然后调用<code>__qdisc_run</code>，这个函数的主体就是调用 <code>qdisc_restart</code>, 直到超过限制或者需要让出时间 CPU 了，最后清空 <code>qdisc</code>的 <code>RUNNING</code>状态。</p>
<p>在此结构中，enqueue 和 dequeue 两个函数是整个 QoS 调度的入口函数。其中的<code>Qdisc_class_ops</code>用于对此 <code>Qdisc</code>的 filter list 进行操作，添加删除等，通过对 Qdisc 添加 fliter，filter 对 enqueue 到此 Qdisc 的 pkt 进行分类，从而归类到此 Qdisc 的子 class 中，而每个子 class 都有自己的 Qdisc 进行 pkt enqueue 的管理，因此实现一个树形的 filter 结构。</p>
<p>callgraph Qdisc 在从来自上层的<code>dev_queue_xmit</code>主动发送开始起作用，对出口数据包作限制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dev_queue_xmit -&gt;</span><br><span class="line">	__dev_queue_xmit -&gt;</span><br><span class="line">    	__dev_xmit_skb -&gt;</span><br><span class="line">    		qdisc-&gt;enqueue</span><br><span class="line">    		__qdisc_run -&gt;</span><br><span class="line">    		  qdisc_restart -&gt;</span><br><span class="line">    		    qdisc-&gt;dequeue -&gt;</span><br><span class="line">    		      sch_direct_xmit</span><br></pre></td></tr></table></figure>

<p>在<code>enqueue</code>的时候会主动唤起<code>dequeue</code>也可能是硬件发送就绪会唤醒发送软中断来<code>dequeue</code>，描述的整个过程大概是图中的这部分。</p>
<img data-src="/zh-CN/2017/05/19/cgroup-%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B9%8B-net-cls-%E5%92%8C-net-prio/qdisc.jpeg" class="">

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="netfilter"><a href="#netfilter" class="headerlink" title="netfilter"></a>netfilter</h3><p>netfilter 在数据包传输中有一些 hook 可以在其中注册回调函数。</p>
<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/37/Netfilter-packet-flow.svg/1600px-Netfilter-packet-flow.svg.png" alt="netfilter"></p>
<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>主要是四表五链，是 netfilter 的用户态工具。</p>
<p><a target="_blank" rel="noopener" href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture">deep dive</a></p>
<h2 id="cgroup-子系统-net-cls-Network-classifier-cgroup"><a href="#cgroup-子系统-net-cls-Network-classifier-cgroup" class="headerlink" title="cgroup 子系统 net_cls (Network classifier cgroup)"></a>cgroup 子系统 net_cls (Network classifier cgroup)</h2><p>net_cls 可以给 packet 打上 classid 的标签，用于过滤分类，有了上面的详细解释，这个 classid 的作用也非常明显了，就是用于标记<code>skb</code>所属的 qdisc class 的。</p>
<p>有了这个标签，流量控制器（tc）可以对不同的 cgroup 的 packet 起作用，Netfilter（iptables）也可以基于这个标签有对应的动作。创建一个 net_cls cgroup 对应的是创建一个 net_cls.classid 文件，这个文件初始化为 0。可以写 16 进制的 0xAAAABBBB 到这个文件里面，AAAA 是 major 号，BBBB 是 minor 号。读这个文件返回的是十进制的数字。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/net_cls</span><br><span class="line">mount -t cgroup -onet_cls net_cls /sys/fs/cgroup/net_cls</span><br><span class="line">mkdir /sys/fs/cgroup/net_cls/0</span><br><span class="line">echo 0x100001 &gt;  /sys/fs/cgroup/net_cls/0/net_cls.classid</span><br></pre></td></tr></table></figure>
<p>设置一个 10:1 handle.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/fs/cgroup/net_cls/0/net_cls.classid</span><br><span class="line">1048577</span><br></pre></td></tr></table></figure>

<p>配置  tc:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root handle 10: htb</span><br><span class="line">tc class add dev eth0 parent 10: classid 10:1 htb rate 40mbit</span><br></pre></td></tr></table></figure>

<p>创建 traffic class 10:1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc filter add dev eth0 parent 10: protocol ip prio 10 handle 1: cgroup</span><br></pre></td></tr></table></figure>
<p>配置 iptables，也可以用于这个 classid。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A OUTPUT -m cgroup ! --cgroup 0x100001 -j DROP</span><br></pre></td></tr></table></figure>
<p>对应的实现在<code>net/core/netclassid_cgroup.c</code>下面。起作用的方式是<code>css_cls_state</code>的<code>classid</code>并且<code>sock_cgroup_set_classid(&amp;sock-&gt;sk-&gt;sk_cgrp_data,(unsigned long)v)</code>来设置<code>sock</code>的<code>classid</code>。</p>
<h2 id="cgroup-net-prio-子系统"><a href="#cgroup-net-prio-子系统" class="headerlink" title="cgroup net_prio 子系统"></a>cgroup net_prio 子系统</h2><p>网络优先权（net_prio）子系统可以为各个 cgroup 中的应用程序动态配置每个网络接口的流量优先级。</p>
<p>net_prio.prioidx</p>
<p>只读文件。它包含一个特有整数值，kernel 使用该整数值作为这个 cgroup 的内部代表。</p>
<p>net_prio.ifpriomap</p>
<p>包含优先级图谱，这些优先级被分配给源于此群组进程的流量以及通过不同接口离开系统的流量。回顾<code>pfifo</code>里优先级映射，对应的就是这个值。该图用 <em><network_interface> <priority></em> 的形式以成对列表表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~]# cat /cgroup/net_prio/iscsi/net_prio.ifpriomap</span><br><span class="line">eth0 5</span><br><span class="line">eth1 4</span><br><span class="line">eth2 6</span><br></pre></td></tr></table></figure>

<p><code>net_prio.ifpriomap</code> 文件的目录可以使用上述格式，通过将字符串回显至文件的方式来修改。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~]# echo &quot;eth0 5&quot; &gt; /cgroup/net_prio/iscsi/net_prio.ifpriomap</span><br></pre></td></tr></table></figure>

<p>上述指令将强制设定任何源于 <code>iscsi</code> <code>net_prio</code> cgroup 进程的流量和 <code>eth0</code> 网络接口传出的流量的优先级为 <code>5</code>。父 cgroup 也有可写入的 <code>net_prio.ifpriomap</code> 文件，可以设定系统默认优先级。</p>
<p>对应的实现在<code>net/core/netprio_cgroup.c</code>下面。实现方式是通过扩展<code>dev-&gt;priomap</code>的<code>prioid-&gt;prio</code>的映射记录这个优先级和 cgroup 的关系。</p>
<p>net_prio 使用每个 cgroup 的 id（cgroupo-&gt;id）作为 sequence number，并将这个存储在 sk_cgrp_prioidx 中。sk_cgrp_prioidx 这个是单纯的用于设置网络包的优先级，使用这个之后将会覆盖之前通过 SO_PRIORITY socket 选项或者其他方式设置的值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/05/07/cgroups-%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E5%AD%98%E5%92%8CCPU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/05/07/cgroups-%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E5%AD%98%E5%92%8CCPU/" class="post-title-link" itemprop="url">cgroup 分析之CPU和内存部分</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-05-07 03:14:07" itemprop="dateCreated datePublished" datetime="2017-05-07T03:14:07+08:00">2017-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/05/07/cgroups-%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E5%AD%98%E5%92%8CCPU/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/05/07/cgroups-分析之内存和CPU/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="cgroup-的整体结构"><a href="#cgroup-的整体结构" class="headerlink" title="cgroup 的整体结构"></a>cgroup 的整体结构</h1><p>cgroup 是容器当中对资源进行限制的机制，完整的名称是叫 control group。经常提到的 hierarchy 对应的是一个层级，而subsystem 对应的是一个子系统，都是可以望文生意的。创建一个层级是通过挂载完成的，也就是说层级对应的是文件系统 root 目录的结构。</p>
<p>子系统目前有下列几种</p>
<ol>
<li> devices 设备权限</li>
<li> cpuset 分配指定的 CPU 和内存节点</li>
<li> cpu 控制 CPU 占用率</li>
<li> cpuacct 统计 CPU 使用情况</li>
<li> memory 限制内存的使用上限</li>
<li> freezer 暂停 Cgroup 中的进程</li>
<li> net_cls 配合 tc(traffic controller)限制网络带宽</li>
<li> net_prio 设置进程的网络流量优先级</li>
<li> huge_tlb 限制 HugeTLB 的使用</li>
<li> perf_event 允许 Perf 工具基于 Cgroup 分组做性能检测</li>
</ol>
<p>创建层级通过 <code>mount -t cgroup -o subsystems name /cgroup/name</code>，/cgroup/name 是用来挂载层级的目录(层级结构是通过挂载添加的)，-o 是子系统列表，比如 <code>-o cpu,cpuset,memory</code>，name 是层级的名称，一个层级可以包含多个子系统，如果要修改层级里的子系统重新 mount 即可。子系统和层级之间满足几个关系。</p>
<ol>
<li> 同一个 hierarchy 可以附加一个或多个 subsystem</li>
<li> 一个 subsystem 可以附加到多个 hierarchy，当且仅当这些 hierarchy 只有这唯一一个 subsystem</li>
<li> 系统每次新建一个 hierarchy 时，该系统上的所有 task 默认构成了这个新建的 hierarchy 的初始化 cgroup，这个 cgroup 也称为 root cgroup。对于你创建的每个 hierarchy，task 只能存在于其中一个 cgroup 中，即一个 task 不能存在于同一个 hierarchy 的不同 cgroup 中，但是一个 task 可以存在在不同 hierarchy 中的多个 cgroup 中。如果操作时把一个 task 添加到同一个 hierarchy 中的另一个 cgroup 中，则会从第一个 cgroup 中移除</li>
</ol>
<p><code>/proc/self</code> 对应的是当前进程的 proc 目录，比如当前进程 pid 是1，那么<code>/proc/1</code>和<code>/proc/self</code>是等价的。运行<code>man proc</code>可以看到<code>/proc/self/cgroup</code>的解释。</p>
<blockquote>
<p>/proc/[pid]/cgroup (since Linux 2.6.24)<br>       This file describes control groups to which the process/task belongs.  For each cgroup hierarchy there is one entry<br>containing colon-separated fields of the form:</p>
<pre><code>5:cpuacct,cpu,cpuset:/daemons
</code></pre>
<p>The colon-separated fields are, from left to right:</p>
<pre><code>1. hierarchy ID number

2. set of subsystems bound to the hierarchy

3. control group in the hierarchy to which the process belongs
</code></pre>
<p>This file is present only if the CONFIG_CGROUPS kernel configuration option is enabled.</p>
</blockquote>
<p>这个展示的是当前进程属于的 control groups, 每一行是一排 hierarchy，中间是子系统，最后是受控制的 cgroup，可以通过这个文件知道自己所属于的cgroup。</p>
<h1 id="cgroup-的创建"><a href="#cgroup-的创建" class="headerlink" title="cgroup 的创建"></a>cgroup 的创建</h1><p>创建一个独立的 cgroup 则是在层级结构下面创建一个目录。</p>
<p>先看一下创建目录做了什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static int cgroup_mkdir(struct inode *dir, struct dentry *dentry, int mode)</span><br><span class="line">&#123; </span><br><span class="line">        struct cgroup *c_parent = dentry-&gt;d_parent-&gt;d_fsdata;</span><br><span class="line">  </span><br><span class="line">        /* the vfs holds inode-&gt;i_mutex already */</span><br><span class="line">        return cgroup_create(c_parent, dentry, mode | S_IFDIR);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">static long cgroup_create(struct cgroup *parent, struct dentry *dentry,</span><br><span class="line">                             mode_t mode)</span><br><span class="line">&#123;</span><br><span class="line">	/* 获取父cgroup对应的层级hierarchy */</span><br><span class="line">	/* 这里叫做 cgroupfs 其实是匹配的，因为创建 hierachy 就是 mount 了一个文件系统的动作 */</span><br><span class="line">	struct cgroupfs_root *root = parent-&gt;root;</span><br><span class="line">	/* 初始化一个cgroup结构 cgrp */</span><br><span class="line">        init_cgroup_housekeeping(cgrp);</span><br><span class="line">        cgrp-&gt;parent = parent; /* 设置父 cgroup */</span><br><span class="line">        cgrp-&gt;root = parent-&gt;root; /* 继承 parent 的 hierachy */</span><br><span class="line">        cgrp-&gt;top_cgroup = parent-&gt;top_cgroup; /* 继承父 parent 对应 hierachy 的root cgroup */</span><br><span class="line">	/* 继承父 parent 的 notify_on_release 设置 */</span><br><span class="line">        if (notify_on_release(parent))</span><br><span class="line">                set_bit(CGRP_NOTIFY_ON_RELEASE, &amp;cgrp-&gt;flags);</span><br><span class="line">	/* 对所属的hierachy的子系统进行初始化 */</span><br><span class="line">        for_each_subsys(root, ss) &#123;</span><br><span class="line">                struct cgroup_subsys_state *css = ss-&gt;create(ss, cgrp);</span><br><span class="line">                if (IS_ERR(css)) &#123;</span><br><span class="line">                        err = PTR_ERR(css);</span><br><span class="line">                        goto err_destroy;</span><br><span class="line">                &#125;</span><br><span class="line">                init_cgroup_css(css, ss, cgrp);</span><br><span class="line">                if (ss-&gt;use_id)</span><br><span class="line">                        if (alloc_css_id(ss, parent, cgrp))</span><br><span class="line">                                goto err_destroy;</span><br><span class="line">                /* At error, -&gt;destroy() callback has to free assigned ID. */</span><br><span class="line">        &#125;</span><br><span class="line">	/* 加入到父 cgroup 的子列表里 */</span><br><span class="line">        cgroup_lock_hierarchy(root);</span><br><span class="line">        list_add(&amp;cgrp-&gt;sibling, &amp;cgrp-&gt;parent-&gt;children);</span><br><span class="line">        cgroup_unlock_hierarchy(root);</span><br><span class="line">	/* 创建 cgroup 目录 */</span><br><span class="line">	cgroup_create_dir(cgrp, dentry, mode);</span><br><span class="line">	/* 创建目录下对应的文件,比如common的部分(tasks),或者子系统的部分(cpu.shares,freezer.state)*/</span><br><span class="line">        cgroup_populate_dir(cgrp);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下 <code>cgroup_subsys_state-&gt;create</code> 的实现，举个例子比如<code>kernel/cpuset.c</code>的<code>cpuset</code>子系统的创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static struct cgroup_subsys_state *cpuset_create(</span><br><span class="line">        struct cgroup_subsys *ss,</span><br><span class="line">        struct cgroup *cont)</span><br><span class="line">&#123;</span><br><span class="line">        struct cpuset *cs;</span><br><span class="line">        struct cpuset *parent;</span><br><span class="line"></span><br><span class="line">        if (!cont-&gt;parent) &#123;</span><br><span class="line">                return &amp;top_cpuset.css;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = cgroup_cs(cont-&gt;parent);</span><br><span class="line">        cs = kmalloc(sizeof(*cs), GFP_KERNEL);</span><br><span class="line">        if (!cs)</span><br><span class="line">                return ERR_PTR(-ENOMEM);</span><br><span class="line">        if (!alloc_cpumask_var(&amp;cs-&gt;cpus_allowed, GFP_KERNEL)) &#123;</span><br><span class="line">                kfree(cs);</span><br><span class="line">                return ERR_PTR(-ENOMEM);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cs-&gt;flags = 0;</span><br><span class="line">        if (is_spread_page(parent))</span><br><span class="line">                set_bit(CS_SPREAD_PAGE, &amp;cs-&gt;flags);</span><br><span class="line">        if (is_spread_slab(parent))</span><br><span class="line">                set_bit(CS_SPREAD_SLAB, &amp;cs-&gt;flags);</span><br><span class="line">        set_bit(CS_SCHED_LOAD_BALANCE, &amp;cs-&gt;flags);</span><br><span class="line">        cpumask_clear(cs-&gt;cpus_allowed);</span><br><span class="line">        nodes_clear(cs-&gt;mems_allowed);</span><br><span class="line">        fmeter_init(&amp;cs-&gt;fmeter);</span><br><span class="line">        cs-&gt;relax_domain_level = -1;</span><br><span class="line"></span><br><span class="line">        cs-&gt;parent = parent;</span><br><span class="line">        number_of_cpusets++;</span><br><span class="line">        return &amp;cs-&gt;css ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是一系列 cgroup 初始化动作，填充目录的部分作为接口留给子系统实现。</p>
<p>总结一下:</p>
<p>hierarchy 对应的是 cgroup 的一个根，拥有一个<code>top_cgroup</code>，之后 hierarchy 下面的目录(cgroup)都是继承这些内容。</p>
<p>真正起作用的入口其实是对文件的读写操作，关于这一块VFS的内容可以看一下我之前的<a href="https://ggaaooppeenngg.github.io/zh-CN/2015/12/22/VFS-%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84/">博客</a>，这也是由子系统实现的，接下来看看子系统的实现。</p>
<h1 id="freezer-子系统"><a href="#freezer-子系统" class="headerlink" title="freezer 子系统"></a>freezer 子系统</h1><p>freeze tasks 的相关内容可以在内核<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/power/freezing-of-tasks.txt">文档</a>当中找到，简单来说是为了提供一种机制能够让进程挂起。这些函数在电源控制里面有很多用到的地方，比如我们常说的挂起，就是让所有进程进入冬眠状态。</p>
<p>首先看这个子系统是因为它比较简单，属性比较少，实现的代码也比较少。</p>
<p>这里铺垫一些知识，说明内核是如何睡眠和唤醒进程的。<br>一般内核进程进入睡眠需要进入<code>wait_queue</code>，然后调用 schedule。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* wait 是我们想要让 task 睡眠的 queue entry, q 是等待队列 */</span><br><span class="line">DEFINE_WAIT(wait);</span><br><span class="line">/* 添加到等待队列中 */</span><br><span class="line">add_wait_queue(q, &amp;wait);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 这里要检查condition是因为可能在唤醒之后这个condition的条件又不成立了,</span><br><span class="line"> * 这个和条件变量一样,即使条件满足被wake up了,也可能被其他进程修改了该条件.</span><br><span class="line"> */</span><br><span class="line">while (!condition) &#123;</span><br><span class="line">	prepare_to_wait(&amp;q, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">	if (signal_pending(current))</span><br><span class="line">		/* 处理信号 */</span><br><span class="line">	/* 进行调度 */</span><br><span class="line">	schedule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finish_wait(&amp;g, &amp;wait);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内核当中进入睡眠都是这个模板，这里的 schedule，会触发调度器遍历 scheduler class，选择优先级最高的调度类。<br>一般就是CFS(Complete Fair Scheduler)，接下来会进行 context 切换，注意不是像一般理解的那样，函数调用增长栈空间,而是把栈和寄存器都换掉，刷掉缓存等等，由此进入另外一个进程的上下文。直到被唤醒从恢复保存的 IP 重新开始执行。</p>
<p>唤醒的过程则是，调用<code>wake_up()</code>函数把 task 的状态重新设置为 <code>TASK_RUNNING</code>，并且把task从等待队列移除。<br>它会使用 <code>enqueue_task()</code> 把任务从新加入到调度器中。如果是 CFS 调度器的话就是加入到红黑树中，当<code>need_resched</code>设置了的话会显式调用调用<code>schedule()</code>调度，不然还会继续执行唤醒者的上下文。</p>
<p>然后说一下<em>Freezing of tasks</em>，就是通过发送信号唤醒用户态的进程和内核进程，所有这些进程需要响应这个信号并且最后调用 <code>refrigerator()</code> 进入睡眠，也就上面的那个循环。<br>下图是进入冬眠进程的过程.</p>
<img data-src="/zh-CN/2017/05/07/cgroups-%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E5%AD%98%E5%92%8CCPU/refrigerator.png" class="">

<p>“冰箱”这个函数名称很形象，就是把当前 task 丢入睡眠状态直到解封。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* Refrigerator is place where frozen processes are stored :-). */</span><br><span class="line">void refrigerator(void)        </span><br><span class="line">&#123;</span><br><span class="line">        /* Hmm, should we be allowed to suspend when there are realtime</span><br><span class="line">           processes around? */</span><br><span class="line">        long save;             </span><br><span class="line"></span><br><span class="line">        task_lock(current);    </span><br><span class="line">        if (freezing(current)) &#123;        </span><br><span class="line">                frozen_process();               </span><br><span class="line">                task_unlock(current);           </span><br><span class="line">        &#125; else &#123;               </span><br><span class="line">                task_unlock(current);           </span><br><span class="line">                return;        </span><br><span class="line">        &#125;</span><br><span class="line">        save = current-&gt;state; </span><br><span class="line">        pr_debug(&quot;%s entered refrigerator\n&quot;, current-&gt;comm);</span><br><span class="line">  </span><br><span class="line">        spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">        recalc_sigpending(); /* We sent fake signal, clean it up */</span><br><span class="line">        spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">  </span><br><span class="line">        /* prevent accounting of that task to load */</span><br><span class="line">        current-&gt;flags |= PF_FREEZING;  </span><br><span class="line">  </span><br><span class="line">        for (;;) &#123;             </span><br><span class="line">                set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">                if (!frozen(current))           </span><br><span class="line">                        break; </span><br><span class="line">                schedule();    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Remove the accounting blocker */</span><br><span class="line">        current-&gt;flags &amp;= ~PF_FREEZING;</span><br><span class="line"></span><br><span class="line">        pr_debug(&quot;%s left refrigerator\n&quot;, current-&gt;comm);</span><br><span class="line">        __set_current_state(save);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以 freezer subsystem 干的事情就是这样一件事情，把 cgroup 中的进程进行挂起和恢复。现在具体看一下实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum freezer_state &#123;           </span><br><span class="line">        CGROUP_THAWED = 0,     </span><br><span class="line">        CGROUP_FREEZING,       </span><br><span class="line">        CGROUP_FROZEN,         </span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">struct freezer &#123;               </span><br><span class="line">        struct cgroup_subsys_state css; </span><br><span class="line">        enum freezer_state state;       </span><br><span class="line">        spinlock_t lock; /* protects _writes_ to state */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>freezer 有三种状态，THAWED，FREEZING，FROZEN，分别代表正常状态，停止中和停止。</p>
<p>freezer 对应的文件有<code>state</code>,<code>cftype</code>是对vfs的file结构的一个封装，最后加上子系统的name，文件名对应的就是”freezer.state”。<br>对<code>freezer.state</code>更改文件内容的操作就可以更改cgroup当中task的挂起和恢复.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 文件的读写函数 */</span><br><span class="line">static struct cftype files[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;state&quot;, </span><br><span class="line">                .read_seq_string = freezer_read,</span><br><span class="line">                .write_string = freezer_write,  </span><br><span class="line">        &#125;,                     </span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">/* 添加子系统文件到cgroup目录中 */</span><br><span class="line">static int freezer_populate(struct cgroup_subsys *ss, struct cgroup *cgroup)</span><br><span class="line">&#123; </span><br><span class="line">        if (!cgroup-&gt;parent)   </span><br><span class="line">                return 0;      </span><br><span class="line">        return cgroup_add_files(cgroup, ss, files, ARRAY_SIZE(files));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>首先看一下<code>freezer_read</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static int freezer_read(struct cgroup *cgroup, struct cftype *cft,</span><br><span class="line">                        struct seq_file *m)</span><br><span class="line">&#123;</span><br><span class="line">        struct freezer *freezer;</span><br><span class="line">        enum freezer_state state;</span><br><span class="line"></span><br><span class="line">        if (!cgroup_lock_live_group(cgroup))</span><br><span class="line">                return -ENODEV;</span><br><span class="line"></span><br><span class="line">        freezer = cgroup_freezer(cgroup);</span><br><span class="line">        spin_lock_irq(&amp;freezer-&gt;lock);</span><br><span class="line">        state = freezer-&gt;state;</span><br><span class="line">        if (state == CGROUP_FREEZING) &#123;</span><br><span class="line">                /* We change from FREEZING to FROZEN lazily if the cgroup was</span><br><span class="line">                 * only partially frozen when we exitted write. */</span><br><span class="line">                update_freezer_state(cgroup, freezer);</span><br><span class="line">                state = freezer-&gt;state;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock_irq(&amp;freezer-&gt;lock);</span><br><span class="line">        cgroup_unlock();</span><br><span class="line"></span><br><span class="line">        seq_puts(m, freezer_state_strs[state]);</span><br><span class="line">        seq_putc(m, &#x27;\n&#x27;);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>整个函数就是把 freezer 的 state 转换成字符换然后读取出来。</p>
<p>再看下 <code>freezer_write</code> 是如何改变进程状态的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int freezer_write(struct cgroup *cgroup,</span><br><span class="line">                         struct cftype *cft,             </span><br><span class="line">                         const char *buffer)             </span><br><span class="line">&#123; </span><br><span class="line">        int retval;            </span><br><span class="line">        enum freezer_state goal_state;  </span><br><span class="line">  </span><br><span class="line">        if (strcmp(buffer, freezer_state_strs[CGROUP_THAWED]) == 0)</span><br><span class="line">                goal_state = CGROUP_THAWED;     </span><br><span class="line">        else if (strcmp(buffer, freezer_state_strs[CGROUP_FROZEN]) == 0)</span><br><span class="line">                goal_state = CGROUP_FROZEN;     </span><br><span class="line">        else                   </span><br><span class="line">                return -EINVAL;</span><br><span class="line">  </span><br><span class="line">        if (!cgroup_lock_live_group(cgroup))</span><br><span class="line">                return -ENODEV;</span><br><span class="line">        retval = freezer_change_state(cgroup, goal_state);</span><br><span class="line">        cgroup_unlock();       </span><br><span class="line">        return retval;         </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>其实只是把写入的字符串转换成对应的枚举类型，然后调用<code>freezer_change_state(cgroup, goal_state)</code>;</p>
<p>为了不贴过多的代码，这里略写，其实是根据类型不同进行调用了<code>unfreeze_cgroup</code>和<code>try_to_freeze_cgroup</code>。</p>
<p><code>try_to_freeze_cgroup</code> 遍历每个task执行freeze操作，而unfreeze也是类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int try_to_freeze_cgroup(struct cgroup *cgroup, struct freezer *freezer)</span><br><span class="line">&#123;</span><br><span class="line">        struct cgroup_iter it;</span><br><span class="line">        struct task_struct *task;</span><br><span class="line">        unsigned int num_cant_freeze_now = 0;</span><br><span class="line"></span><br><span class="line">        freezer-&gt;state = CGROUP_FREEZING;</span><br><span class="line">        cgroup_iter_start(cgroup, &amp;it);</span><br><span class="line">        while ((task = cgroup_iter_next(cgroup, &amp;it))) &#123;</span><br><span class="line">		/* 尝试freeze task */</span><br><span class="line">                if (!freeze_task(task, true))</span><br><span class="line">                        continue;</span><br><span class="line">                if (is_task_frozen_enough(task))</span><br><span class="line">                        continue;</span><br><span class="line">                if (!freezing(task) &amp;&amp; !freezer_should_skip(task))</span><br><span class="line">                        num_cant_freeze_now++;</span><br><span class="line">        &#125;</span><br><span class="line">        cgroup_iter_end(cgroup, &amp;it);</span><br><span class="line"></span><br><span class="line">        return num_cant_freeze_now ? -EBUSY : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，这里我们看最后的freeze和unfreeze某个task的动作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">bool freeze_task(struct task_struct *p, bool sig_only)</span><br><span class="line">&#123;</span><br><span class="line">        /*</span><br><span class="line">         * We first check if the task is freezing and next if it has already</span><br><span class="line">         * been frozen to avoid the race with frozen_process() which first marks</span><br><span class="line">         * the task as frozen and next clears its TIF_FREEZE.</span><br><span class="line">         */</span><br><span class="line">        if (!freezing(p)) &#123;</span><br><span class="line">                rmb();</span><br><span class="line">		/* 如果frozen标记了</span><br><span class="line">		 * 说明已经冻结,就返回失败</span><br><span class="line">		 */</span><br><span class="line">                if (frozen(p))</span><br><span class="line">                        return false;</span><br><span class="line"></span><br><span class="line">                if (!sig_only || should_send_signal(p))</span><br><span class="line">                        set_freeze_flag(p);</span><br><span class="line">                else</span><br><span class="line">                        return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (should_send_signal(p)) &#123;</span><br><span class="line">                if (!signal_pending(p))</span><br><span class="line">                        fake_signal_wake_up(p);</span><br><span class="line">        &#125; else if (sig_only) &#123;</span><br><span class="line">                return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                wake_up_state(p, TASK_INTERRUPTIBLE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>停止的方式就是通过标记 <code>freeze_flag</code>，然后通过发送信号或者唤醒 task 来处理<code>TIF_FREEZE</code>标记(取决于是否设置了<code>PF_FREEZER_NOSIG</code>)。<br>最后又回到了之前给的那张流程图，等处理函数运行又会<code>try_to_freeze()</code>检查信号或者标志位，然后进入冰箱，而唤醒的方式则是反过来，把标记清除并且<code>wake_up</code>进程即可。</p>
<h1 id="cpu-子系统"><a href="#cpu-子系统" class="headerlink" title="cpu 子系统"></a>cpu 子系统</h1><p>cpu子系统是对CPU时间配额进行限制的子系统，属性在这里列举一下</p>
<ul>
<li>  cpu.cfs_period_us 完全公平调度器的调整时间配额的周期</li>
<li>  cpu.cfs_quota_us 完全公平调度器的周期当中可以占用的时间</li>
<li>cpu.stat 统计值<ul>
<li>  nr_periods 进入周期的次数</li>
<li>  nr_throttled 运行时间被调整的次数</li>
<li>  throttled_time 用于调整的时间</li>
</ul>
</li>
<li>  cpu.share cgroup中cpu的分配，如果a group是100，b group是300，那么a就会获得\(\frac{1}{4}\)，b就会获得\(\frac{3}{4}\)的CPU。</li>
</ul>
<h2 id="CFS-调度器"><a href="#CFS-调度器" class="headerlink" title="CFS 调度器"></a>CFS 调度器</h2><p>接下来看一下对于 CPU 的限制是如何做到的，这要补充一下 CFS(完全公平调度器) 的<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt">相关的内容</a>。</p>
<p>CFS 保证进程之间完全公平获得 CPU 的份额，和我们传统的操作系统的时间片的理念不同，CFS 计算进程的 vruntime (其实就是总时间中的比例，并且带上进程优先级作为权重)，来选择需要调度的下一个进程。用户态暴露的权重就是nice值，这个值越高权重就会低，反之亦然。(坊间的解释是 nice 的意思就是我对别的进程很 nice ，所以让别的进程多运行一会儿，自己少运行一会儿)。</p>
<p>CFS主要有几点，时间计算，进程选择，调度入口。</p>
<h3 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h3><p>先看下面这句话</p>
<blockquote>
<p>Linux is a multi-user operating system. Consider a scenario where user A spawns ten tasks and user B spawns five. Using the above approach, every task would get ~7% of the available CPU time within a scheduling period. So user A gets 67% and user B gets 33% of the CPU time during their runs. Clearly, if user A continues to spawn more tasks, he can starve user B of even more CPU time. To address this problem, the concept of “group scheduling” was introduced in the scheduler, where, instead of dividing the CPU time among tasks, it is divided among groups of tasks.</p>
</blockquote>
<p>总结来说 CPU 的时间并不是分给独立的 <code>task</code> 的，而是分给 <code>task_group</code> 的，这样防止用户 A 的进程数远远大于 B 而导致 B 饥饿的<a target="_blank" rel="noopener" href="https://lwn.net/Articles/639543/">情况</a>。这一组task通过 <code>sched_entity</code> 来表示。能够导致进程分组的方式一种是把进程划入一个cgroup，一种是通过<code>set_sid()</code>系统调用的新session中创建的进程会自动分组，这需要<code>CONFIG_SCHED_AUTOGROUP</code>编译选项开启。</p>
<p>调度的粒度是以<code>sched_entity</code>为粒度的,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct sched_entity &#123;</span><br><span class="line">        struct load_weight      load;           /* for load-balancing */</span><br><span class="line">        struct rb_node          run_node;</span><br><span class="line">        struct list_head        group_node;</span><br><span class="line">        unsigned int            on_rq;</span><br><span class="line"></span><br><span class="line">        u64                     exec_start;</span><br><span class="line">        u64                     sum_exec_runtime;</span><br><span class="line">        u64                     vruntime;</span><br><span class="line">        u64                     prev_sum_exec_runtime;</span><br><span class="line"></span><br><span class="line">        u64                     nr_migrations;</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_FAIR_GROUP_SCHED)</span><br><span class="line">        /* Per-entity load-tracking */</span><br><span class="line">        struct sched_avg        avg;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_SCHEDSTATS       </span><br><span class="line">        struct sched_statistics statistics;</span><br><span class="line">#endif                         </span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_FAIR_GROUP_SCHED </span><br><span class="line">        struct sched_entity     *parent;</span><br><span class="line">        /* rq on which this entity is (to be) queued: */</span><br><span class="line">        struct cfs_rq           *cfs_rq;</span><br><span class="line">        /* rq &quot;owned&quot; by this entity/group: */</span><br><span class="line">        struct cfs_rq           *my_q;  </span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个调度实体都有两个<code>cfs_rq</code>结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   struct cfs_rq &#123;</span><br><span class="line">struct load_weight load;</span><br><span class="line">unsigned long runnable_load_avg;</span><br><span class="line">unsigned long blocked_load_avg;</span><br><span class="line">unsigned long tg_load_contrib;</span><br><span class="line">/* ... */</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Each scheduling entity may, in turn, be queued on a parent scheduling entity’s run queue. At the lowest level of this hierarchy, the scheduling entity is a task; the scheduler traverses this hierarchy until the end when it has to pick a task to run on the CPU.</p>
</blockquote>
<p>最底层的调度实体就是进程，而每个调度实体还会有两个<code>cfs_rq</code>，一个是<code>cfs_rq</code>另一个是<code>my_q</code>，前者是当前调度实体从属的rq，后者他自己的rq，所有的子调度实体都在这个rq上，从而构成了树形结构。可以通过<code>cfs_rq</code>遍历调度实体，而把自己的时间平分给<code>my_q</code>的调度实体.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   struct task_group &#123;</span><br><span class="line">struct sched_entity **se;</span><br><span class="line">struct cfs_rq **cfs_rq;</span><br><span class="line">unsigned long shares;</span><br><span class="line">atomic_long_t load_avg;</span><br><span class="line">/* ... */</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tasks belonging to a group can be scheduled on any CPU. Therefore it is not sufficient for a group to have a single scheduling entity; instead, every group must have one scheduling entity for each CPU. Tasks belonging to a group must move between the run queues in these per-CPU scheduling entities only, so that the footprint of the task is associated with the group even during task migrations.</p>
</blockquote>
<p>单独的<code>sched_entity</code>为了适应SMP结构，又引入了<code>task_group</code>结构，包含了数组，分别属于某个CPU，对于一个进程想要从CPU1迁移到CPU2，只要把进程从<code>tg-&gt;cfs_rq[0]</code>转移到<code>tg-&gt;cfs_rq[1]</code>即可，一种 percpu 的结构。</p>
<p>优先级有一个映射表，表示调度占的权重，一般nice值为0的时候，大家都是1024，但是nice值为1的时候，权重就会降低到820，对于所有1024权重的进程，就会享有更少的时间，这个映射体现的是每提升一个等级，相差值大约为10%。</p>
<p>下面是 nice 值到权重的映射，这是内核普通进程的优先级范围(100-139)，内核拥有140个优先级。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static const int prio_to_weight[40] = &#123;</span><br><span class="line"> /* -20 */     88761,     71755,     56483,     46273,     36291,</span><br><span class="line"> /* -15 */     29154,     23254,     18705,     14949,     11916,</span><br><span class="line"> /* -10 */      9548,      7620,      6100,      4904,      3906,</span><br><span class="line"> /*  -5 */      3121,      2501,      1991,      1586,      1277,</span><br><span class="line"> /*   0 */      1024,       820,       655,       526,       423,</span><br><span class="line"> /*   5 */       335,       272,       215,       172,       137,</span><br><span class="line"> /*  10 */       110,        87,        70,        56,        45,</span><br><span class="line"> /*  15 */        36,        29,        23,        18,        15,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调度实体中包含了一个结构就是表示这个权重的值，表示进程占的权重。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   struct load_weight &#123;</span><br><span class="line">unsigned long weight;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>最后 <code>time_slice = (sched_period() * se.load.weight) / cfs_rq.load.weight;</code> 就是 se 运行时应该分配到的 CPU 时间的份额(<code>sched_period</code>是<code>cfs.nr_running</code>调度最小粒度时间，理想要每个进程都能运行一次)。</p>
<p>另外，用于衡量CPU负载的方式是通过<code>sched_entity</code>中的<code>sched_avg</code>结构，这个结构用于记录负载情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sched_avg &#123;</span><br><span class="line">u32 runnable_sum, runnable_avg_period;</span><br><span class="line">unsigned long load_avg_contrib;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当<code>sched_entity</code>是一个进程的时候，计算公式是<code>sa.load_avg_contrib = (sa.runnable_sum * se.load.weight) / sa.runnable_period;</code>(<code>se</code>是<code>sched_entity</code>，<code>sa</code>是<code>sched_avg</code>)，<code>runnbale_sum</code> 是处于 <code>RUNNING</code> 状态的时间，<code>runnable_period</code> 表示可以变成运行状态的时间段。<code>runnable_load_avg</code> 是<code>cfs_rq</code>中用于统计所有<code>se</code>的<code>load</code>的合，以此来表示CPU负载。<code>blocked_load_avg</code> 是相应的进程处于阻塞状态的负载。</p>
<p>当<code>sched_entity</code>是一组进程的时候，计算方式是，<br>首先提取<code>task group</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tg = cfs_rq-&gt;tg;</span><br></pre></td></tr></table></figure>
<p>之前已经统计了队列中的所有<code>se</code>的总和<code>runnable_load_avg</code>，然后全部累加到<code>tg</code>中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfs_rq-&gt;tg_load_contrib = cfs_rq-&gt;runnable_load_avg + cfs_rq-&gt;blocked_load_avg;</span><br><span class="line">    tg-&gt;load_avg += cfs_rq-&gt;tg_load_contrib;</span><br></pre></td></tr></table></figure>

<p>最后<code>se</code>的值是通过在<code>tg</code>中的比重得到的，这里的<code>tg-&gt;shares</code>是最大允许的负载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">se-&gt;avg.load_avg_contrib =</span><br><span class="line"> (cfs_rq-&gt;tg_load_contrib * tg-&gt;shares / tg-&gt;load_avg);</span><br></pre></td></tr></table></figure>



<h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h3><p>完全公平调度器的进程选择其实很简单，通过调用<code>pick_next_entity()</code>每次选择 vruntime 最小的进程进行运行。装载进程的结构选择的是红黑树，并且最左下角的结点是个特殊的节点，被保存起来，这样防止每次都从 root 一直搜索到最左下角，每次选择进程的时候直接选择该节点即可。</p>
<p>每次 vruntime 会在时钟中断和任何进程运行状态发生改变的时候进行计算，方式是通过权重调整得到一个 delta 值然后加到 vruntime 上面。<br>公式是<code>vruntime += delta_exec * (NICE_0_LOAD/curr-&gt;load.weight);</code>。这里的 weight 取决于 shares 值和负载等等因素的综合结果。</p>
<p>通过<code>enqueue_entity()</code>可以把进程加入到红黑树当中，当进程被唤醒的时候，或者第一次调用<code>fork</code>的时候就会被调用这个函数。具体就是更新了统计数据，并且把调度节点插入到红黑树当中。如果正好插入到了最右下角，那么就能马上被运行了。</p>
<p>通过<code>dequeue_entity()</code>可以把调度结点从红黑树中删除，这是进程在阻塞或者终止的时候会被调用的函数，具体就是把调度节点移除红黑树并且调整红黑树。</p>
<h3 id="调度入口"><a href="#调度入口" class="headerlink" title="调度入口"></a>调度入口</h3><p>内核的调度入口就是<code>schedule()</code>，遍历所有的调度类(因为内核中调度器的实现不只一种)，选择权重最高的调度类并且进行进程选择，然后执行该进程。</p>
<p>这里列举一下所有抢占可能发生的时机</p>
<ol>
<li>用户态进程:<ul>
<li>  从系统调用返回</li>
<li>  从中断返回</li>
</ul>
</li>
<li>内核态进程:<ul>
<li>  从中断返回内核态</li>
<li>  进程主动调用<code>schedule()</code></li>
<li>  进程变为可抢占状态(没有持有锁,其实还是中断驱动的)</li>
<li>  进程阻塞(最后还是调用schedule)</li>
</ul>
</li>
</ol>
<h1 id="具体看-cgroup-的-cpu-子系统"><a href="#具体看-cgroup-的-cpu-子系统" class="headerlink" title="具体看 cgroup 的 cpu 子系统"></a>具体看 cgroup 的 cpu 子系统</h1><p>补充完调度器的知识，再回来看 cgroup 是如何对进程做运行时间限制的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static struct cftype cpu_files[] = &#123;</span><br><span class="line">#ifdef CONFIG_FAIR_GROUP_SCHED</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;shares&quot;,</span><br><span class="line">                .read_u64 = cpu_shares_read_u64,</span><br><span class="line">                .write_u64 = cpu_shares_write_u64,</span><br><span class="line">        &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CFS_BANDWIDTH</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;cfs_quota_us&quot;,</span><br><span class="line">                .read_s64 = cpu_cfs_quota_read_s64,</span><br><span class="line">                .write_s64 = cpu_cfs_quota_write_s64,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;cfs_period_us&quot;,</span><br><span class="line">                .read_u64 = cpu_cfs_period_read_u64,</span><br><span class="line">                .write_u64 = cpu_cfs_period_write_u64,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;stat&quot;,</span><br><span class="line">                .read_map = cpu_stats_show,</span><br><span class="line">        &#125;,</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cpu 子系统也是用对文件进行读写的接口，其实就是获取了 cgroup 的 subsystem 的从属的 <code>task_group</code>，并且读取或者设置了 <code>quota_us</code> 和 <code>period_write</code> 以及 <code>shares</code> 属性。具体这些属性应用的地方在调度器内部。<code>task_group</code>是一个管理组调度的结构。</p>
<p>因为内嵌了一个<code>cgroup_subsys_state</code>，这样cgroup就能通过自己的<code>css</code>成员反找到这个<code>task_group</code>。</p>
<p>看一下<code>cpu_shares_write_u64</code>的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpu_shares_write_u64 实际调用的是</span><br><span class="line">	-&gt; sched_group_set_shares(cgroup_tg(cgrp), scale_load(shareval))</span><br><span class="line">		-&gt; update_cfs_shares 获取 cgroup 的task group结构，调整权重</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void update_cfs_shares(struct cfs_rq *cfs_rq)</span><br><span class="line">&#123;</span><br><span class="line">        struct task_group *tg;</span><br><span class="line">        struct sched_entity *se;</span><br><span class="line">        long shares;</span><br><span class="line"></span><br><span class="line">        tg = cfs_rq-&gt;tg;</span><br><span class="line">        se = tg-&gt;se[cpu_of(rq_of(cfs_rq))];</span><br><span class="line">        if (!se || throttled_hierarchy(cfs_rq))</span><br><span class="line">                return;</span><br><span class="line">#ifndef CONFIG_SMP</span><br><span class="line">        if (likely(se-&gt;load.weight == tg-&gt;shares))</span><br><span class="line">                return;</span><br><span class="line">#endif</span><br><span class="line">        /* 根据tg-&gt;shares 和 rq 的负载计算出新的权重 */</span><br><span class="line">        shares = calc_cfs_shares(cfs_rq, tg);</span><br><span class="line">	</span><br><span class="line">        reweight_entity(cfs_rq_of(se), se, shares);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后一步 <code>reweight_entity</code> 就是调整<code>se-&gt;load.weight</code>的权重，从这里来保证<code>shares</code>能够调整进程可以获得的运行时间。当然除了这里，任何发生调度的地方都会有这样的行为，只不过我们主动修改了<code>shares</code>的值。</p>
<p>下图表示了展示了<code>shares</code>在<code>task group</code>中的作用。</p>
<img data-src="/zh-CN/2017/05/07/cgroups-%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E5%AD%98%E5%92%8CCPU/shares_hierarchy.png" class="">

<p>对于<code>cpu.cfs_period_us</code>和<code>cpu.cfs_quota_us</code>，是关于<code>CPU bandwith</code>的内容，论文<a href="https://ggaaooppeenngg.github.io/zh-CN/2015/12/22/VFS-%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84/">CPU bandwidth control for CFS</a>详细描述了其中的设计。论文中举例提到，shares 值只是使得CPU 的时间能够平均分配，但是实际运行时间可能会有变化，不能限制一个进程运行的上限。</p>
<p>在调度实体<code>sched_entity</code>中内嵌了一个结构体:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct cfs_bandwidth &#123;</span><br><span class="line">#ifdef CONFIG_CFS_BANDWIDTH</span><br><span class="line">        raw_spinlock_t lock;</span><br><span class="line">        ktime_t period;</span><br><span class="line">        /* quota 是被赋予的时间，runtime 是实际运行的时间 */</span><br><span class="line">        u64 quota, runtime;</span><br><span class="line">        s64 hierarchal_quota;</span><br><span class="line">        /* 到期时间 */ </span><br><span class="line">        u64 runtime_expires;</span><br><span class="line">  </span><br><span class="line">        int idle, timer_active;</span><br><span class="line">        struct hrtimer period_timer, slack_timer;</span><br><span class="line">        struct list_head throttled_cfs_rq;</span><br><span class="line"></span><br><span class="line">        /* statistics */</span><br><span class="line">        int nr_periods, nr_throttled;   </span><br><span class="line">        u64 throttled_time;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在每次调度的时候(无论是时间中断还是其他调度时间导致 enqueue 或者 dequeue)，都会调用<code>account_cfs_rq_runtime()</code>,runtime 相当于实际使用的 quota , 在论文里说的是<code>account_cfs_rq_quota()</code>，对占用时间更新，计算剩余可以运行的时间，如果不够，则进行限制，标记为不可调度。其中内含一个高精度定时器<code>period_timer</code>定时扫描进程，把限制的进程解除，并给予更多的bandwidth以继续运行，period就是计时器的周期，每次都会更新可运行的时间。注意这里用的时间是真实时间.</p>
<p>另外，<code>cpu.stat</code> 主要是控制过程中的统计信息，是只读属性，比如被限制了多少次等等，具体的代码分析就直接略过。</p>
<h1 id="cpuacct-子系统"><a href="#cpuacct-子系统" class="headerlink" title="cpuacct 子系统"></a>cpuacct 子系统</h1><p>cpuacct 比较简单，因为主要是一些统计信息</p>
<ul>
<li>  cpuacct.stat cgroup 及子消耗在用户态和内核态的CPU循环次数</li>
<li>  cpuacct.usage cgroup 消耗的CPU总时间</li>
<li>  cpuacct.usage_percpu cgroup在每个CPU上消耗的总时间</li>
</ul>
<p>在<code>kernel/sched/cpuacct.c</code>下有具体实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* track cpu usage of a group of tasks and its child groups */</span><br><span class="line">struct cpuacct &#123;</span><br><span class="line">        struct cgroup_subsys_state css;</span><br><span class="line">        /* cpuusage holds pointer to a u64-type object on every cpu */</span><br><span class="line">        u64 __percpu *cpuusage;</span><br><span class="line">        struct kernel_cpustat __percpu *cpustat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中定义了<a target="_blank" rel="noopener" href="http://www.makelinux.net/ldd3/chp-8-sect-5">per-cpu</a>结构，让每个CPU都独占了一个用于统计的值，算是CPU的私有变量。</p>
<p>接口如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static struct cftype files[] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;usage&quot;,</span><br><span class="line">                .read_u64 = cpuusage_read,</span><br><span class="line">                .write_u64 = cpuusage_write,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;usage_percpu&quot;,</span><br><span class="line">                .read_seq_string = cpuacct_percpu_seq_read,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .name = &quot;stat&quot;,</span><br><span class="line">                .read_map = cpuacct_stats_show,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; &#125;     /* terminate */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次调度<code>update_curr</code>，都会调用<code>cpuacct_charge</code>更新<code>cpuacct</code>中的值，作为统计数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * charge this task&#x27;s execution time to its accounting group.</span><br><span class="line"> *</span><br><span class="line"> * called with rq-&gt;lock held.</span><br><span class="line"> */</span><br><span class="line">void cpuacct_charge(struct task_struct *tsk, u64 cputime)</span><br><span class="line">&#123;</span><br><span class="line">        struct cpuacct *ca;</span><br><span class="line">        int cpu;</span><br><span class="line">        /* 获取当前task属于的cpu */</span><br><span class="line">        cpu = task_cpu(tsk);</span><br><span class="line"></span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        /* task的cpuacct结构 */</span><br><span class="line">        ca = task_ca(tsk);</span><br><span class="line">        /* 所有父节点的值都应该相应变化</span><br><span class="line">         * 上溯父节点更新统计值</span><br><span class="line">         */</span><br><span class="line">        while (true) &#123;</span><br><span class="line">                u64 *cpuusage = per_cpu_ptr(ca-&gt;cpuusage, cpu);</span><br><span class="line">                *cpuusage += cputime;</span><br><span class="line"></span><br><span class="line">                ca = parent_ca(ca);</span><br><span class="line">                if (!ca)</span><br><span class="line">                        break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在时钟中断的时候会最终调用<code>cpuacct_account_field()</code>来更新<code>kcpustat</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Add user/system time to cpuacct.</span><br><span class="line"> *</span><br><span class="line"> * Note: it&#x27;s the caller that updates the account of the root cgroup.</span><br><span class="line"> */</span><br><span class="line">void cpuacct_account_field(struct task_struct *p, int index, u64 val)</span><br><span class="line">&#123;</span><br><span class="line">        struct kernel_cpustat *kcpustat;</span><br><span class="line">        struct cpuacct *ca;</span><br><span class="line"></span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        ca = task_ca(p);</span><br><span class="line">        while (ca != &amp;root_cpuacct) &#123;</span><br><span class="line">                kcpustat = this_cpu_ptr(ca-&gt;cpustat);</span><br><span class="line">                kcpustat-&gt;cpustat[index] += val;</span><br><span class="line">                ca = __parent_ca(ca);</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>cpuacct 算是一个简单的子系统，多是统计信息。</p>
<h1 id="cpuset-子系统"><a href="#cpuset-子系统" class="headerlink" title="cpuset 子系统"></a>cpuset 子系统</h1><p>cpuset 子系统用于分配独立的内存节点和CPU节点，这个主要应用与<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA结构</a>里面，多内存节点属于结构，先看一下<code>cpuset</code>的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct cpuset &#123;</span><br><span class="line">        struct cgroup_subsys_state css;</span><br><span class="line">        </span><br><span class="line">        unsigned long flags;            /* &quot;unsigned long&quot; so bitops work */</span><br><span class="line">        cpumask_var_t cpus_allowed;     /* CPUs allowed to tasks in cpuset */</span><br><span class="line">        nodemask_t mems_allowed;        /* Memory Nodes allowed to tasks */</span><br><span class="line">        </span><br><span class="line">        struct fmeter fmeter;           /* memory_pressure filter */</span><br><span class="line">        </span><br><span class="line">        /*</span><br><span class="line">         * Tasks are being attached to this cpuset.  Used to prevent</span><br><span class="line">         * zeroing cpus/mems_allowed between -&gt;can_attach() and -&gt;attach().</span><br><span class="line">         */</span><br><span class="line">        int attach_in_progress;</span><br><span class="line">        </span><br><span class="line">        /* partition number for rebuild_sched_domains() */</span><br><span class="line">        int pn;</span><br><span class="line">        </span><br><span class="line">        /* for custom sched domain */</span><br><span class="line">        int relax_domain_level;</span><br><span class="line">        </span><br><span class="line">        struct work_struct hotplug_work;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<ul>
<li> cpuset.cpus cpu结点限制</li>
<li> cpuset.mems 内存结点限制</li>
<li> cpuset.memory_migrate 内存结点改变是否迁移</li>
<li> cpuset.cpu_exclusive 指定的限制是否是独享的，除了父节点或者子节点，不会和其他cpuset有交集</li>
<li> cpuset.mem_exclusive 指定的限制是否是独享的，除了父节点或者子节点，不会和其他cpuset有交集</li>
<li> cpuset.memory_pressure 换页压力的比率统计</li>
<li> cpuset.mem_hardwall 限制内核内存分配的结点，mems是限制用户态的分配</li>
<li> cpuset.memory_spread_page 把page cache分散到分配的各个结点中，而不是当前运行的结点.</li>
<li> cpuset.memory_spread_slab 把fs相关的slab的对象(inode和dentry)分散到结点中.</li>
<li> cpuset.sched_load_balance 打开调度CPU的负载均衡，这里指的是cpuset拥有的sched_domain，默认全局的CPU调度是本来就有负载均衡的。</li>
<li> cpuset.sched_relax_domain_level </li>
<li> cpuset.memory_pressure_enabled 计算换页压力的开关，注意，这个属性在<code>top_group</code>里面才有</li>
</ul>
<p><code>cpus_allowed</code>和<code>mems_allowed</code>就是允许分配的内存节点和CPU节点的<a target="_blank" rel="noopener" href="http://blog.csdn.net/ustc_dylan/article/details/4030831">掩码</a>。</p>
<p>分配内存的时候调用栈是<code>alloc_pages()-&gt;alloc_pages_current()-&gt;__alloc_pages_nodemask()</code>，直到寻找可分配结点的时候会调用 <code>zref_in_nodemask</code> 来判断是否可以分配在该结点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)</span><br><span class="line">&#123; </span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">        return node_isset(zonelist_node_idx(zref), *nodes);</span><br><span class="line">#else</span><br><span class="line">        return 1;</span><br><span class="line">#endif /* CONFIG_NUMA */</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从这个函数也可以看到如果编译选项带了<code>CONFIG_NUMA</code>才会起作用，不然返回的永远都是真。</p>
<p>分散<code>file cache</code>和<code>slab cache</code>的方式是通过设置<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/scheduler/sched-domains.txt">标志位</a>来实现的。</p>
<blockquote>
<p>Setting the flag ‘cpuset.memory_spread_page’ turns on a per-process flag<br>PFA_SPREAD_PAGE for each task that is in that cpuset or subsequently<br>joins that cpuset.  The page allocation calls for the page cache<br>is modified to perform an inline check for this PFA_SPREAD_PAGE task<br>flag, and if set, a call to a new routine cpuset_mem_spread_node()<br>returns the node to prefer for the allocation.</p>
<p>Similarly, setting ‘cpuset.memory_spread_slab’ turns on the flag<br>PFA_SPREAD_SLAB, and appropriately marked slab caches will allocate<br>pages from the node returned by cpuset_mem_spread_node().</p>
</blockquote>
<p>内存分配向结点的传播，都是通过设置标志<code>PFA_SPREAD_PAGE</code>或者<code>PFA_SPREAD_SLAB</code>来标记的，这个时候对应的函数<code>cpuset_mem_spread_node</code>和<code>cpuset_mem_spread_node</code>会返回希望分配的结点，举个例子，<code>cpuset_mem_spread_node</code>会从允许的节点中随机返回一个值，以达到分配对象分散在结点当中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static int cpuset_spread_node(int *rotor)</span><br><span class="line">&#123; </span><br><span class="line">        int node;              </span><br><span class="line"></span><br><span class="line">        node = next_node(*rotor, current-&gt;mems_allowed);</span><br><span class="line">        if (node == MAX_NUMNODES)       </span><br><span class="line">                node = first_node(current-&gt;mems_allowed);</span><br><span class="line">        *rotor = node;         </span><br><span class="line">        return node;           </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">int cpuset_mem_spread_node(void)</span><br><span class="line">&#123; </span><br><span class="line">        if (current-&gt;cpuset_mem_spread_rotor == NUMA_NO_NODE)</span><br><span class="line">                current-&gt;cpuset_mem_spread_rotor =</span><br><span class="line">                        node_random(&amp;current-&gt;mems_allowed);</span><br><span class="line">  </span><br><span class="line">        return cpuset_spread_node(&amp;current-&gt;cpuset_mem_spread_rotor);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于CPU结点的控制是通过修改<code>cpus_allowed</code>来控制的，在task被唤醒的时候选择运行的rq时就会对掩码做判断，这是调度类需要实现的接口<code>select_task_rq</code>，比如CFS的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The caller (fork, wakeup) owns p-&gt;pi_lock, -&gt;cpus_allowed is stable.</span><br><span class="line"> */</span><br><span class="line">static inline</span><br><span class="line">int select_task_rq(struct task_struct *p, int sd_flags, int wake_flags)</span><br><span class="line">&#123; </span><br><span class="line">        int cpu = p-&gt;sched_class-&gt;select_task_rq(p, sd_flags, wake_flags);</span><br><span class="line">  </span><br><span class="line">        /*</span><br><span class="line">         * In order not to call set_task_cpu() on a blocking task we need</span><br><span class="line">         * to rely on ttwu() to place the task on a valid -&gt;cpus_allowed</span><br><span class="line">         * cpu.</span><br><span class="line">         *</span><br><span class="line">         * Since this is common to all placement strategies, this lives here.</span><br><span class="line">         *</span><br><span class="line">         * [ this allows -&gt;select_task() to simply return task_cpu(p) and</span><br><span class="line">         *   not worry about this generic constraint ]</span><br><span class="line">         */</span><br><span class="line">        if (unlikely(!cpumask_test_cpu(cpu, tsk_cpus_allowed(p)) ||</span><br><span class="line">                     !cpu_online(cpu)))              </span><br><span class="line">                cpu = select_fallback_rq(task_cpu(p), p);</span><br><span class="line"></span><br><span class="line">        return cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>load_balance</code> 设置的是<code>cpuset</code>的<code>CS_SCHED_LOAD_BALANCE</code>标志，之后会调用<code>update_cpumask</code>，这个标志的更新会调用<code>rebuild_sched_domains_locked()</code>，会引起<code>sched_domain</code>的分配。当然这不是唯一的<code>sched_domain</code>重新划分的触发点,触发点有一下几点。</p>
<ol>
<li> 绑定了CPU并且该标记改变</li>
<li> 这个标记为enable，绑定CPU发生改变</li>
<li> 绑定了CPU，这个标记为enable，标记<code>cpuset.sched_relax_domain_level</code>发生改变</li>
<li> 绑定了CPU，并且该标记设置了，但是cpuset被删除了</li>
<li> CPU 转变 offline/online 状态</li>
</ol>
<p>简单说一下[sched_domain](<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-schldom/">https://www.ibm.com/developerworks/cn/linux/l-cn-schldom/</a> sched domain 的详细内容)的作用，其实就是划定了负载均衡的 CPU 范围，默认是有一个全局的<code>sched_domain</code>，对所有 CPU 做负载均衡的，现在再划分出一个<code>sched_domain</code>把 CPU 的某个子集作为负载均衡的单元。<br>每个 Scheduling Domain 其实就是具有相同属性的一组 CPU 的集合. 并且跟据 Hyper-threading, Multi-core, SMP, NUMA architectures 这样的系统结构划分成不同的级别，不同级之间通过指针链接在一起, 从而形成一种的树状的关系, 如下图所示。</p>
<img data-src="/zh-CN/2017/05/07/cgroups-%E5%88%86%E6%9E%90%E4%B9%8B%E5%86%85%E5%AD%98%E5%92%8CCPU/sched_domain.jpg" class="">

<p>调度器会调用<code>partition_sched_domains()</code>来更新自己的<code>scehd_domains</code>，调度域发生作用的地方是在时钟中断的时候会触发<code>SCHED_SOFTIRQ</code>对任务做迁移，或者<code>p-&gt;sched_class-&gt;select_task_rq</code>，会在选择运行 CPU 时进行抉择，看一下 CFS 的实现的<code>select_task_rq</code>的简化流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 向上遍历更高层次的domain,如果发现同属一个domain</span><br><span class="line">// 就是affine目标</span><br><span class="line">      for_each_domain(cpu, tmp) &#123;</span><br><span class="line">               /*</span><br><span class="line">                * If both cpu and prev_cpu are part of this domain,</span><br><span class="line">                * cpu is a valid SD_WAKE_AFFINE target.</span><br><span class="line">                */</span><br><span class="line">               if (want_affine &amp;&amp; (tmp-&gt;flags &amp; SD_WAKE_AFFINE) &amp;&amp;</span><br><span class="line">                   cpumask_test_cpu(prev_cpu, sched_domain_span(tmp))) &#123;</span><br><span class="line">                       affine_sd = tmp;</span><br><span class="line">                       break;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (tmp-&gt;flags &amp; sd_flag)</span><br><span class="line">                       sd = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">// 如果上面的条件满足,从prev_cpu中选出一个idle的new_cpu来运行.</span><br><span class="line">       if (affine_sd) &#123;</span><br><span class="line">               if (cpu != prev_cpu &amp;&amp; wake_affine(affine_sd, p, sync))</span><br><span class="line">                       prev_cpu = cpu;                 </span><br><span class="line">	// 在同一个级别的sched domain向下找到一个idle的CPU.</span><br><span class="line">               new_cpu = select_idle_sibling(p, prev_cpu);</span><br><span class="line">	// 快速路径,有idle的CPU就不用负载均衡了.</span><br><span class="line">               goto unlock;</span><br><span class="line">       &#125;</span><br><span class="line">// 遍历层级</span><br><span class="line">       while (sd) &#123;</span><br><span class="line">	//  找到负载最小的CPU</span><br><span class="line">               group = find_idlest_group(sd, p, cpu, load_idx);</span><br><span class="line">               if (!group) &#123;</span><br><span class="line">                       sd = sd-&gt;child;</span><br><span class="line">                       continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               new_cpu = find_idlest_cpu(group, p, cpu);</span><br><span class="line">	/* 如果最闲置的CPU没有变的话,或者没有找到的话,就向下遍历.</span><br><span class="line">               if (new_cpu == -1 || new_cpu == cpu) &#123;</span><br><span class="line">                       /* Now try balancing at a lower domain level of cpu */</span><br><span class="line">                       sd = sd-&gt;child;</span><br><span class="line">                       continue;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               /* Now try balancing at a lower domain level of new_cpu */</span><br><span class="line">               cpu = new_cpu;</span><br><span class="line">               weight = sd-&gt;span_weight;</span><br><span class="line">               sd = NULL;</span><br><span class="line">	// 如果选出的节点weight比其他节点都大的话.</span><br><span class="line">	// 再向下一个层级遍历.</span><br><span class="line">               for_each_domain(cpu, tmp) &#123;</span><br><span class="line">                       if (weight &lt;= tmp-&gt;span_weight)</span><br><span class="line">                               break;</span><br><span class="line">                       if (tmp-&gt;flags &amp; sd_flag)</span><br><span class="line">                               sd = tmp;</span><br><span class="line">               &#125;</span><br><span class="line">               /* while loop will break here if sd == NULL */</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>负载均衡的对象有个例外。</p>
<blockquote>
<p>CPUs in “cpuset.isolcpus” were excluded from load balancing by the<br>isolcpus= kernel boot option, and will never be load balanced regardless<br>of the value of “cpuset.sched_load_balance” in any cpuset.</p>
</blockquote>
<p>如果boot选项标记了该CPU，会无视<code>sched_load_balance</code>的设置。</p>
<p><code>cpuset.sched_relax_domain_level</code>有几个等级，越大越优先，表示迁移时搜索CPU的范围，这个主要开启了负载均衡选项的时候才有用。</p>
<ul>
<li>  -1  : no request. use system default or follow request of others. 用默认的或者按照其他组的优先级来.</li>
<li>  0  : no search,不搜索.</li>
<li>  1  : search siblings (hyperthreads in a core,搜索CPU当中的超线程).</li>
<li>  2  : search cores in a package.(搜索CPU当中的核).</li>
<li>  3  : search cpus in a node [= system wide on non-NUMA system]</li>
<li>  4  : search nodes in a chunk of node [on NUMA system]</li>
<li>  5  : search system wide [on NUMA system]</li>
</ul>
<h1 id="memory-子系统"><a href="#memory-子系统" class="headerlink" title="memory 子系统"></a>memory 子系统</h1><p>看完 cpu 部分再开看一下内存子系统是如何做限制的</p>
<p>memory 子系统的参数比较多</p>
<ul>
<li>  memory.usage_in_bytes           # 当前内存中的 res_counter 使用量</li>
<li>  memory.memsw.usage_in_bytes     # 当前内存和交换空间中的 res_counter 使用量</li>
<li>  memory.limit_in_bytes           # 设置/读取 内存使用量</li>
<li>  memory.memsw.limit_in_bytes     # 设置/读取 内存加交换空间使用量</li>
<li>  memory.failcnt                  # 读取内存使用量被限制的次数</li>
<li>  memory.memsw.failcnt            # 读取内存和交换空间使用量被限制的次数</li>
<li>  memory.max_usage_in_bytes       # 最大内存使用量</li>
<li>  memory.memsw.max_usage_in_bytes # 最大内存和交换空间使用量</li>
<li>  memory.soft_limit_in_bytes      # 设置/读取内存的soft limit</li>
<li>  memory.stat                     # 统计信息</li>
<li>  memory.use_hierarchy            # 设置/读取 层级统计的使能</li>
<li>  memory.force_empty              # trigger forced move charge to parent?</li>
<li>  memory.pressure_level           # 设置内存压力通知</li>
<li>  memory.swappiness               # 设置/读取 vmscan swappiness 参数?</li>
<li>  memory.move_charge_at_immigrate # 设置/读取 controls of moving charges?</li>
<li>  memory.oom_control              # 设置/读取 内存超限控制信息</li>
<li>  memory.numa_stat                # 每个numa节点的内存使用数量</li>
<li>  memory.kmem.limit_in_bytes      # 设置/读取 内核内存限制的hard limit</li>
<li>  memory.kmem.usage_in_bytes      # 读取当前内核内存的分配</li>
<li>  memory.kmem.failcnt             # 读取当前内核内存分配受限的次数</li>
<li>  memory.kmem.max_usage_in_bytes  # 读取最大内核内存使用量</li>
<li>  memory.kmem.tcp.limit_in_bytes  # 设置tcp 缓存内存的hard limit</li>
<li>  memory.kmem.tcp.usage_in_bytes  # 读取tcp 缓存内存的使用量</li>
<li>  memory.kmem.tcp.failcnt            # tcp 缓存内存分配的受限次数</li>
<li>  memory.kmem.tcp.max_usage_in_bytes # tcp 缓存内存的最大使用量</li>
</ul>
<p>对于大部分的数据是通过<code>res_counter</code>来保存的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The core object. the cgroup that wishes to account for some</span><br><span class="line"> * resource may include this counter into its structures and use</span><br><span class="line"> * the helpers described beyond</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">struct res_counter &#123;</span><br><span class="line">        /*</span><br><span class="line">         * the current resource consumption level</span><br><span class="line">         */</span><br><span class="line">        unsigned long long usage;</span><br><span class="line">        /*</span><br><span class="line">         * the maximal value of the usage from the counter creation</span><br><span class="line">         */</span><br><span class="line">        unsigned long long max_usage;</span><br><span class="line">        /*</span><br><span class="line">         * the limit that usage cannot exceed</span><br><span class="line">         */</span><br><span class="line">        unsigned long long limit;</span><br><span class="line">        /*</span><br><span class="line">         * the limit that usage can be exceed</span><br><span class="line">         */</span><br><span class="line">        unsigned long long soft_limit;</span><br><span class="line">        /*</span><br><span class="line">         * the number of unsuccessful attempts to consume the resource</span><br><span class="line">         */</span><br><span class="line">        unsigned long long failcnt;</span><br><span class="line">        /*</span><br><span class="line">         * the lock to protect all of the above.</span><br><span class="line">         * the routines below consider this to be IRQ-safe</span><br><span class="line">         */</span><br><span class="line">        spinlock_t lock;</span><br><span class="line">        /*</span><br><span class="line">         * Parent counter, used for hierarchial resource accounting</span><br><span class="line">         */</span><br><span class="line">        struct res_counter *parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取方式是通过该结构相关的封装接口提供的，比如<code>mem_cgroup_usage</code>就是通过<code>res_counter_red_u64</code>来获取对应的<code>res_counter</code>的<code>RES_USAGE</code>对应的值的，也就是<code>unsigned long long usage</code>这个成员。(如果不是root，还会递归获取rss和page cache的合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static inline u64 mem_cgroup_usage(struct mem_cgroup *memcg, bool swap)</span><br><span class="line">&#123; </span><br><span class="line">        u64 val;</span><br><span class="line">  </span><br><span class="line">        if (!mem_cgroup_is_root(memcg)) &#123;</span><br><span class="line">                if (!swap)</span><br><span class="line">                        return res_counter_read_u64(&amp;memcg-&gt;res, RES_USAGE);</span><br><span class="line">                else</span><br><span class="line">                        return res_counter_read_u64(&amp;memcg-&gt;memsw, RES_USAGE);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        /*</span><br><span class="line">         * Transparent hugepages are still accounted for in MEM_CGROUP_STAT_RSS</span><br><span class="line">         * as well as in MEM_CGROUP_STAT_RSS_HUGE.</span><br><span class="line">         */</span><br><span class="line">	// 如果是root就把所有的内存使用量都算进来.</span><br><span class="line">        val = mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_CACHE);</span><br><span class="line">        val += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_RSS);</span><br><span class="line">  </span><br><span class="line">        if (swap)</span><br><span class="line">                val += mem_cgroup_recursive_stat(memcg, MEM_CGROUP_STAT_SWAP);</span><br><span class="line">  </span><br><span class="line">        return val &lt;&lt; PAGE_SHIFT;       </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>struct mem_cgroup</code> 是负责内存 cgroup 的结构，简化的表示是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct mem_cgroup &#123;</span><br><span class="line">        struct cgroup_subsys_state css; // 通过css关联cgroup.</span><br><span class="line">        struct res_counter res; // mem统计变量</span><br><span class="line">	res_counter memsw; // mem+sw的和</span><br><span class="line">        struct res_counter kmem; // 内核内存统计量</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些参数的入口都在<code>mm/memcontrol.c</code>下，比如说<code>memory.usage_in_bytes</code>的读取调用的是<code>mem_cgroup_read</code>函数,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t mem_cgroup_read(struct cgroup *cont, struct cftype *cft,</span><br><span class="line">                               struct file *file, char __user *buf,</span><br><span class="line">                               size_t nbytes, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	// 获取cgroup对应的mem_cgroup.</span><br><span class="line">        struct mem_cgroup *memcg = mem_cgroup_from_cont(cont);</span><br><span class="line">        char str[64];</span><br><span class="line">        u64 val;</span><br><span class="line">        int name, len;</span><br><span class="line">        enum res_type type;</span><br><span class="line">  </span><br><span class="line">	// 获取读取的类型,memory.usage_in_bytes就是_MEM</span><br><span class="line">        type = MEMFILE_TYPE(cft-&gt;private);</span><br><span class="line">	// 名称</span><br><span class="line">        name = MEMFILE_ATTR(cft-&gt;private);</span><br><span class="line">  </span><br><span class="line">        switch (type) &#123;</span><br><span class="line">        case _MEM:</span><br><span class="line">                if (name == RES_USAGE)          </span><br><span class="line">                        val = mem_cgroup_usage(memcg, false); </span><br><span class="line">                else</span><br><span class="line">                        val = res_counter_read_u64(&amp;memcg-&gt;res, name);</span><br><span class="line">                break;</span><br><span class="line">        case _MEMSWAP:</span><br><span class="line">                if (name == RES_USAGE)          </span><br><span class="line">                        val = mem_cgroup_usage(memcg, true);</span><br><span class="line">                else</span><br><span class="line">                        val = res_counter_read_u64(&amp;memcg-&gt;memsw, name);</span><br><span class="line">                break;</span><br><span class="line">        case _KMEM:</span><br><span class="line">                val = res_counter_read_u64(&amp;memcg-&gt;kmem, name);</span><br><span class="line">                break;</span><br><span class="line">        default:</span><br><span class="line">                BUG();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        len = scnprintf(str, sizeof(str), &quot;%llu\n&quot;, (unsigned long long)val);</span><br><span class="line">        return simple_read_from_buffer(buf, nbytes, ppos, str, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来再看一下这些值是在什么时候统计的，统计的入口是<code>mem_cgroup_charge_common()</code>，如果统计值超过限制就会在cgroup内进行回收。调用者分别是缺页时调用的<code>mem_cgroup_newpage_charge</code> 和 page cache　相关的<code>mem_cgroup_cache_charge</code>。</p>
<p>简单复习一下内存分配的过程，来自<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">维基百科</a></p>
<blockquote>
<p>创建进程fork(), 程序载入execve(), 映射文件mmap(), 动态内存分配 malloc()/brk() 等进程相关操作都需要分配内存给进程。不过这时进程申请和获得的还不是实际内存，而是虚拟内存，准确的说是“内存区域”。进程对内存区域的分配最终都会归结到 do_mmap() 函数上来(brk调用被单独以系统调用实现，不用do_mmap())，内核使用 do_mmap() 函数创建一个新的线性地址区间。但是说该函数创建了一个新 VMA 并不非常准确，因为如果创建的地址区间和一个已经存在的地址区间相邻，并且它们具有相同的访问权限的话，那么两个区间将合并为一个。如果不能合并，那么就确实需要创建一个新的 VMA 了。但无论哪种情况，do_mmap() 函数都会将一个地址区间加入到进程的地址空间中–无论是扩展已存在的内存区域还是创建一个新的区域。同样，释放一个内存区域应使用函数 do_ummap()，它会销毁对应的内存区域。当进程需要内存时，从内核获得的仅仅是虚拟的内存区域，而不是实际的物理地址，进程并没有获得物理内存，获得的仅仅是对一个新的线性地址区间的使用权。实际的物理内存只有当进程真的去访问新获取的虚拟地址时，才会由”请求页机制”产生”缺页”异常，从而进入分配实际页面的例程<br>。</p>
</blockquote>
<p>和下面来自<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt">内核文档</a></p>
<blockquote>
<p>与用户进程相似，内核也有一个名为 init_mm 的 mm_strcut 结构来描述内核地址空间，其中页表项 pdg=swapper_pg_dir包含了系统内核空间(3G-4G)的映射关系。因此 vmalloc 分配内核虚拟地址必须更新内核页表，而kmalloc或get_free_page由于分配的连续内存，所以不需要更新内核页表。[13]</p>
</blockquote>
<p>内存页的分配是基于伙伴分配系统，也就是基于2的阶乘通过拆分大阶乘的连续页和合并小阶乘的连续页来管理物理内存的方式，这在任何一本操作系统的书里都会讲到，我之前的博客也详细分析了。</p>
<p>当进程进入缺页异常的时候就会分配具体的物理内存，当物理内存使用超过高水平线以后，换页daemon(kswapd)就会被唤醒用于把内存交换到交换空间以腾出内存，当内存恢复至高水平线以后换页daemon进入睡眠。</p>
<p>缺页异常的入口是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static int __do_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span><br><span class="line">                unsigned long address, pmd_t *pmd,</span><br><span class="line">                pgoff_t pgoff, unsigned int flags, pte_t orig_pte)</span><br><span class="line">&#123;</span><br><span class="line">        pte_t *page_table;</span><br><span class="line">        spinlock_t *ptl;</span><br><span class="line">        struct page *page;</span><br><span class="line">        struct page *cow_page;</span><br><span class="line">        pte_t entry;</span><br><span class="line">        int anon = 0;</span><br><span class="line">        struct page *dirty_page = NULL;</span><br><span class="line">        struct vm_fault vmf;</span><br><span class="line">        int ret;</span><br><span class="line">        int page_mkwrite = 0;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * If we do COW later, allocate page befor taking lock_page()</span><br><span class="line">         * on the file cache page. This will reduce lock holding time.</span><br><span class="line">         */</span><br><span class="line">        if ((flags &amp; FAULT_FLAG_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED)) &#123;</span><br><span class="line"></span><br><span class="line">                if (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">                        return VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">		/* 分配内存并且映射到内存区间 */</span><br><span class="line">                cow_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);</span><br><span class="line">                if (!cow_page)</span><br><span class="line">                        return VM_FAULT_OOM;</span><br><span class="line">		/* 进行统计 */</span><br><span class="line">                if (mem_cgroup_newpage_charge(cow_page, mm, GFP_KERNEL)) &#123;</span><br><span class="line">                        page_cache_release(cow_page);</span><br><span class="line">                        return VM_FAULT_OOM;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else</span><br><span class="line">                cow_page = NULL;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>mem_cgroup_newpage_charge</code>则调用<code>mem_cgroup_charge_common</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int mem_cgroup_newpage_charge(struct page *page,</span><br><span class="line">                              struct mm_struct *mm, gfp_t gfp_mask)</span><br><span class="line">&#123; </span><br><span class="line">        if (mem_cgroup_disabled())</span><br><span class="line">                return 0;</span><br><span class="line">	// 不应该关联到页表</span><br><span class="line">        VM_BUG_ON(page_mapped(page));</span><br><span class="line">	// 对应用户态地址,但是不是匿名页</span><br><span class="line">        VM_BUG_ON(page-&gt;mapping &amp;&amp; !PageAnon(page));</span><br><span class="line">	// mm 为空</span><br><span class="line">        VM_BUG_ON(!mm);</span><br><span class="line">        return mem_cgroup_charge_common(page, mm, gfp_mask,</span><br><span class="line">                                        MEM_CGROUP_CHARGE_TYPE_ANON);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>mem_cgroup_charge_common</code>内容是，返回<code>ret &lt; 0</code>则是OOM。第一步是调用<code>__mem_cgroup_try_charge</code>查看当前使用量是否超过内存限制，如果超过就进行内存回收。第二步如果成功就调用<code>__mem_cgroup_commit_charge</code>添加统计值 ,不然就返回无法分配内存的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int mem_cgroup_charge_common(struct page *page, struct mm_struct *mm,</span><br><span class="line">                                gfp_t gfp_mask, enum charge_type ctype)</span><br><span class="line">&#123; </span><br><span class="line">        struct mem_cgroup *memcg = NULL;</span><br><span class="line">        unsigned int nr_pages = 1;      </span><br><span class="line">        bool oom = true;</span><br><span class="line">        int ret;</span><br><span class="line">        if (PageTransHuge(page)) &#123;      </span><br><span class="line">                nr_pages &lt;&lt;= compound_order(page);</span><br><span class="line">                VM_BUG_ON(!PageTransHuge(page));</span><br><span class="line">                /*</span><br><span class="line">                 * Never OOM-kill a process for a huge page.  The</span><br><span class="line">                 * fault handler will fall back to regular pages.</span><br><span class="line">                 */</span><br><span class="line">                oom = false;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        ret = __mem_cgroup_try_charge(mm, gfp_mask, nr_pages, &amp;memcg, oom);</span><br><span class="line">        if (ret == -ENOMEM)</span><br><span class="line">                return ret;</span><br><span class="line">        __mem_cgroup_commit_charge(memcg, page, nr_pages, ctype, false);</span><br><span class="line">        return 0;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>__mem_cgroup_try_charge</code>最终会调用<code>mem_cgroup_do_charge</code>，省略代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int mem_cgroup_do_charge(struct mem_cgroup *memcg, gfp_t gfp_mask,</span><br><span class="line">                                unsigned int nr_pages, unsigned int min_pages,</span><br><span class="line">                                bool invoke_oom)</span><br><span class="line">&#123;</span><br><span class="line">        unsigned long csize = nr_pages * PAGE_SIZE;</span><br><span class="line">        struct mem_cgroup *mem_over_limit;</span><br><span class="line">        struct res_counter *fail_res;</span><br><span class="line">        unsigned long flags = 0;</span><br><span class="line">        int ret;</span><br><span class="line">	// 更新res计数器</span><br><span class="line">        ret = res_counter_charge(&amp;memcg-&gt;res, csize, &amp;fail_res);</span><br><span class="line"></span><br><span class="line">        if (likely(!ret)) &#123;</span><br><span class="line">                if (!do_swap_account)</span><br><span class="line">                        return CHARGE_OK;</span><br><span class="line">		// 计数成功,如果开启swap计数,记录memsw.</span><br><span class="line">                ret = res_counter_charge(&amp;memcg-&gt;memsw, csize, &amp;fail_res);</span><br><span class="line">                if (likely(!ret))</span><br><span class="line">                        return CHARGE_OK;               </span><br><span class="line">		// swap计数失败,退回res的计数</span><br><span class="line">                res_counter_uncharge(&amp;memcg-&gt;res, csize);</span><br><span class="line">		// 获取fail_res对应的memcg,也就是计数失败的memcg.</span><br><span class="line">                mem_over_limit = mem_cgroup_from_res_counter(fail_res, memsw);</span><br><span class="line">                flags |= MEM_CGROUP_RECLAIM_NOSWAP;</span><br><span class="line">        &#125; else</span><br><span class="line">                mem_over_limit = mem_cgroup_from_res_counter(fail_res, res);</span><br><span class="line">	// 回收内存</span><br><span class="line">        ret = mem_cgroup_reclaim(mem_over_limit, gfp_mask, flags);</span><br><span class="line">	// 告诉上层重试一次，可能回收了一些内存</span><br><span class="line">        if (nr_pages &lt;= (1 &lt;&lt; PAGE_ALLOC_COSTLY_ORDER) &amp;&amp; ret)</span><br><span class="line">                return CHARGE_RETRY;</span><br><span class="line">        if (invoke_oom)</span><br><span class="line">		// 进入oom的处理</span><br><span class="line">                mem_cgroup_oom(mem_over_limit, gfp_mask, get_order(csize));	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>mem_cgroup_reclaim</code>的代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static unsigned long mem_cgroup_reclaim(struct mem_cgroup *memcg,</span><br><span class="line">                                        gfp_t gfp_mask,                 </span><br><span class="line">                                        unsigned long flags)            </span><br><span class="line">&#123;</span><br><span class="line">        unsigned long total = 0;        </span><br><span class="line">        bool noswap = false;</span><br><span class="line">        int loop;</span><br><span class="line"></span><br><span class="line">        if (flags &amp; MEM_CGROUP_RECLAIM_NOSWAP)</span><br><span class="line">                noswap = true;</span><br><span class="line">        if (!(flags &amp; MEM_CGROUP_RECLAIM_SHRINK) &amp;&amp; memcg-&gt;memsw_is_minimum)</span><br><span class="line">                noswap = true;</span><br><span class="line"></span><br><span class="line">        for (loop = 0; loop &lt; MEM_CGROUP_MAX_RECLAIM_LOOPS; loop++) &#123;</span><br><span class="line">                if (loop)</span><br><span class="line">                        drain_all_stock_async(memcg);   </span><br><span class="line">                total += try_to_free_mem_cgroup_pages(memcg, gfp_mask, noswap);</span><br><span class="line">                /*</span><br><span class="line">                 * Allow limit shrinkers, which are triggered directly</span><br><span class="line">                 * by userspace, to catch signals and stop reclaim</span><br><span class="line">                 * after minimal progress, regardless of the margin.</span><br><span class="line">                 */</span><br><span class="line">                if (total &amp;&amp; (flags &amp; MEM_CGROUP_RECLAIM_SHRINK))</span><br><span class="line">                        break;</span><br><span class="line">                if (mem_cgroup_margin(memcg))   </span><br><span class="line">                        break;</span><br><span class="line">                /*</span><br><span class="line">                 * If nothing was reclaimed after two attempts, there</span><br><span class="line">                 * may be no reclaimable pages in this hierarchy.</span><br><span class="line">                 */</span><br><span class="line">                if (loop &amp;&amp; !total)             </span><br><span class="line">                        break;</span><br><span class="line">        &#125;</span><br><span class="line">        return total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><code>RSS</code>在<code>page_fault</code>的时候记录，<code>page cache</code>是插入到<code>inode</code>的<code>radix-tree</code>中才记录的。<br><code>RSS</code>在完全<code>unmap</code>的时候减少计数，<code>page cache</code>的<code>page</code>在离开<code>inode</code>的<code>radix-tree</code>才减少计数。<br>即使<code>RSS</code>完全unmap，也就是被<code>kswapd</code>给换出，可能作为SwapCache存留在系统中，除非不作为SwapCache，不然还是会被计数。<br>一个换入的<code>page</code>不会马上计数，只有被<code>map</code>的时候才会，当进行换页的时候，会预读一些不属于当前进程的<code>page</code>，而不是通过<code>page fault</code>，所以不在换入的时候计数。</p>
<p>补充:</p>
<blockquote>
<ul>
<li>why ‘memory+swap’ rather than swap.<br>The global LRU(kswapd) can swap out arbitrary pages. Swap-out means<br>to move account from memory to swap…there is no change in usage of<br>memory+swap. In other words, when we want to limit the usage of swap without<br>affecting global LRU, memory+swap limit is better than just limiting swap from<br>an OS point of view.[12]</li>
</ul>
</blockquote>
<p>使用<code>memoery+swap</code>来统计而不是光统计<code>swap</code>，是因为<code>kswapd</code>换出的<code>page</code>只是从内存到了交换空间而已 ,在不影响<code>kswpad</code>的单页内存池<code>LRU</code>的情况下，这样的统计更有意义。</p>
<p>内核内存是不会被换出的。只有在被限制的时候才会开始计数。并且限制不能在已经有进程或者有子cgroup的情况下设置。<br>计数部分</p>
<blockquote>
<p>When use_hierarchy == 1 and a group is accounted, its children will<br>automatically be accounted regardless of their limit value.</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前总结了调度相关和内存相关的 cgroup 代码，可以看出 cgroup 本身其实主要是在一些 hook 的地方做检查，真正的控制的执行者还是调度器和内存分配器本身，cgroup 只是统计数据并且在必要的时候触发调度和内存回收等等。接下来我会就网络的部分进行一些分析，希望能够把完整的各个 cgroup 的子系统都能够解析一下。</p>
<p>参考:</p>
<ol>
<li> 《Docker 进阶与实战》</li>
<li> <a target="_blank" rel="noopener" href="http://abcdxyzk.github.io/download/kernel/Linux_Physical_Memory_Page_Allocation.pdf">http://abcdxyzk.github.io/download/kernel/Linux_Physical_Memory_Page_Allocation.pdf</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/04/30/hugepage-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/04/30/hugepage-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">hugepage 分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-30 03:59:56" itemprop="dateCreated datePublished" datetime="2017-04-30T03:59:56+08:00">2017-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/04/30/hugepage-%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/04/30/hugepage-分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先介绍一下 hugepage 的背景。</p>
<p>一般来说操作系统分配内存的最小单元是页，一般是 4KB 大小，但是这个页放到现在来说可能有点“不够用”，因为很多程序内存消耗很大，分配内存很频繁，所以选择更大的页可以提升性能，大页带来的好处很多，首先是页表的层次可以减少，增加访存的速度，其次是减少 TLB miss 的概率，同时 page fault 也会减少，减少到 hugepage size / 4KB (x86_64 一般有 2MB 的 hugepage 和 1GB 的 hugepage)。例如下面这张图就说明了 hugepage 带来的改变。文章中的代码使用的是 4.x 的内核版本。</p>
<img data-src="/zh-CN/2017/04/30/hugepage-%E5%88%86%E6%9E%90/table.png" class="">

<p>hugepage 有两种类型，一种是 THP(Transparent Huge Page) ，顾名思义，就是对用户来说对这种大页是无感知的，它本身可以被分成 4KB 的小页，并且可以被 swap out，有一个 Khugepaged 周期性扫描 4KB 的页合并成大页。</p>
<p>另一种大页是 persistent hugepage，这种 page 是预先分配的并且不能拆分成 4KB 小页，而且不能 swap out。这种的隐患是可能在内存 fragmentation 太多分不出大页的时候压缩小页，这在内存分配有压力的时候会造成很大的性能影响。</p>
<p>使用 persistent hugepage 可以通过 <code>echo 512 | sudo tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</code>，这会预先分配 512 个 2MB 的大页。具体使用是通过 fs/hugetlbfs 下实现的<code>hugetlbfs</code>来实现的。应用程序需要通过<code>mmap</code>进行文件映射来使用这些大页。具体的使用方式内核附带的一个<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/tools/testing/selftests/vm/hugepage-mmap.c">测试</a>可以作为参考。</p>
<p>这个 <code>echo</code> 触发的是 <code>sysfs</code> 的 <code>nr_hugepages_store_common</code>, 它会设置最大的 hugepage 个数（存在 hstate 中，一个保存 hugepage 状态的结构体），<code>h-&gt;max_huge_pages = set_max_huge_pages(h, count, nodes_allowed);</code>，<code>set_max_huge_pages</code> 有一个副作用就是调用 <code>alloc_fresh_huge_page</code> 来(分配或者减少)大页以达到 count 个。比如说分配会调用 <code>ret = alloc_fresh_huge_page(h, nodes_allowed);</code>，然后加入到 <code>hstate</code> 的 freelist 当中, 减少则是相反的，如果 <code>freelist</code> 上没有就会触发 buddysystem 的 <code>__alloc_buddy_huge_page_no_mpol</code>。</p>
<p>我们来看一下具体的实现，首先关键的结构体是 hugetlbfs_file_operations , 其中规定了 mmap 函数，也就是当我打开 hugetlbfs 文件系统下的文件对对应的 fd 调用 <code>mmap</code> 的时候触发的对应的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const struct file_operations hugetlbfs_file_operations = &#123;</span><br><span class="line">	.read_iter		= hugetlbfs_read_iter,</span><br><span class="line">	.mmap			= hugetlbfs_file_mmap,</span><br><span class="line">	.fsync			= noop_fsync,</span><br><span class="line">	.get_unmapped_area	= hugetlb_get_unmapped_area,</span><br><span class="line">	.llseek			= default_llseek,</span><br><span class="line">	.fallocate		= hugetlbfs_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在解释 mmap 之前，先复习一下进程空间内存的相关的内容。进程的内存空间是通过<code>mm_struct</code>这个结构体管理的。进程的地址空间，基本上是一些松散的区间，每个区间有相同的功能和保护属性（只读等属性），这个区间用 <code>vm_area_struct</code> 表示。再来看 <code>hugetlbfs_file_mmap</code> 中的一段代码。把申请的虚拟空间的地址长度按照大页对齐以后，保留对应个数的大页。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (hugetlb_reserve_pages(inode,</span><br><span class="line">			vma-&gt;vm_pgoff &gt;&gt; huge_page_order(h),</span><br><span class="line">			len &gt;&gt; huge_page_shift(h), vma,</span><br><span class="line">			vma-&gt;vm_flags))</span><br><span class="line">	goto out;</span><br><span class="line"></span><br><span class="line">ret = 0;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>hugetlb_reserve_pages</code> 要处理两种逻辑，如果是 <code>VM_MAYSHARE</code> 就从 inode 中取出 <code>resv_map</code> 并且获取分配长度，不然就使用<code>vma</code>的长度，然后用 <code>hugepage_subpool_get_pages</code> 从 <code>hugepage_subpool</code> 中减掉对应的<code>spool-&gt;rsv_hpages</code>, 这个个人感觉也不是池子，只是一个统计数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct hstate *h = hstate_inode(inode); // 获取 hugepage state，里面保存了 hugepage 的相关信息</span><br><span class="line">struct hugepage_subpool *spool = subpool_inode(inode); // 写获取 hugepage 的 pool, pool 其实只是个数字 rsv_pages。</span><br><span class="line">...</span><br><span class="line">// 然后根据 flag 算出要使用的长度 chg，我猜应该是 charge 的缩写。</span><br><span class="line">if (!vma || vma-&gt;vm_flags &amp; VM_MAYSHARE) &#123;</span><br><span class="line">	resv_map = inode_resv_map(inode);</span><br><span class="line"></span><br><span class="line">	chg = region_chg(resv_map, from, to);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">	resv_map = resv_map_alloc();</span><br><span class="line">	if (!resv_map)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	chg = to - from;</span><br><span class="line"></span><br><span class="line">	set_vma_resv_map(vma, resv_map);</span><br><span class="line">	set_vma_resv_flags(vma, HPAGE_RESV_OWNER);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">// 最后从 hugepage 的 pool 减掉对应的个数。</span><br><span class="line">gbl_reserve = hugepage_subpool_get_pages(spool, chg);</span><br><span class="line">// 确定有足够的 hugepage 如果没有就从 buddysystem 里面取出来。</span><br><span class="line">ret = hugetlb_acct_memory(h, gbl_reserve);</span><br><span class="line">// 把 page 和 vma 做映射</span><br><span class="line">region_add(resv_map, from, to);</span><br></pre></td></tr></table></figure>

<p>在 <code>do_page_fault</code> 一直调用到 <code>__handle_mm_fault</code> 的时候，如果对应的 <code>vma</code> 是大页分配的，会直接进到<code>hugetlb_fault</code>，最后在缺页的时候会调用<code>hugetlb_no_page</code>，然后调用 <code>alloc_huge_page_node</code>，就会看到 <code>__alloc_buddy_huge_page</code>，开始走 buddy system, buddy system ，这里的 buddy system 没有细说，可以参考我之前的<a href="https://ggaaooppeenngg.github.io/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/">一篇文章</a>。</p>
<p>补充:</p>
<p>你可以理解<code>mm_struct</code>管理着一个<code>vm_area_struct</code>的链表，而 <code>vm_area_struct</code> 对应的主要操作函数如下（还有很多，这里只列了和本文相关的函数指针）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct vm_operations_struct &#123;</span><br><span class="line">	void (*open)(struct vm_area_struct * area);</span><br><span class="line">	void (*close)(struct vm_area_struct * area);</span><br><span class="line">	int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应到 hugetlbfs 就是如下的 <code>hugetlb_vm_ops</code> 它会在对文件 <code>mmap</code> 的时候，进行初始化<code>vma-&gt;vm_ops = &amp;hugetlb_vm_ops;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const struct vm_operations_struct hugetlb_vm_ops = &#123;</span><br><span class="line">	.fault = hugetlb_vm_op_fault,</span><br><span class="line">	.open = hugetlb_vm_op_open,</span><br><span class="line">	.close = hugetlb_vm_op_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是注意，<code>hugetlb_vm_op_fault</code> 如果被触发说明有 BUG，因为 hugepage 的 page fault 是在<code>do_page_fault</code>里面独立处理的，不会调用到<code>vm_operations_struct</code>的<code>fault</code>接口。mmap 走的流程是 <code>mmap -&gt; mmap_region -&gt; make_pages_presetn -&gt; get_user_pages -&gt; handle_page_fault -&gt; handle_mm_fault -&gt; hugetlb_fault</code>。</p>
<p>以上是大页的分配和使用的流程，希望对大家有帮助。</p>
<p>参考:</p>
<ol>
<li> <a target="_blank" rel="noopener" href="https://godleon.github.io/blog/2016/08/02/KVM-Basic-Concept-Memory">Linux KVM concept - Memory</a></li>
<li> <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/1305_zhangli_hugepage/">Linux 内核中大页的实现与分析，第 1 部分</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" class="post-title-link" itemprop="url">SQL 隔离级别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-16 22:45:33" itemprop="dateCreated datePublished" datetime="2017-04-16T22:45:33+08:00">2017-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/04/16/SQL隔离级别/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>不同的隔离级别有不同的约束，而且不一定是子集和超集的关系，约束可能是交集的。这里尝试循序渐进的加强锁的级别和实现方式来阐述各个隔离级别的区别，由此可以选择在实际开发中适合业务的隔离策略。我自己最近也在调研 cockroachdb 比较关心事务这方面的性能，cockroachdb 的事务主要是两个级别，SI 和 SSI，会在下面提到。</p>
<h2 id="总视图"><a href="#总视图" class="headerlink" title="总视图"></a>总视图</h2><p>这是各个隔离级别的一个关系，可以看出不一定是包含与被包含的关系（因为完整的隔离级别不只 4 种）。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/ansi-sql-isolation-levels.png" class="">

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>长期锁：到事务结束就释放的锁<br>短期锁：对相关数据操作完成就释放的锁</p>
<p>这里提到的写锁和排他锁可以互换，读锁和共享锁可以互换，长期锁也被称为二阶段锁，就是事务某个时候锁上了算一个阶段，最后一起释放算一个阶段。</p>
<p>断言型：基于先判的锁的修饰词，比如 WHERE 语句指定的范围就是预测型，如果没有 WHERE 可能就是整张表。</p>
<p>如果没有断言修饰的话，锁就是有指定数据的锁，也就是有明确索引的锁。</p>
<p>缩写 P(Phenomena) A(Anomalies)</p>
<h2 id="P0-dirty-write-（脏写）"><a href="#P0-dirty-write-（脏写）" class="headerlink" title="P0 dirty write （脏写）"></a>P0 dirty write （脏写）</h2><h3 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h3><p>我们最开始的阶段是一切皆有可能发生，没有任何锁，所以碰到的第一个问题是脏写。</p>
<p>脏写导致的问题是，破坏数据的一致性，一个事务 (T1) 如果覆盖了另一个正在执行事务 (T2) 之前写入的值的时候就会导致脏写。比如 T1 写入 x=y=1 并且 T2 写入 x=y=2，但是整个数据的一致性就被破坏了。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/dirty-write.png" class="">

<h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><p>对 x 和 y 持有长期写锁。基本上没有事务不拿长期写锁的，不然数据库连回退的可能都没有。防止脏写以后会出现新的现象，脏读。</p>
<h2 id="P1-dirty-read-（脏读-read-uncommited"><a href="#P1-dirty-read-（脏读-read-uncommited" class="headerlink" title="P1 dirty read （脏读 read uncommited)"></a>P1 dirty read （脏读 read uncommited)</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>事务 (T1) 写入的值被正在执行的事务 (T2) 读取。比如 x 向 y 转 40，在 x 写入以后，T2 看到的总和只有 60。</p>
<p>网上很多人把这个级别算作了脏写其实不是很严格，最开始那个 P0 级别才算是脏写。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/dirty-read.png" class="">

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>使用短期读锁和长期写锁，长期写锁可以防止 T2 的 X 读数据，短期读锁可以防止 T1 的 y 写不了（如果使用长期读锁就被阻塞到 T1 结束了）。解决脏读问题，我们又面临的问题是不可重复读</p>
<h2 id="P2-non-repeatable-read-（不可重复读）"><a href="#P2-non-repeatable-read-（不可重复读）" class="headerlink" title="P2 non-repeatable read （不可重复读）"></a>P2 non-repeatable read （不可重复读）</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><p>当正在执行的事务 (T1) 读取的值被事务 (T2) 写入的时候，对 T1 来说就出现了不一致。例如下图，X 在被读取之后又被 T2 写入，这个时候总的钱数出现了不一致。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/non-repeatable-read.png" class="">

<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>使用长期读锁和长期写锁，也就是 T2 的 X 要等 T1 提交之后才能写入。对于不可重复读的问题。不过短期的断言型读锁也是足够的，因为 X 和 Y 如果都提前读取出来还是能保持一致的。我们解决了不可重复读以后，还会碰到幻读的情况。</p>
<h2 id="P3-phantom-（幻读）"><a href="#P3-phantom-（幻读）" class="headerlink" title="P3 phantom （幻读）"></a>P3 phantom （幻读）</h2><h3 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h3><p>幻读发生在正在执行的事务 T1 有断言的读 (select where) 时，另外一个事务 T2 执行了和断言集合有交集的插入操作。<br>比如 T1 在 T2 之前读到了员工总数是 3，但是 T2 执行的时候有交集，插入了新的数据，这个时候员工总数是 4，但是 T1 如果再读取的话，就会发现员工总数变成了 4，而不是最初的 3，这就是幻读。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/phantom.png" class="">

<h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>解决幻读的方式是使用长期（断言型）读锁和写锁。也就是不允许在这个范围内进行插入操作。解决了幻读以后我们的事务就完全串行化了，这样的事务并发度是最弱的。</p>
<h2 id="P4-update-lost-（更新丢失）"><a href="#P4-update-lost-（更新丢失）" class="headerlink" title="P4 update lost （更新丢失）"></a>P4 update lost （更新丢失）</h2><p>常见的 4 个隔离级别说完了以后我们看一下剩下的部分，注意更新丢失这个现象不是比幻读更约束的现象，这个是在基于防止脏读以后可能会出现的现象，会被可重复读防止。</p>
<h3 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h3><p>事务 T2 提交的写被其他事务覆盖，首先，没有脏写，因为 T2 已经提交，其次没有脏读，因为在写之后没有读操作，这样的现象称为更新丢失。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/update-lost.png" class="">


<h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>升级到可重复读就可以了。</p>
<h2 id="P4C-cursor-update-lost-（游标更新丢失）"><a href="#P4C-cursor-update-lost-（游标更新丢失）" class="headerlink" title="P4C cursor update lost （游标更新丢失）"></a>P4C cursor update lost （游标更新丢失）</h2><h3 id="现象-4"><a href="#现象-4" class="headerlink" title="现象"></a>现象</h3><p>和更新丢失是一样的，这个只是约束在了游标操作的时候，事务 (T1) 对游标下的数据进行读之后被另一个事务 (T2) 提交了，在游标下的数据写之后让，T1 的写导致 T2 的更新丢失。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/cursor-update-lost.png" class="">

<h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>在游标移动或者释放之前，都不释放锁，这个是到达可重复读之前的一个插曲。这个也是在读提交的阶段会发生的事情。</p>
<h2 id="A5A-read-skew-（读偏）"><a href="#A5A-read-skew-（读偏）" class="headerlink" title="A5A read skew （读偏）"></a>A5A read skew （读偏）</h2><p>偏可以理解为不一致，这个是发生在多个数据之间有一个总的约束的时候。</p>
<h3 id="现象-5"><a href="#现象-5" class="headerlink" title="现象"></a>现象</h3><p>总的钱是 100，但是从 T1 的角度，总的钱数是 (50+75)，因为只有短期读锁。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/read-skew.png" class="">

<h3 id="解决-5"><a href="#解决-5" class="headerlink" title="解决"></a>解决</h3><p>使用快照隔离 (Snapshot Isolation)，快照隔离是基于 MVCC 的。当一个 T 事务开始的时候，T 会获得一个抽象的时间戳（版本），当对数据 X 进行读取的时候，并不是直接看到最新写入的数据而是在 T 开始前的所有执行中的事务中最后一个对 X 标记的版本（如果 T 修改过 X，那么看到的是自己的版本）。也就是说 T 是基于当前的数据库的一个镜像进行操作的，有点类似于 Copy And Swap，而 T 开始执行是获得的版本就是这个快照的凭证。这样能保证所有的读都是基于一个一致的状态获取的。</p>
<p>SI 解决冲突的方法一般是 “First-Commiter-Wins” 也就是说，如果两个并发的事务修改了同一个数据，先写的事务会成功，而后写的事务会发现版本和原本的不一致而退出事务。</p>
<p>以我们的例子来说的话，T1 的 y 只会读到自己开始时候的版本，也就是 50，而不是 75，这样读偏就解决了。但是快照隔离还是不能解决另一个问题，就是写偏。这是我们要面临的新问题。</p>
<h2 id="A5B-write-skew-（写偏）"><a href="#A5B-write-skew-（写偏）" class="headerlink" title="A5B write skew （写偏）"></a>A5B write skew （写偏）</h2><h3 id="现象-6"><a href="#现象-6" class="headerlink" title="现象"></a>现象</h3><p>这个和读偏类似，只不过，不一致在了整个系统上。T1 写锁有 y 的新版本，T2 写锁有 x 的新版本，他们没有写冲突，导致最后系统不一致，x+y 的钱变多了。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/write-skew.png" class="">

<h3 id="解决-6"><a href="#解决-6" class="headerlink" title="解决"></a>解决</h3><p>目前快照隔离的算法有很多，参考 cockroachDB 使用的论文的话，可以说，通过对版本依赖构成有向图，解决成环问题，以此达到串行快照隔离的级别。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/figure1.png" class="">

<p>比如上面的例子，如果 T1 在 y 读了之后写了一个版本的 y 就构成一个先读后写的 rw(y) 依赖，类似的 T2 对 T1 构成了一个先读后写的 rw(x) 依赖。还有两种无害的依赖是先写后读 (wr) 和先写后写 (ww)。论文中阐述了，造成写偏的条件是成环，并且环中有两个连续的 rw 依赖。也就是下面这种形式。</p>
<img data-src="/zh-CN/2017/04/16/SQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/figure2.png" class="">

<p>这个问题的关键是，检查成环这件事情，就跟操作系统检查死锁一样，消耗太大了，性能上不能接受，所以这个实现的妥协是，把检查放宽，让一些无害的条件也被认定为有害，通过重试来恢复执行，至少防止错误的发生。<br>这个条件是只要有两个连续的 rw 依赖就会放弃提交，即使没有成环。这个检查发生在读的时候如果发现读的版本和自己开始之前的版本不一致就会找到依赖的事务，构建一条入边，另一个事务构建一条出边，如果某个事务入边出边都有 rw 边，这个节点就会被作为嫌疑人。当然还有其他关于串行 snapshot 隔离的论文可以参考。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Oracle Consistent Read 也算是另一种快照级别的隔离。</p>
<p>参考文献</p>
<ol>
<li> <a target="_blank" rel="noopener" href="https://blog.acolyer.org/2016/02/24/a-critique-of-ansi-sql-isolation-levels/">A Critique of ANSI SQL Isolation Levels</a></li>
<li> <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/cs/0701157.pdf">ASCI-SQL</a></li>
<li> <a target="_blank" rel="noopener" href="http://www.cs.nyu.edu/courses/fall09/G22.2434-001/p729-cahill.pdf">cockroachdb 使用的算法</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/04/07/MultiRaft-%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/04/07/MultiRaft-%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">MultiRaft 解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-07 20:13:11" itemprop="dateCreated datePublished" datetime="2017-04-07T20:13:11+08:00">2017-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/04/07/MultiRaft-%E8%A7%A3%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/04/07/MultiRaft-解析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>援引自 cockroach <a target="_blank" rel="noopener" href="https://www.cockroachlabs.com/blog/scaling-raft/">博客</a> 的解释</p>
<p>cockroach 的底层 scaling 存储本身可以认为是一张无限大的有序 KV map，上层封装了一层 SQL。他 sharding 的方式是通过 range 实现的。对一组 64M 大小数据的范围内的 key 做冗余，用二级 metadata range 可以理论上存储 4EB 的数据。</p>
<p>举个例子，五节点打散三副本的一个 range 做冗余，是成本性能和效率上比较典型的一个折衷。像你说的 leader 集中的情况是比较少的，因为三副本是打散分布到不同节点上的，所以三副本的交集不会太集中，单点的压力还是很少的。</p>
<p>另外租约的存在（不知道算不算在 multi raft 算法内），也可以缓解集中化的压力，通过获得授权的租约旁路一些“可以本地化”的请求（比如只对一个 replica 的操作以及一些能保证数据不变的一段时间的读请求），来缓解主的压力，这个最早我记得在 GFS 里面看到过是这么设计的。</p>
<p>另外 gossip 的协议有点像交换机的生成树协议，是通过互相传播自己的负载和位置信心来传播信息的，没有中心化的决策节点，这样的好处就是无中心化，不会依靠一个中心的节点来做负载均衡，而且整个系统就需要一个二进制文件不依赖任何的其他服务。</p>
<p>如图是一个 range 在三节点上的三副本的一个 raft group 之间有网路通信。</p>
<img data-src="/zh-CN/2017/04/07/MultiRaft-%E8%A7%A3%E6%9E%90/raft1.png" class="">

<p>但是如果 range 变多的话，就会很复杂，如下图，是四个节点之间大概 8 个 （如果我没看错颜色的话） range 的 raft group 之间通信。</p>
<img data-src="/zh-CN/2017/04/07/MultiRaft-%E8%A7%A3%E6%9E%90/raft2.png" class="">

<p>很明显网络 RoundTrip 太多了。针对这个的优化就是 MultiRaft 了，说白了就是把网络请求 batch up，变成下面的形式。</p>
<img data-src="/zh-CN/2017/04/07/MultiRaft-%E8%A7%A3%E6%9E%90/multiraft.png" class="">

<p>这样网络压力就会小很多。针对这个的优化和应用本身的实现是耦合的，作者也尝试把这个优化加到 etcd/raft 当中，但是最后的决定是增加 RawNode 这样的无线程安全的接口给应用层实用，方便对心跳等请求的合并，所以你会看到有个非线程安全的 RawNode 的实现。</p>
<p>具体到 cockroach 的实现是可以找到相应的代码的，省略无关代码就如下。</p>
<p>在发送消息的时候检查是否有可以整合的请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (r *Replica) sendRaftMessage(ctx context.Context, msg raftpb.Message) &#123;</span><br><span class="line">    for range &#123;</span><br><span class="line">        // 迭代每个 follower 发送消息</span><br><span class="line">        // 对消息进行缓存</span><br><span class="line">        if r.maybeCoalesceHeartbeat(ctx, msg, toReplica, fromReplica, true) &#123;</span><br><span class="line">                continue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环取出缓存的消息，注意因为是整合了消息，所以对消息来说有延迟，这里稍微加快了频率，弥补这个延迟。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Since coalesced heartbeats adds latency to heartbeat messages, it is</span><br><span class="line">// beneficial to have it run on a faster cycle than once per tick, so that</span><br><span class="line">// the delay does not impact latency-sensitive features such as quiescence.</span><br><span class="line">func (s *Store) startCoalescedHeartbeatsLoop() &#123;</span><br><span class="line">	s.stopper.RunWorker(func() &#123;</span><br><span class="line">		ticker := time.NewTicker(s.cfg.CoalescedHeartbeatsInterval)</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			ticker.Stop()</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		for &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-ticker.C:</span><br><span class="line">				s.sendQueuedHeartbeats()</span><br><span class="line">			case &lt;-s.stopper.ShouldStop():</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Store 这个层面是对每个 Replica （一个 raft group 的成员） 是有感知的，但是每个 raft group 是独立的，只是在发送是会检查对方节点是否和现在的 raft group 有交集，<br>从而尝试合并消息的发送，你可以理解为在节点之间的消息通道上对不同 raft group 之间多路复用。<br>这就是 MultiRaft 对多个 raft group 的网络吞吐做的一个优化，代价是可能造成消息的延迟，因为毕竟是被缓存到队列里了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/03/31/%E4%BB%8E%E6%9C%B4%E7%B4%A0%E8%A7%A3%E9%87%8A%E5%87%BA%E5%8F%91%E8%A7%A3%E9%87%8Aleveldb%E7%9A%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/03/31/%E4%BB%8E%E6%9C%B4%E7%B4%A0%E8%A7%A3%E9%87%8A%E5%87%BA%E5%8F%91%E8%A7%A3%E9%87%8Aleveldb%E7%9A%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">从朴素解释出发解释leveldb的设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-31 00:56:49" itemprop="dateCreated datePublished" datetime="2017-03-31T00:56:49+08:00">2017-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/03/31/%E4%BB%8E%E6%9C%B4%E7%B4%A0%E8%A7%A3%E9%87%8A%E5%87%BA%E5%8F%91%E8%A7%A3%E9%87%8Aleveldb%E7%9A%84%E8%AE%BE%E8%AE%A1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/03/31/从朴素解释出发解释leveldb的设计/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>其实大家提的 LSM 最开始论文里面都使用树做搜索结构的, 现在在用的都不是严格的树结构了。</p>
<p>如<a target="_blank" rel="noopener" href="https://www.igvita.com/2012/02/06/sstable-and-log-structured-storage-leveldb/">这篇文章</a>解释的一样，从最朴素的角度上来讲可以把<code>SSTable(sorted string table)</code>作为一个连续的kv构成的块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SSTable</span><br><span class="line">+-+---+----+---+</span><br><span class="line">|k| v |  k | v | ...</span><br><span class="line">+-+---+----+---+</span><br></pre></td></tr></table></figure>
<p>对于一个大文件来说，读取整个文件以后就能构成一个各个键值的索引，当然可以在文件追加一块索引，和文件一起保存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Index</span><br><span class="line">+-+-------+</span><br><span class="line">|k|offset |</span><br><span class="line">+-+-------+</span><br><span class="line">|k|offset |</span><br><span class="line">+-+-------+</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br></pre></td></tr></table></figure>
<p>有了索引以后用 seek 操作或者直接把文件 mmap 到内存中都可以有很好的随机读性能。</p>
<p>但是对于随机写来说, 会造成大量的I/O，如果我们能够保证我们的<code>SSTable</code>是不可修改(immutable)的，只有<code>SSTable</code>在内存当中的时候(也就是<code>MemTable</code>)才可以修改，就能避免随机写的大负载问题。</p>
<p>通过下面几条约束就能完成我们的要求：</p>
<ol>
<li> 首先<code>SSTable</code>索引要放在内存中，这样读索引更快</li>
<li> 所有写只能写到<code>MemTable</code>当中, 因为<code>SSTable</code>不可修改</li>
<li> 所有读要先查看<code>MemTable</code>如果没有再查看内存中的索引(最后找到磁盘上的kv)</li>
<li> 定期把<code>MemTable</code>刷成<code>SSTable</code>,这段时间<code>MemTable</code>也变成了不可修改的,新的<code>MemTable</code>会顶替</li>
<li> 定期对<code>SSTable</code>进行合并</li>
</ol>
<p>最终我们保证了随机写很快（因为只在<code>MemTable</code>中），随机读也很快（因为要么在<code>MemTable</code>中要么通过索引可以很快找到)。</p>
<p>还有一个问题是对于已有数据的删除和修改怎么办？</p>
<p>因为<code>SSTable</code>不可修改所以只能追加写一个新的数据覆盖老的数据，对于删除则是追加一个”墓碑”值覆盖掉存在的值。把索引指向新值，这样老值就不会被访问了。最后在<code>SSTable</code>合并的时候这些老值会完全消失。所以还要定期合并<code>SSTable</code></p>
<p>以上是对leveldb的LSM结构的朴素解释。实际上<code>MemTable</code>和<code>SSTable</code>都没有采用纯粹的树形结构,<code>MemTable</code>使用的是跳表而<code>SSTable</code>使用的是层次的结构。(这也是为什么 leveldb 叫 level db 的原因)</p>
<p>从这里开始完善朴素解释</p>
<p>首先对于<code>MemTable</code>来说不是持久化的如果重启导致内存中的数据丢失怎么办？<a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Write-Ahead-Log-File-Format">WAL</a> 表示的是预写日志，这个日志和<code>MemTable</code>是同步的，这个日志把每次的命令追加到日志中再更改<code>MemTable</code>，这样如果重启的话能够进行”重放”把从已经持久化的状态开始把数据填回到<code>MemTable</code>当中。</p>
<p>其次是对<code>SSTable</code>的合并，<code>SSTable</code>是分层存储的，第一层也就是Level0(被称作 young level)，是<code>MemTable</code>刷入的一层，允许这一层的<code>SSTable</code>的key有交集。对于每一层都有一个阈值(young level 是 4,其他层是按大小算的，10^L MB)，如果超过阈值自动向下一层合并，从level1开始的每一次key不允许有交集。具体的做法是从 young level 中把有交集的<code>SSTable</code>一起和下一层key有交集的<code>SSTable</code>合并成一个新的<code>SSTable</code>，然后其他层则是从自身层取出一个和下一层有交集的<code>SSTable</code>合并即可。这个属性可以用归纳法证明，从0层向1层合并的时候，1层只有一个的情况下肯定不会相交，然后假设n个的时候也不相交，在n+1的时候有交集，那么n+1合并时有0层的 key 和 n 当中的有交集，但是有交集的部分会被归并掉所以矛盾，所以n+1个的时候也是没有交集的。那1层能保证没有交集的话取出一个向下合并也是类似的不会有交集。所以再重复一遍分层存储的两个属性。</p>
<p>对于朴素解释的两个扩展使得我们对leveldb的设计更接近了。</p>
<ol>
<li>young层SSTable之间可能存在交集</li>
<li>Li（i&gt;0）层SSTable之间不存在交集</li>
</ol>
<p>在这个基础上再增加几个约束条件，一个是，对于合并过程每超过2MB就会产生一个新文件，如果文件和下一层的文件有交集的个数有10个以上的话也会产生一个新文件，这样的目的是保证Ln和Ln+1之间不会重复太多。个人理解是覆盖太多，会成了倒三角的”树”情况，上一层搜索性能不好。</p>
<p>当然大量的随机读落在磁盘上还是会有性能问题，因为 seek 也可能是不连续的，这个可以想办法优化, 比如leveldb 里面使用了一种LRU缓存优化读性能。</p>
<p>参考</p>
<ol>
<li> <a target="_blank" rel="noopener" href="https://github.com/google/leveldb/blob/master/doc/impl.md">官方实现文档</a></li>
<li> <a target="_blank" rel="noopener" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.44.2782&rep=rep1&type=pdf">LSM-tree论文</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">什么是SSA以及SSA的作用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-01-22 01:14:50" itemprop="dateCreated datePublished" datetime="2017-01-22T01:14:50+08:00">2017-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/01/22/SSA是什么/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="SSA概述"><a href="#SSA概述" class="headerlink" title="SSA概述"></a>SSA概述</h2><p>SSA在Go1.7中被引入，这个特性对编译器的性能有很大的提高，但是也导致编译过程有些减速。下面来结合网上的资粮和书籍，简单说明一下SSA以及SSA的应用。</p>
<p>SSA 代表 static single-assignment，是一种IR(中间表示代码)，要保证每个变量只被赋值一次。这个能帮助简化编译器的优化算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y := 1</span><br><span class="line">y := 2</span><br><span class="line">x := y</span><br></pre></td></tr></table></figure>
<p>比如上面这段代码，<code>y = 1</code>其实是不可用的，这个要通过定义的可达分析来确定<code>y</code>是要用1还是2，而SSA有一个标识符可以称之为版本或者“代“。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y1 := 1</span><br><span class="line">y2 := 2</span><br><span class="line">x1 := y2</span><br></pre></td></tr></table></figure>
<p>这样就没有任何间接值了。用SSA表示的好处是对于同一个变量的无关使用表示成不同“代”，可以方便很多编译器的优化算法的实现。</p>
<p>一个概念:</p>
<p>Φ(读作fai) 函数，表示要根据控制流赋值的“代”。</p>
<p>例子可以参考维基里的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_single_assignment_form#Converting_to_SSA">这一段</a>。</p>
<p>三个定义：</p>
<p>A dominate B，如果从起点开始必须通过A到达B。也就是说A是到B的必经之路。</p>
<p>A strictly dominate B，如果 A dominate B，并且A和B不相等。</p>
<p>A 的 dominance frontier 含有B，如果A没有strictly dominate B，但是 dominate 了B的一个前驱节点。</p>
<p>用遍历的方式确定 dominance frontier 的伪代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for each node b</span><br><span class="line">    if the number of immediate predecessors of b ≥ 2</span><br><span class="line">        for each p in immediate predecessors of b</span><br><span class="line">            runner := p</span><br><span class="line">            while runner ≠ idom(b)</span><br><span class="line">                add b to runner’s dominance frontier set</span><br><span class="line">                runner := idom(runner)</span><br></pre></td></tr></table></figure>
<p>idom(b) 代表相邻的strictly dominate b的结点。这样的点只有一个，因为相邻的点有两个的话就不会是必经之路了。</p>
<img data-src="/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/example_1.jpg" class="">

<p>如图是一个例子，2的前驱是1和7，7没有sd(strictly dominate) 2，所以把2加入到7的DF(dominate frontiers)当中。3是7的相邻sd，然后3不是2的sd所以2加入到3的DF当中，接着2是3相邻的sd，然后2不是2的sd所以把2加入到2的DF中，最后遍历到7，5和6不是7的sd所以把7加入到5和6的df当中。</p>
<p>df(A)可以认为是可以通过A到达的，但不是必经之路的点的集合。</p>
<p>有了这个定义以后就可以插入Φ函数了和重命名了。如果X中有定义a那么所有df(X)都需要a的Φ函数。并且Φ函数本身也是一个定义。</p>
<p>比如还是同一个例子。</p>
<img data-src="/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/example_2.jpg" class="">

<p>1当中有j的定义，但是df(1)是空的，5当中有j的定义，并且5的df有7所以7当中要插入一个φ(j, j)。j现在在7中定义了(通过φ函数）所以df(7)中的2也要有φ(j, j)，6也有j的定义但是7已经有了φ函数了，2的df有2，但是2已经有φ函数了。类似的方式可以应用到i和k。接着对定义重命名就可以完成SSA的转换了。</p>
<h2 id="SSA的应用"><a href="#SSA的应用" class="headerlink" title="SSA的应用"></a>SSA的应用</h2><p>上面只是通俗的解释了一下SSA，没有给出更多详细的理论和算法以及证明，因为证明实在难看懂，下面说一下SSA的应用。</p>
<h3 id="DEAD-CODE-消除"><a href="#DEAD-CODE-消除" class="headerlink" title="DEAD CODE 消除"></a>DEAD CODE 消除</h3><p>因为每个变量都有“代”（因为大家都只被赋值一次），所以很容易检查出没有被使用的变量并且删除对应的定义。另外如果删除v=x这样的定义还要在x的use表中把这条语句删除。</p>
<h3 id="简单的常量扩展"><a href="#简单的常量扩展" class="headerlink" title="简单的常量扩展"></a>简单的常量扩展</h3><p>比如<code>v = φ(c1,c2,...,cn)</code>这种格式，如果c都是相等的可以直接替换成c，或者<code>v=c</code>，如果c是常量的话也可以直接替换掉。在做这些的同时也可以做其他的优化，能够在一趟遍历中都完成，比如<code>copy propagation</code>，<code>x=y</code>或者<code>x=φ(y)</code>都可以直接用y替换掉x。比如<code>constant folding</code>，<code>x=a+b</code>如果<code>a+b</code>是常量的话，可以直接用常量赋值。</p>
<p>当然还有其他的优化算法，出发点都是基于SSA的简单性。</p>
<h2 id="从SSA转换回原始代码"><a href="#从SSA转换回原始代码" class="headerlink" title="从SSA转换回原始代码"></a>从SSA转换回原始代码</h2><p><code>y = φ(x1, x2, x3)</code>这样的形式要根据条件分支再拆分回原来的形态，比如满足1条件，使用<code>y=x1</code>这样的形式。并且可能会很自然的想把x1和x2变回使用同一个寄存器，但是通过优化过程中的一些手段(copy propagation)已经把大部分move指令给优化掉了，并且重新推回x可能会有生命周期的影响，所以还是保留了“代”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个就是把def-use换成了use-def方便做代码优化呀：）害我看那么久</p>
<p>参考文献</p>
<ol>
<li> 虎书第十九章</li>
<li> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_single_assignment_form#Converting_to_SSA">维基百科</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2014 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ggaaooppeenngg</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"ggaaooppeenngg","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
