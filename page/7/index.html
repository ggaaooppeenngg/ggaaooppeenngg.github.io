<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_85tctgPWrqH2EPVuuD5IT6KE-tW8nH0hTISJDMnShg">
  <meta name="baidu-site-verification" content="bb16c5b1fd3302c18e0015bef11eea42">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ggaaooppeenngg.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:type" content="website">
<meta property="og:title" content="ggaaooppeenngg">
<meta property="og:url" content="https://ggaaooppeenngg.github.io/page/7/index.html">
<meta property="og:site_name" content="ggaaooppeenngg">
<meta property="og:description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ggaaooppeenngg">
<meta property="article:tag" content="ggaaooppeenngg,kernel,sysml,golang,python,rust">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ggaaooppeenngg.github.io/page/7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ggaaooppeenngg</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-62096626-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-62096626-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?bb16c5b1fd3302c18e0015bef11eea42"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ggaaooppeenngg</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">为什么计算机科学是无限的但生命是有限的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">136</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">14</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">80</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ggaaooppeenngg</p>
  <div class="site-description" itemprop="description">为什么计算机科学是无限的但生命是有限的</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">136</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ggaaooppeenngg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ggaaooppeenngg" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:peng.gao.dut@gmail.com" title="E-Mail → mailto:peng.gao.dut@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">什么是SSA以及SSA的作用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-01-22 01:14:50" itemprop="dateCreated datePublished" datetime="2017-01-22T01:14:50+08:00">2017-01-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2017/01/22/SSA是什么/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="SSA概述"><a href="#SSA概述" class="headerlink" title="SSA概述"></a>SSA概述</h2><p>SSA在Go1.7中被引入，这个特性对编译器的性能有很大的提高，但是也导致编译过程有些减速。下面来结合网上的资粮和书籍，简单说明一下SSA以及SSA的应用。</p>
<p>SSA 代表 static single-assignment，是一种IR(中间表示代码)，要保证每个变量只被赋值一次。这个能帮助简化编译器的优化算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y := 1</span><br><span class="line">y := 2</span><br><span class="line">x := y</span><br></pre></td></tr></table></figure>
<p>比如上面这段代码，<code>y = 1</code>其实是不可用的，这个要通过定义的可达分析来确定<code>y</code>是要用1还是2，而SSA有一个标识符可以称之为版本或者“代“。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y1 := 1</span><br><span class="line">y2 := 2</span><br><span class="line">x1 := y2</span><br></pre></td></tr></table></figure>
<p>这样就没有任何间接值了。用SSA表示的好处是对于同一个变量的无关使用表示成不同“代”，可以方便很多编译器的优化算法的实现。</p>
<p>一个概念:</p>
<p>Φ(读作fai) 函数，表示要根据控制流赋值的“代”。</p>
<p>例子可以参考维基里的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_single_assignment_form#Converting_to_SSA">这一段</a>。</p>
<p>三个定义：</p>
<p>A dominate B，如果从起点开始必须通过A到达B。也就是说A是到B的必经之路。</p>
<p>A strictly dominate B，如果 A dominate B，并且A和B不相等。</p>
<p>A 的 dominance frontier 含有B，如果A没有strictly dominate B，但是 dominate 了B的一个前驱节点。</p>
<p>用遍历的方式确定 dominance frontier 的伪代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for each node b</span><br><span class="line">    if the number of immediate predecessors of b ≥ 2</span><br><span class="line">        for each p in immediate predecessors of b</span><br><span class="line">            runner := p</span><br><span class="line">            while runner ≠ idom(b)</span><br><span class="line">                add b to runner’s dominance frontier set</span><br><span class="line">                runner := idom(runner)</span><br></pre></td></tr></table></figure>
<p>idom(b) 代表相邻的strictly dominate b的结点。这样的点只有一个，因为相邻的点有两个的话就不会是必经之路了。</p>
<img data-src="/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/example_1.jpg" class="">

<p>如图是一个例子，2的前驱是1和7，7没有sd(strictly dominate) 2，所以把2加入到7的DF(dominate frontiers)当中。3是7的相邻sd，然后3不是2的sd所以2加入到3的DF当中，接着2是3相邻的sd，然后2不是2的sd所以把2加入到2的DF中，最后遍历到7，5和6不是7的sd所以把7加入到5和6的df当中。</p>
<p>df(A)可以认为是可以通过A到达的，但不是必经之路的点的集合。</p>
<p>有了这个定义以后就可以插入Φ函数了和重命名了。如果X中有定义a那么所有df(X)都需要a的Φ函数。并且Φ函数本身也是一个定义。</p>
<p>比如还是同一个例子。</p>
<img data-src="/zh-CN/2017/01/22/SSA%E6%98%AF%E4%BB%80%E4%B9%88/example_2.jpg" class="">

<p>1当中有j的定义，但是df(1)是空的，5当中有j的定义，并且5的df有7所以7当中要插入一个φ(j, j)。j现在在7中定义了(通过φ函数）所以df(7)中的2也要有φ(j, j)，6也有j的定义但是7已经有了φ函数了，2的df有2，但是2已经有φ函数了。类似的方式可以应用到i和k。接着对定义重命名就可以完成SSA的转换了。</p>
<h2 id="SSA的应用"><a href="#SSA的应用" class="headerlink" title="SSA的应用"></a>SSA的应用</h2><p>上面只是通俗的解释了一下SSA，没有给出更多详细的理论和算法以及证明，因为证明实在难看懂，下面说一下SSA的应用。</p>
<h3 id="DEAD-CODE-消除"><a href="#DEAD-CODE-消除" class="headerlink" title="DEAD CODE 消除"></a>DEAD CODE 消除</h3><p>因为每个变量都有“代”（因为大家都只被赋值一次），所以很容易检查出没有被使用的变量并且删除对应的定义。另外如果删除v=x这样的定义还要在x的use表中把这条语句删除。</p>
<h3 id="简单的常量扩展"><a href="#简单的常量扩展" class="headerlink" title="简单的常量扩展"></a>简单的常量扩展</h3><p>比如<code>v = φ(c1,c2,...,cn)</code>这种格式，如果c都是相等的可以直接替换成c，或者<code>v=c</code>，如果c是常量的话也可以直接替换掉。在做这些的同时也可以做其他的优化，能够在一趟遍历中都完成，比如<code>copy propagation</code>，<code>x=y</code>或者<code>x=φ(y)</code>都可以直接用y替换掉x。比如<code>constant folding</code>，<code>x=a+b</code>如果<code>a+b</code>是常量的话，可以直接用常量赋值。</p>
<p>当然还有其他的优化算法，出发点都是基于SSA的简单性。</p>
<h2 id="从SSA转换回原始代码"><a href="#从SSA转换回原始代码" class="headerlink" title="从SSA转换回原始代码"></a>从SSA转换回原始代码</h2><p><code>y = φ(x1, x2, x3)</code>这样的形式要根据条件分支再拆分回原来的形态，比如满足1条件，使用<code>y=x1</code>这样的形式。并且可能会很自然的想把x1和x2变回使用同一个寄存器，但是通过优化过程中的一些手段(copy propagation)已经把大部分move指令给优化掉了，并且重新推回x可能会有生命周期的影响，所以还是保留了“代”。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个就是把def-use换成了use-def方便做代码优化呀：）害我看那么久</p>
<p>参考文献</p>
<ol>
<li> 虎书第十九章</li>
<li> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_single_assignment_form#Converting_to_SSA">维基百科</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/11/21/kernel-%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%93%BE%E8%B7%AF%E5%B1%82%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2016/11/21/kernel-%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%93%BE%E8%B7%AF%E5%B1%82%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">kernel-协议栈链路层分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-11-21 22:31:34" itemprop="dateCreated datePublished" datetime="2016-11-21T22:31:34+08:00">2016-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/11/21/kernel-%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%93%BE%E8%B7%AF%E5%B1%82%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/11/21/kernel-协议栈链路层分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本篇文章主要分析一下经过纯物理层之后从设备读取的frame是如何进入协议栈的和对应封装好的frame是如何离开协议栈的，多亏协议栈的分层思路，每一层之间都可以独立分析和阅读，对于驱动来说，首先要面对的就是中断了, 本文基于4.7.2的内核简单的过了一遍.</p>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>中断处理是分析链路层数据传输的入口。<br>例如在<code>drivers/net/ethernet/3com/3c59x.c</code>这个是一个华三的设备驱动, 观察这个驱动的中断处理函数可以知道，frame的接收的入口是<code>vortex_rx</code>，而当设备有足够的空间发送frame的时候就会调用<code>netif_wake_queue</code>来触发发送frame的例程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is the ISR for the vortex series chips.</span><br><span class="line"> * full_bus_master_tx == 0 &amp;&amp; full_bus_master_rx == 0</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">static irqreturn_t</span><br><span class="line">vortex_interrupt(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">	struct net_device *dev = dev_id;</span><br><span class="line">	struct vortex_private *vp = netdev_priv(dev);</span><br><span class="line">	void __iomem *ioaddr;</span><br><span class="line">	int status;</span><br><span class="line">	int work_done = max_interrupt_work;</span><br><span class="line">	int handled = 0;</span><br><span class="line">	unsigned int bytes_compl = 0, pkts_compl = 0;</span><br><span class="line"></span><br><span class="line">	ioaddr = vp-&gt;ioaddr;</span><br><span class="line">	spin_lock(&amp;vp-&gt;lock);</span><br><span class="line"></span><br><span class="line">	status = ioread16(ioaddr + EL3_STATUS); // 从ioremap的地址当中读取网卡的状态,这个是设备规定的地址</span><br><span class="line"></span><br><span class="line">	if (vortex_debug &gt; 6)</span><br><span class="line">		pr_debug(&quot;vortex_interrupt(). status=0x%4x\n&quot;, status);</span><br><span class="line"></span><br><span class="line">	// 在中断处理的时候,设备是关中断的,这个时候可以通过观察这个status来检查设备是否有中断到来.</span><br><span class="line">	if ((status &amp; IntLatch) == 0) // 有中断需要处理,但是可能已经被其他中断处理函数处理了</span><br><span class="line">		goto handler_exit;		/* No interrupt: shared IRQs cause this */</span><br><span class="line">	handled = 1;</span><br><span class="line"></span><br><span class="line">	if (status &amp; IntReq) &#123; // 中断请求</span><br><span class="line">		status |= vp-&gt;deferred;</span><br><span class="line">		vp-&gt;deferred = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (status == 0xffff)		/* h/w no longer present (hotplug)? */</span><br><span class="line">		goto handler_exit;</span><br><span class="line"></span><br><span class="line">	if (vortex_debug &gt; 4)</span><br><span class="line">		pr_debug(&quot;%s: interrupt, status %4.4x, latency %d ticks.\n&quot;,</span><br><span class="line">			   dev-&gt;name, status, ioread8(ioaddr + Timer));</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;vp-&gt;window_lock);</span><br><span class="line">	window_set(vp, 7);</span><br><span class="line"></span><br><span class="line">	do &#123;</span><br><span class="line">		if (vortex_debug &gt; 5)</span><br><span class="line">				pr_debug(&quot;%s: In interrupt loop, status %4.4x.\n&quot;,</span><br><span class="line">					   dev-&gt;name, status);</span><br><span class="line">		if (status &amp; RxComplete) // 中断表示接收完成的时候调用 vortex_rx</span><br><span class="line">			vortex_rx(dev);</span><br><span class="line"></span><br><span class="line">		if (status &amp; TxAvailable) &#123; // 中断表示可以传输的时候</span><br><span class="line">			if (vortex_debug &gt; 5)</span><br><span class="line">				pr_debug(&quot;	TX room bit was handled.\n&quot;);</span><br><span class="line">			/* There&#x27;s room in the FIFO for a full-sized packet. */</span><br><span class="line">			iowrite16(AckIntr | TxAvailable, ioaddr + EL3_CMD);</span><br><span class="line">			netif_wake_queue (dev);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (status &amp; DMADone) &#123;// 表示发送完成可以清除sk_buff了</span><br><span class="line">			if (ioread16(ioaddr + Wn7_MasterStatus) &amp; 0x1000) &#123;</span><br><span class="line">				iowrite16(0x1000, ioaddr + Wn7_MasterStatus); /* Ack the event. */</span><br><span class="line">				pci_unmap_single(VORTEX_PCI(vp), vp-&gt;tx_skb_dma, (vp-&gt;tx_skb-&gt;len + 3) &amp; ~3, PCI_DMA_TODEVICE);</span><br><span class="line">				pkts_compl++;</span><br><span class="line">				bytes_compl += vp-&gt;tx_skb-&gt;len;</span><br><span class="line">				dev_kfree_skb_irq(vp-&gt;tx_skb); /* Release the transferred buffer */</span><br><span class="line">				if (ioread16(ioaddr + TxFree) &gt; 1536) &#123;</span><br><span class="line">					/*</span><br><span class="line">					 * AKPM: FIXME: I don&#x27;t think we need this.  If the queue was stopped due to</span><br><span class="line">					 * insufficient FIFO room, the TxAvailable test will succeed and call</span><br><span class="line">					 * netif_wake_queue()</span><br><span class="line">					 */</span><br><span class="line">					netif_wake_queue(dev);</span><br><span class="line">				&#125; else &#123; /* Interrupt when FIFO has room for max-sized packet. */</span><br><span class="line">					iowrite16(SetTxThreshold + (1536&gt;&gt;2), ioaddr + EL3_CMD);</span><br><span class="line">					netif_stop_queue(dev);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		/* Check for all uncommon interrupts at once. */</span><br><span class="line">		if (status &amp; (HostError | RxEarly | StatsFull | TxComplete | IntReq)) &#123;</span><br><span class="line">			if (status == 0xffff)</span><br><span class="line">				break;</span><br><span class="line">			if (status &amp; RxEarly)</span><br><span class="line">				vortex_rx(dev);</span><br><span class="line">			spin_unlock(&amp;vp-&gt;window_lock);</span><br><span class="line">			vortex_error(dev, status);</span><br><span class="line">			spin_lock(&amp;vp-&gt;window_lock);</span><br><span class="line">			window_set(vp, 7);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (--work_done &lt; 0) &#123; // 最多处理work_done个frame</span><br><span class="line">			pr_warn(&quot;%s: Too much work in interrupt, status %4.4x\n&quot;,</span><br><span class="line">				dev-&gt;name, status);</span><br><span class="line">			/* Disable all pending interrupts. */</span><br><span class="line">			do &#123;</span><br><span class="line">				vp-&gt;deferred |= status; // 把当前状态保存起来等下次中断的时候处理</span><br><span class="line">				iowrite16(SetStatusEnb | (~vp-&gt;deferred &amp; vp-&gt;status_enable),</span><br><span class="line">					 ioaddr + EL3_CMD);</span><br><span class="line">				iowrite16(AckIntr | (vp-&gt;deferred &amp; 0x7ff), ioaddr + EL3_CMD);</span><br><span class="line">			&#125; while ((status = ioread16(ioaddr + EL3_CMD)) &amp; IntLatch); // 把中断清掉?</span><br><span class="line">			/* The timer will reenable interrupts. */</span><br><span class="line">			mod_timer(&amp;vp-&gt;timer, jiffies + 1*HZ);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		/* Acknowledge the IRQ. */</span><br><span class="line">		iowrite16(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);</span><br><span class="line">	&#125; while ((status = ioread16(ioaddr + EL3_STATUS)) &amp; (IntLatch | RxComplete));// 当有pending的中断并且是接收完成的状态</span><br><span class="line"></span><br><span class="line">	netdev_completed_queue(dev, pkts_compl, bytes_compl);</span><br><span class="line">	spin_unlock(&amp;vp-&gt;window_lock);</span><br><span class="line"></span><br><span class="line">	if (vortex_debug &gt; 4)</span><br><span class="line">		pr_debug(&quot;%s: exiting interrupt, status %4.4x.\n&quot;,</span><br><span class="line">			   dev-&gt;name, status);</span><br><span class="line">handler_exit:</span><br><span class="line">	spin_unlock(&amp;vp-&gt;lock);</span><br><span class="line">	return IRQ_RETVAL(handled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当中断到来的时候检查<code>RxComplete</code>，如果这个状态置位了说明有frame可以处理，当状态有<code>TxAvailable</code>的时候表示网卡的缓冲有空可以尝试发送frame，这样的检查会循环很多次，直到出现错误或者超过规定的循环次数<code>max_interrupt_work</code>，这个值对于这个设备来说是32，也就是说最多接受32帧就会退出中断处理。</p>
<h2 id="frame的接收"><a href="#frame的接收" class="headerlink" title="frame的接收"></a>frame的接收</h2><p><code>vortex_rx</code>最终会调用<code>netif_rx</code>这个函数很关键，<code>vortex_rx</code>会通过<code>netdev_alloc_skb</code>分配一个<code>sk_buff</code>，这个是一个会贯穿整个协议栈的一个buff，然后从设备中拷贝frame，拷贝的方式也有很多比如直接读取或者利用DMA。<br>从DMA读取到内存当中比如截取的这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 转换成总线地址给DMA设备,启动DMA传输,然后循环检查传输状态</span><br><span class="line">// 最后取消总线地址的映射.</span><br><span class="line">dma_addr_t dma = pci_map_single(VORTEX_PCI(vp), skb_put(skb, pkt_len),</span><br><span class="line">                                    pkt_len, PCI_DMA_FROMDEVICE);</span><br><span class="line">iowrite32(dma, ioaddr + Wn7_MasterAddr);</span><br><span class="line">iowrite16((skb-&gt;len + 3) &amp; ~3, ioaddr + Wn7_MasterLen);</span><br><span class="line">iowrite16(StartDMAUp, ioaddr + EL3_CMD);</span><br><span class="line">while (ioread16(ioaddr + Wn7_MasterStatus) &amp; 0x8000)</span><br><span class="line">                ;</span><br><span class="line">pci_unmap_single(VORTEX_PCI(vp), dma, pkt_len, PCI_DMA_FROMDEVICE);</span><br></pre></td></tr></table></figure>
<p>也有不饶过CPU直接读取的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ioread32_rep(ioaddr + RX_FIFO,</span><br><span class="line">             skb_put(skb, pkt_len),</span><br><span class="line">             (pkt_len + 3) &gt;&gt; 2);</span><br></pre></td></tr></table></figure>

<p>接着调用<code>eth_type_trans</code>确定对应的protocol，并且最终调用<code>netif_rx</code>来继续处理接收任务。</p>
<p>到了<code>netif_rx</code>就是一个通用流程了，<code>netif_rx</code>调用了<code>netif_rx_internal</code>，这个函数会先通过<code>net_timestamp_check</code>检查<code>sk_buff</code>的时间戳，并且设置，然后调用<code>enqueue_to_backlog</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * enqueue_to_backlog is called to queue an skb to a per CPU backlog</span><br><span class="line"> * queue (may be a remote CPU queue).</span><br><span class="line"> */</span><br><span class="line">static int enqueue_to_backlog(struct sk_buff *skb, int cpu,</span><br><span class="line">                              unsigned int *qtail)</span><br><span class="line">&#123;</span><br><span class="line">        struct softnet_data *sd;</span><br><span class="line">        unsigned long flags;</span><br><span class="line">        unsigned int qlen;</span><br><span class="line"></span><br><span class="line">        sd = &amp;per_cpu(softnet_data, cpu); // 获取per-cpu softnet_data</span><br><span class="line"></span><br><span class="line">        local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">        rps_lock(sd);</span><br><span class="line">        if (!netif_running(skb-&gt;dev)) // 如果设备已经没有运行的直接丢frame</span><br><span class="line">                goto drop;</span><br><span class="line">        qlen = skb_queue_len(&amp;sd-&gt;input_pkt_queue); // 获取softnet_data的&amp;sk_buff的队列长度</span><br><span class="line">        if (qlen &lt;= netdev_max_backlog &amp;&amp; !skb_flow_limit(skb, qlen)) &#123; // 如果没有超过最大长度并且没有被限制</span><br><span class="line">                if (qlen) &#123;</span><br><span class="line">enqueue:</span><br><span class="line">                        __skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb);</span><br><span class="line">                        input_queue_tail_incr_save(sd, qtail);</span><br><span class="line">                        rps_unlock(sd);</span><br><span class="line">                        local_irq_restore(flags); // 加入队列并且开中断</span><br><span class="line">                        return NET_RX_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果队列为空可以尝试调度 backlog device，</span><br><span class="line">                // 再把frame加入到队列当中。</span><br><span class="line">                /* Schedule NAPI for backlog device</span><br><span class="line">                 * We can use non atomic operation since we own the queue lock</span><br><span class="line">                 */</span><br><span class="line">                if (!__test_and_set_bit(NAPI_STATE_SCHED, &amp;sd-&gt;backlog.state)) &#123;</span><br><span class="line">                        if (!rps_ipi_queued(sd))</span><br><span class="line">                                ____napi_schedule(sd, &amp;sd-&gt;backlog);</span><br><span class="line">                &#125;</span><br><span class="line">                goto enqueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">drop:</span><br><span class="line">        sd-&gt;dropped++;</span><br><span class="line">        rps_unlock(sd);</span><br><span class="line"></span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">        atomic_long_inc(&amp;skb-&gt;dev-&gt;rx_dropped);</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        return NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入到<code>____napi_schedule</code>则很简单了，就是唤起把<code>backlog</code>这个<code>softnet_data</code>上的device加入到<code>poll_list</code>当中然后唤起softirq来处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Called with irq disabled */</span><br><span class="line">static inline void ____napi_schedule(struct softnet_data *sd,</span><br><span class="line">                                     struct napi_struct *napi)</span><br><span class="line">&#123;</span><br><span class="line">        list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br><span class="line">        __raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要提的是，kernel对于frame的处理有一个比较新的API，称之为NAPI。</p>
<p>对于NAPI来说, <code>net_rx_action</code>结合了轮询和中断, 当设备有中断表示收到frame的时候会把它加入<code>softnet_data</code>的 <code>poll_list</code>, 这个时候设备不再发出中断，然后通过轮询这些设备是否有剩余frame处理，并且限制最大处理数量，这样能保证cpu不会承受过大的中断load的压力，并且可以使得设备之间能够相对公平获得处理的机会,而不是中断更频繁的设备获得的机会更多。</p>
<p>对于使用NAPI的设备来说显然需要提供poll接口来供查询之用，同时用<code>NET_RX_SOFTIRQ</code>触发软中断执行<code>net_rx_action</code>这个软中断处理函数，而不需要<code>netif_rx</code>这个接口。</p>
<p><code>NET_RX_SOFTIRQ</code>做的事情就是把设备加入<code>poll</code>列表并且触发softirq. 对于没有使用NAPI的设备来说，会使用per-cpu 结构<code>softnet_data</code>中的<code>backlog_dev</code>(是一个假的胶水层的封装)来替代放入对应的<code>poll</code>列表中，然后再进入<code>netif_rx_schedule</code>的例程来处理。也就是说NAPI-unaware的设备用的是<code>backlog_dev</code>而NAPI-aware的设备用的是自己的device结构体。</p>
<p>相反的把设备从轮询列表中移除依靠的是<code>netif_rx_complete</code>. 这样轮询检查的时候就不会处理对应的设备了.</p>
<p>这里说了这么久的轮询不要误会frame的主力是轮询，显然这是不行的，因为网络数据要求接受很快，还是中断驱动的，只不过为了物尽其用，既然你有数据帧还在就不要中断告诉我，我继续处理就可以了。</p>
<p>现在看一下加入到<code>poll_list</code>之后，<code>NET_RX_SOFTIRQ</code>软中断是如何工作的。关于软中断的实现可以参考参考列表中的第二个链接，我本来想自己总结一下，但是发现这篇文章确实总结的很好，所以保存一下就好了。</p>
<p>补充一点，<code>softnet_data-&gt;input_pkt_queue</code>是frame的缓存队列，这个队列有一个最大值<code>netdev_max_backlog</code>，目前这个值是1000，也就是每个CPU最多有1000个frame没处理。对于有自己device的设备，frame需要通过设备的<code>poll</code>方法来获取。</p>
<p><code>net_rx_action</code>对应的是软中断<code>NET_RX_SOFTIRQ</code>的处理函数。之前说过<code>net_rx_action</code>的工作方式，这里看一下具体的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static void net_rx_action(struct softirq_action *h)</span><br><span class="line">&#123;</span><br><span class="line">        struct softnet_data *sd = this_cpu_ptr(&amp;softnet_data);</span><br><span class="line">        unsigned long time_limit = jiffies + 2;</span><br><span class="line">        int budget = netdev_budget; // 一个budget用于限制运行时间，目前是300</span><br><span class="line">        LIST_HEAD(list);</span><br><span class="line">        LIST_HEAD(repoll);</span><br><span class="line"></span><br><span class="line">        local_irq_disable();</span><br><span class="line">        list_splice_init(&amp;sd-&gt;poll_list, &amp;list); // 把poll_list合并到list上并且把poll_list清空</span><br><span class="line">        local_irq_enable();</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">                struct napi_struct *n;</span><br><span class="line"></span><br><span class="line">                if (list_empty(&amp;list)) &#123;</span><br><span class="line">                        if (!sd_has_rps_ipi_waiting(sd) &amp;&amp; list_empty(&amp;repoll))</span><br><span class="line">                                return;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                n = list_first_entry(&amp;list, struct napi_struct, poll_list);</span><br><span class="line">                budget -= napi_poll(n, &amp;repoll); // 每调用一次会减掉相应的budget，如果还有work没完成还需要poll就会加入到repoll链表里。</span><br><span class="line"></span><br><span class="line">                /* If softirq window is exhausted then punt.</span><br><span class="line">                 * Allow this to run for 2 jiffies since which will allow</span><br><span class="line">                 * an average latency of 1.5/HZ.</span><br><span class="line">                 */</span><br><span class="line">                if (unlikely(budget &lt;= 0 || // 如果budge耗尽或者超过了两个jiffies就会停止</span><br><span class="line">                             time_after_eq(jiffies, time_limit))) &#123;</span><br><span class="line">                        sd-&gt;time_squeeze++;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __kfree_skb_flush();</span><br><span class="line">        local_irq_disable();</span><br><span class="line"></span><br><span class="line">        list_splice_tail_init(&amp;sd-&gt;poll_list, &amp;list); // 再把poll_list合并到list当中,并且清空poll_list。</span><br><span class="line">        list_splice_tail(&amp;repoll, &amp;list); // 然后把repoll合并到list当中。</span><br><span class="line">        list_splice(&amp;list, &amp;sd-&gt;poll_list); // 再把list合并到poll_list当中。</span><br><span class="line">        if (!list_empty(&amp;sd-&gt;poll_list)) // 这几步的过程就是把需要repoll的设备和当前的poll_list合并</span><br><span class="line">                __raise_softirq_irqoff(NET_RX_SOFTIRQ); // 如果还有需要poll的设备就再触发软中断.</span><br><span class="line"></span><br><span class="line">        net_rps_action_and_irq_enable(sd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个过程就是检查<code>poll_list</code>并且轮询调用<code>poll</code>方法。接下来具体看一下<code>poll</code>方法的相关内容。以非NAPI设备为例，使用的是<code>backlog</code>的<code>poll</code>方法，对应的方法可以在<code>net/core/dev.c</code>当中找到，在初始化函数<code>net_dev_init</code>当中<code>sd-&gt;backlog.poll = process_backlog;</code>给每个per-cpu结构的<code>softnet_data</code>都是指向了这个poll函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static int process_backlog(struct napi_struct *napi, int quota)</span><br><span class="line">&#123;</span><br><span class="line">        int work = 0;</span><br><span class="line">        struct softnet_data *sd = container_of(napi, struct softnet_data, backlog);</span><br><span class="line"></span><br><span class="line">        /* Check if we have pending ipi, its better to send them now,</span><br><span class="line">         * not waiting net_rx_action() end.</span><br><span class="line">         */</span><br><span class="line">        if (sd_has_rps_ipi_waiting(sd)) &#123;</span><br><span class="line">                local_irq_disable();</span><br><span class="line">                net_rps_action_and_irq_enable(sd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        napi-&gt;weight = weight_p; // 这个值目前是32</span><br><span class="line">        local_irq_disable();</span><br><span class="line">        while (1) &#123;</span><br><span class="line">                struct sk_buff *skb;</span><br><span class="line"></span><br><span class="line">                while ((skb = __skb_dequeue(&amp;sd-&gt;process_queue))) &#123;</span><br><span class="line">                        rcu_read_lock();</span><br><span class="line">                        local_irq_enable();</span><br><span class="line">                        __netif_receive_skb(skb); // 取出的skb交给__netif_receive_skb处理</span><br><span class="line">                        rcu_read_unlock();</span><br><span class="line">                        local_irq_disable();</span><br><span class="line">                        input_queue_head_incr(sd);</span><br><span class="line">                        if (++work &gt;= quota) &#123;</span><br><span class="line">                                local_irq_enable();</span><br><span class="line">                                return work;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rps_lock(sd);</span><br><span class="line">                if (skb_queue_empty(&amp;sd-&gt;input_pkt_queue)) &#123;</span><br><span class="line">                        /*</span><br><span class="line">                         * Inline a custom version of __napi_complete().</span><br><span class="line">                         * only current cpu owns and manipulates this napi,</span><br><span class="line">                         * and NAPI_STATE_SCHED is the only possible flag set</span><br><span class="line">                         * on backlog.</span><br><span class="line">                         * We can use a plain write instead of clear_bit(),</span><br><span class="line">                         * and we dont need an smp_mb() memory barrier.</span><br><span class="line">                         */</span><br><span class="line">                        napi-&gt;state = 0;</span><br><span class="line">                        rps_unlock(sd);</span><br><span class="line"></span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                skb_queue_splice_tail_init(&amp;sd-&gt;input_pkt_queue,</span><br><span class="line">                                           &amp;sd-&gt;process_queue);</span><br><span class="line">                rps_unlock(sd);</span><br><span class="line">        &#125;</span><br><span class="line">        local_irq_enable();</span><br><span class="line"></span><br><span class="line">        return work;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的主体就是把<code>&amp;sd-&gt;input_pkt_queue</code>交给<code>&amp;sd-&gt;process_queue</code>然后从<code>&amp;sd-&gt;process_queue</code>当中取出<code>sk_buff</code>，再调用<code>__netif_receive_skb</code>，进一步处理.我想老是把<code>&amp;sd-&gt;input_pkt_queue</code>拷贝并且清空应该是因为希望不因为锁独占这个队列太久的原因.</p>
<p><code>__netif_receive_skb</code>的内容主要是根据<code>skb-&gt;protocol</code>，遍历<code>&amp;skb-&gt;dev-&gt;ptype_all</code>然后将frame交给L3的<code>ptype-&gt;func</code>处理，还有一些在这一层需要处理的特性，比如bridging.</p>
<p>目前说描述的东西就是整个传输路径的这部分，完整的图在<a target="_blank" rel="noopener" href="https://wiki.linuxfoundation.org/images/1/1c/Network_data_flow_through_kernel.png">这里</a></p>
<img data-src="/zh-CN/2016/11/21/kernel-%E5%8D%8F%E8%AE%AE%E6%A0%88%E9%93%BE%E8%B7%AF%E5%B1%82%E5%88%86%E6%9E%90/l2_recv.png" class="">

<h2 id="frame的发送"><a href="#frame的发送" class="headerlink" title="frame的发送"></a>frame的发送</h2><p>在frame的发送路径，主要包含几个任务，开关设备的发送功能，调度设备进行发送，选择在设备发送队列的frame进行发送，还要传输过程的本身.而且发送的例程也是类似接收的过程，有对应的softirq(<code>NET_TX_SOFTIRQ</code>)和对应的handler，<code>net_tx_action</code>。和<code>poll_list</code>对应的是<code>output_queue</code>，也是一个等待发送的设备列表。<br><code>__LINK_STATE_START</code> 和 <code>__LINK_ STATE_XOFF</code>，<code>__LINK_STATE_RX_SCHED</code>和<code>__LINK_STATE_SCHED</code>也是对应的.回顾开头中断的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (status &amp; TxAvailable) &#123; // 中断表示可以传输的时候</span><br><span class="line">	if (vortex_debug &gt; 5)</span><br><span class="line">		pr_debug(&quot;	TX room bit was handled.\n&quot;);</span><br><span class="line">	/* There&#x27;s room in the FIFO for a full-sized packet. */</span><br><span class="line">	iowrite16(AckIntr | TxAvailable, ioaddr + EL3_CMD);</span><br><span class="line">	netif_wake_queue (dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是说当状态可用的时候，尝试调用<code>netif_wake_queue</code>来触发frame的发送。</p>
<p>首先来看一下如何选择发送的设备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *      netif_wake_queue - restart transmit</span><br><span class="line"> *      @dev: network device</span><br><span class="line"> *</span><br><span class="line"> *      Allow upper layers to call the device hard_start_xmit routine.</span><br><span class="line"> *      Used for flow control when transmit resources are available.</span><br><span class="line"> */</span><br><span class="line">static inline void netif_wake_queue(struct net_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">        netif_tx_wake_queue(netdev_get_tx_queue(dev, 0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数内部调用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static inline void __netif_reschedule(struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">        struct softnet_data *sd;</span><br><span class="line">        unsigned long flags;</span><br><span class="line"></span><br><span class="line">        local_irq_save(flags);</span><br><span class="line">        sd = this_cpu_ptr(&amp;softnet_data);</span><br><span class="line">        q-&gt;next_sched = NULL;</span><br><span class="line">        *sd-&gt;output_queue_tailp = q;</span><br><span class="line">        sd-&gt;output_queue_tailp = &amp;q-&gt;next_sched;</span><br><span class="line">        raise_softirq_irqoff(NET_TX_SOFTIRQ);</span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主体就是把设备加入<code>output_queue</code>(通过<code>-&gt;next_sched</code>连接)然后唤起软中断<code>NET_TX_SOFTIRQ</code>。</p>
<p>再来看看软中断的主体。<br>首先是遍历<code>completion_queue</code>来释放<code>sk_buff</code>这个连接是通过<code>dev_kfree_skb_irq</code>添加的,和正常的<code>dev_kfree_skb</code>不同，它是把<code>sk_buff</code>加入到释放列表中就快速返回了, 然后就会遍历设备列表寻找可运行的设备，调用<code>qdisk_run</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> void net_tx_action(struct softirq_action *h)</span><br><span class="line">&#123;</span><br><span class="line">        struct softnet_data *sd = this_cpu_ptr(&amp;softnet_data);</span><br><span class="line"></span><br><span class="line">        if (sd-&gt;completion_queue) &#123; // 检查completion_queue逐一释放sk_buff, 他们是通过dev_kfree_skb_irq,因为他不真的释放sk_buff,而是把sk_buff移到completio_queue当中.</span><br><span class="line">                struct sk_buff *clist;</span><br><span class="line"></span><br><span class="line">                local_irq_disable();</span><br><span class="line">                clist = sd-&gt;completion_queue;</span><br><span class="line">                sd-&gt;completion_queue = NULL;</span><br><span class="line">                local_irq_enable();</span><br><span class="line"></span><br><span class="line">                while (clist) &#123;</span><br><span class="line">                        struct sk_buff *skb = clist;</span><br><span class="line">                        clist = clist-&gt;next;</span><br><span class="line"></span><br><span class="line">                        WARN_ON(atomic_read(&amp;skb-&gt;users));</span><br><span class="line">                        if (likely(get_kfree_skb_cb(skb)-&gt;reason == SKB_REASON_CONSUMED))</span><br><span class="line">                                trace_consume_skb(skb);</span><br><span class="line">                        else</span><br><span class="line">                                trace_kfree_skb(skb, net_tx_action);</span><br><span class="line"></span><br><span class="line">                        if (skb-&gt;fclone != SKB_FCLONE_UNAVAILABLE)</span><br><span class="line">                                __kfree_skb(skb);</span><br><span class="line">                        else</span><br><span class="line">                                __kfree_skb_defer(skb);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                __kfree_skb_flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (sd-&gt;output_queue) &#123;</span><br><span class="line">                struct Qdisc *head;</span><br><span class="line"></span><br><span class="line">                local_irq_disable();</span><br><span class="line">                head = sd-&gt;output_queue; // 拷贝并首尾相连.</span><br><span class="line">                sd-&gt;output_queue = NULL;</span><br><span class="line">                sd-&gt;output_queue_tailp = &amp;sd-&gt;output_queue;</span><br><span class="line">                local_irq_enable();</span><br><span class="line"></span><br><span class="line">                while (head) &#123;</span><br><span class="line">                        struct Qdisc *q = head;</span><br><span class="line">                        spinlock_t *root_lock;</span><br><span class="line"></span><br><span class="line">                        head = head-&gt;next_sched;</span><br><span class="line"></span><br><span class="line">                        root_lock = qdisc_lock(q);</span><br><span class="line">                        if (spin_trylock(root_lock)) &#123;</span><br><span class="line">                                smp_mb__before_atomic();</span><br><span class="line">                                clear_bit(__QDISC_STATE_SCHED,</span><br><span class="line">                                          &amp;q-&gt;state);</span><br><span class="line">                                qdisc_run(q); // qdisk_run</span><br><span class="line">                                spin_unlock(root_lock);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                if (!test_bit(__QDISC_STATE_DEACTIVATED,</span><br><span class="line">                                              &amp;q-&gt;state)) &#123;</span><br><span class="line">                                        __netif_reschedule(q);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                        smp_mb__before_atomic();</span><br><span class="line">                                        clear_bit(__QDISC_STATE_SCHED,</span><br><span class="line">                                                  &amp;q-&gt;state);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>qdisc_run</code>首先检查设备的运行状态然后调用<code>__qdisc_run</code>，这个函数的主体就是调用<code>qdisc_restart</code>,直到超过限制或者需要让出时间CPU了,最后清空qdisc的RUNNING状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void __qdisc_run(struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">        int quota = weight_p;</span><br><span class="line">        int packets;</span><br><span class="line"></span><br><span class="line">        while (qdisc_restart(q, &amp;packets)) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * Ordered by possible occurrence: Postpone processing if</span><br><span class="line">                 * 1. we&#x27;ve exceeded packet quota</span><br><span class="line">                 * 2. another process needs the CPU;</span><br><span class="line">                 */</span><br><span class="line">                quota -= packets;</span><br><span class="line">                if (quota &lt;= 0 || need_resched()) &#123;</span><br><span class="line">                        __netif_schedule(q);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qdisc_run_end(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而<code>qdisc_restart</code>的主体是从队列中取出<code>sk_buff</code>，然后调用<code>sch_direct_xmit</code>，它的功能是调用<code>dev_hard_start_xmit</code>来运行设备驱动的指定的传输方法<code>hard_start_xmit</code>，如果没有成功则把<code>sk_buff</code>重新加入到出队当中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Transmit possibly several skbs, and handle the return status as</span><br><span class="line"> * required. Holding the __QDISC___STATE_RUNNING bit guarantees that</span><br><span class="line"> * only one CPU can execute this function.</span><br><span class="line"> *</span><br><span class="line"> * Returns to the caller:</span><br><span class="line"> *                              0  - queue is empty or throttled.</span><br><span class="line"> *                              &gt;0 - queue is not empty.</span><br><span class="line"> */</span><br><span class="line">int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,</span><br><span class="line">                    struct net_device *dev, struct netdev_queue *txq,</span><br><span class="line">                    spinlock_t *root_lock, bool validate)</span><br><span class="line">&#123;</span><br><span class="line">        int ret = NETDEV_TX_BUSY;</span><br><span class="line"></span><br><span class="line">        /* And release qdisc */</span><br><span class="line">        spin_unlock(root_lock);</span><br><span class="line"></span><br><span class="line">        /* Note that we validate skb (GSO, checksum, ...) outside of locks */</span><br><span class="line">        if (validate)</span><br><span class="line">                skb = validate_xmit_skb_list(skb, dev);</span><br><span class="line"></span><br><span class="line">        if (likely(skb)) &#123;</span><br><span class="line">                HARD_TX_LOCK(dev, txq, smp_processor_id());</span><br><span class="line">                if (!netif_xmit_frozen_or_stopped(txq))</span><br><span class="line">                        skb = dev_hard_start_xmit(skb, dev, txq, &amp;ret);</span><br><span class="line"></span><br><span class="line">                HARD_TX_UNLOCK(dev, txq);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                spin_lock(root_lock);</span><br><span class="line">                return qdisc_qlen(q);</span><br><span class="line">        &#125;</span><br><span class="line">        spin_lock(root_lock);</span><br><span class="line"></span><br><span class="line">        if (dev_xmit_complete(ret)) &#123;</span><br><span class="line">                /* Driver sent out skb successfully or skb was consumed */</span><br><span class="line">                ret = qdisc_qlen(q);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                /* Driver returned NETDEV_TX_BUSY - requeue skb */</span><br><span class="line">                if (unlikely(ret != NETDEV_TX_BUSY))</span><br><span class="line">                        net_warn_ratelimited(&quot;BUG %s code %d qlen %d\n&quot;,</span><br><span class="line">                                             dev-&gt;name, ret, q-&gt;q.qlen);</span><br><span class="line"></span><br><span class="line">                ret = dev_requeue_skb(skb, q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ret &amp;&amp; netif_xmit_frozen_or_stopped(txq))</span><br><span class="line">                ret = 0;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此整个L2的发送和接收就大致有了一个了解，并且能够理解整个的工作过程，这里有一点没有讲到的是L2的转发机制，比如STP等协议和实现，可能会在接下来的文章中继续剖析.</p>
<p>参考:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/zqixiao_09/article/details/51089088">Linux 下DMA浅析</a></li>
<li><a target="_blank" rel="noopener" href="http://www.wowotech.net/irq_subsystem/soft-irq.html">linux kernel的中断子系统之（八）：softirq</a></li>
<li><a target="_blank" rel="noopener" href="http://pdf.th7.cn/down/files/1312/understanding_linux_network_internals.pdf">Linux Network Internals</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/09/07/golang-context%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2016/09/07/golang-context%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">golang-context使用方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-07 22:51:39" itemprop="dateCreated datePublished" datetime="2016-09-07T22:51:39+08:00">2016-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/09/07/golang-context%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/09/07/golang-context使用方式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>经常提到的context都是一些在一个http请求的不同中间件之间传递参数和返回值的上下文. 标准库里的上下文稍微丰富一点, 比如流水线模型都会有一个通知退出的channel, 也一并封装进了Context, 所以既有传值功能也有流程控制的功能.</p>
<p>一般会把Context作为函数的第一个参数传递下去, 比如Context可以保存一个Request的id, 在打log的时候带上, 这样就可以区分出输出中同一个request的调用情况. 或者子函数select 传入的Context.Done channel用于在流水线中退出的通知等等.</p>
<p>Context接口有四个方法, 并且线程安全.</p>
<p><code>Done</code> 是一个channel用于通知退出事件, 当从这个channel里读出的时候说明Context结束.<br><code>Err</code> 返回退出的原因.<br><code>Deadline</code> 返回一个截止时间(如果设置了的话).<br><code>Value</code> 可以取得Context里面存得值.</p>
<p>Context的实现有4种, cancelCtx, emptyCtx, timerCtx, valueCtx.</p>
<p>valueCtx只是最简单的Ctx用来存k-v, 这类似于中间件之间传递各种值的功能, 没有Done, Err, Deadline这些方法, 是组合父Context得到的.</p>
<p>cancelCtx是一个带取消功能的Ctx, 返回一个cancel函数, 可以通过调用它主动取消这个Ctx, 比如错误退出的时候, 可以调用cancel函数, 他会同时调用子Ctx的cancel函数, 以此来让Context的Done起作用, cancelCtx是树形的, 有Done, Err, 但是没有Deadline, 组合了父结构获得的.</p>
<p>timerCtx是一个cancelCtx的封装, 由timer调用cancel函数, 并且不会超过parent的Deadline(不然就退化成cancelCtx由parent触发cancel), 有Deadline, 其余部分是组合了cancelCtx.</p>
<p>Context.WithCancel就是绑定一个parent, 返回一个cancelCtx的Context, 用返回的CancelFunc可以用来主动关闭Context, 比如程序错误的时候可以调用CancelFunc来让select Done的goroutine知道.</p>
<p>Context.WithTimer是对Context.WithDeadline的封装, Context.WithDeadline返回的是timerCtx.</p>
<p>Context.WithValue则仅仅是用来存值的Context.</p>
<p>WithXXX的函数都是要接受一个parent的, 最初的parent就用Context.Background().<br>它是一种emptyCtx, Err, Done(nil channel永远阻塞), Deadline, Value全都返回空值, 没有实际作用只是作为树形结构的root.</p>
<p>另一种emptyCtx是context.TODO(), 用于没有明确作用的不知道父Context会是什么的时候可以使用.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/09/05/vmalloc-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2016/09/05/vmalloc-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D/" class="post-title-link" itemprop="url">vmalloc-非连续内存的分配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-09-05 00:07:50" itemprop="dateCreated datePublished" datetime="2016-09-05T00:07:50+08:00">2016-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/09/05/vmalloc-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/09/05/vmalloc-非连续内存的分配/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h2><p>为了解决外部碎片的问题, 需要有一种手段可以分配非连续的页映射到一段连续的虚拟地址上. 这就是vmalloc的目的, 本文基于4.7.2的代码对<code>vmalloc</code>的实现进行分析.</p>
<p>这里要提到一个重要的结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct vm_struct &#123;</span><br><span class="line">	struct vm_struct	*next;</span><br><span class="line">	void			*addr;</span><br><span class="line">	unsigned long		size;</span><br><span class="line">	unsigned long		flags;</span><br><span class="line">	struct page		**pages;</span><br><span class="line">	unsigned int		nr_pages;</span><br><span class="line">	phys_addr_t		phys_addr;</span><br><span class="line">	const void		*caller;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个结构用于描述每一段映射的内存.</p>
<p>比起32位的结构, 64位结构有更大的寻址空间, 可以通过查看<code>Documentation/x86/x86_64/mm.txt</code> 获得64位的内存映射, 比起32位的变化就是跨度变大了很多.</p>
<p>直接映射是64TB, 有一个1TB的空洞, 接着就是32TB的vmalloc空间,以<code>VMALLOC_START(64TB+1TB)</code>开始,<code>VMALLOC_END(64TB+1TB+32TB)</code>结尾.</p>
<p>原来的32位时, 内核的虚拟空间只有1G, 直接映射的区间占896MB, 隔了一个8MB的空洞,   再接着是vmalloc的映射区, 大小一般是128MB.</p>
<p>vmalloc和物理映射的空洞主要是一个安全区, 如果越过了这个hole说明程序有问题存在非法的访问.</p>
<p><code>vm_struct</code>的组织是通过链表实现的,<br>其中<code>next</code>指向下一个<code>vm_struct</code>, <code>addr</code>指向的是虚拟地址, <code>size</code>对应分配的内存的大小,在有guard page(也就是flag的<code>VM_NO_GUARD</code>没有设置的话)的时候会多出一个PAGE_SIZE的大小(但没有映射内存), <code>pages</code>是页的地址, <code>nr_pages</code>是页的数量, <code>phy_addr</code>这个字段一般为0,当用于ioremap的时候会用到, <code>caller</code>是调用者的地址.</p>
<p>上面说了, 每个<code>vm_struct</code>代表的区间之间会有一PAGE_SIZE大小的分隔,也是为了能够方便检查非法越界的情况.</p>
<p>这是32位的一张分布图, 整体结构没变, 就是64位的区间变大了.</p>
<img data-src="/zh-CN/2016/09/05/vmalloc-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D/memory.jpeg" class=""> 

<p><code>vmap_area</code>用于代表虚拟地址的区间, 和vm_struct是有对应关系的.<br>list 是按地址排序存的线性链表节点.<br>rb_node 是按地址存的红黑树节点.<br>这两个值都是在插入的时候修改的.<br>也就是为了方便搜索,它既存在红黑树上也存在链表里面.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct vmap_area &#123;</span><br><span class="line">	unsigned long va_start;</span><br><span class="line">	unsigned long va_end;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	struct rb_node rb_node;         /* address sorted rbtree */</span><br><span class="line">	struct list_head list;          /* address sorted list */</span><br><span class="line">	struct llist_node purge_list;    /* &quot;lazy purge&quot; list */</span><br><span class="line">	struct vm_struct *vm;</span><br><span class="line">	struct rcu_head rcu_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="vmap-area-虚拟地址的管理"><a href="#vmap-area-虚拟地址的管理" class="headerlink" title="vmap_area 虚拟地址的管理"></a>vmap_area 虚拟地址的管理</h2><p>接下了说一下调用过程, 首先<code>vmalloc</code>会调用<code>__vmalloc_node_flags</code>,这是一层封装,指定了GFP的flag, 接着调用<code>__vmalloc_node</code>,它通过指定搜寻的区域(<code>VMALLOC_START</code>,<code>VMALLOC_END</code>)调用了<code>__vmalloc_node_range</code>, 然后通过<code>__get_vm_area_node</code>寻找合适的虚拟内存空间,并且分配<code>vm_struct</code>,最后调用<code>__vmalloc_area_node</code>根据<code>vm_struct</code>分配具体的物理页并在页表中建立虚拟地址的映射.</p>
<p><code>__get_vm_area_node</code> 对<code>size</code>进行对齐, 分配<code>vmap_area</code>的内存, 然后增加一个<code>PAGE_SIZE</code>的guard page, 接着就是寻找一段合适的虚拟地址的区间来分配给<code>vmap_area</code>并且用它来初始化<code>vm_struct</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static struct vm_struct *__get_vm_area_node(unsigned long size,</span><br><span class="line">		unsigned long align, unsigned long flags, unsigned long start,</span><br><span class="line">		unsigned long end, int node, gfp_t gfp_mask, const void *caller)</span><br><span class="line">&#123;</span><br><span class="line">	struct vmap_area *va;</span><br><span class="line">	struct vm_struct *area;</span><br><span class="line"></span><br><span class="line">	BUG_ON(in_interrupt());</span><br><span class="line">	if (flags &amp; VM_IOREMAP)</span><br><span class="line">		align = 1ul &lt;&lt; clamp_t(int, fls_long(size),</span><br><span class="line">				       PAGE_SHIFT, IOREMAP_MAX_ORDER);</span><br><span class="line"></span><br><span class="line">	size = PAGE_ALIGN(size);</span><br><span class="line">	if (unlikely(!size))</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	/* 分配vm_struct</span><br><span class="line">	 * 并且初始化全0</span><br><span class="line">	 */</span><br><span class="line">	area = kzalloc_node(sizeof(*area), gfp_mask &amp; GFP_RECLAIM_MASK, node);</span><br><span class="line">	if (unlikely(!area))</span><br><span class="line">		return NULL;</span><br><span class="line">    /* 如果没有标记，size要多算一个guard page用于分隔 */</span><br><span class="line">	if (!(flags &amp; VM_NO_GUARD))</span><br><span class="line">		size += PAGE_SIZE;</span><br><span class="line">	/* 分配vmap_area */</span><br><span class="line">	va = alloc_vmap_area(size, align, start, end, node, gfp_mask);</span><br><span class="line">	if (IS_ERR(va)) &#123;</span><br><span class="line">		kfree(area);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 初始化 */</span><br><span class="line">	setup_vmalloc_vm(area, va, flags, caller);</span><br><span class="line"></span><br><span class="line">	return area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>alloc_vmap_area</code>会缓存上次一次搜索的节点到<code>free_vmap_cache</code>, 这样是认为一般虚拟内存是按顺序连续分配的, 如果通过缓存没有搜索到就要从全局的<code>vmap_area_root</code>开始搜索.</p>
<p>这里说明一下<code>vmap_area</code>的分配过程, 主要是在红黑树中根据所指定的区间寻找合适的点,如果找到一个区间正好包含了<code>vstart</code>,那么在这个区间链表后面寻找合适的空洞进行分配就可以, 也有可能在红黑书上找到的就是空洞就不用接着遍历了, 总之搜索的过程是先红黑书然后再链表.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Allocate a region of KVA of the specified size and alignment, within the</span><br><span class="line"> * vstart and vend.</span><br><span class="line"> */</span><br><span class="line">static struct vmap_area *alloc_vmap_area(unsigned long size,</span><br><span class="line">				unsigned long align,</span><br><span class="line">				unsigned long vstart, unsigned long vend,</span><br><span class="line">				int node, gfp_t gfp_mask)</span><br><span class="line">&#123;</span><br><span class="line">	struct vmap_area *va;</span><br><span class="line">	struct rb_node *n;</span><br><span class="line">	unsigned long addr;</span><br><span class="line">	int purged = 0;</span><br><span class="line">	struct vmap_area *first;</span><br><span class="line"></span><br><span class="line">	BUG_ON(!size);</span><br><span class="line">	BUG_ON(offset_in_page(size));</span><br><span class="line">	BUG_ON(!is_power_of_2(align));</span><br><span class="line"></span><br><span class="line">	might_sleep_if(gfpflags_allow_blocking(gfp_mask));</span><br><span class="line"></span><br><span class="line">	va = kmalloc_node(sizeof(struct vmap_area),</span><br><span class="line">			gfp_mask &amp; GFP_RECLAIM_MASK, node);</span><br><span class="line">	if (unlikely(!va))</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Only scan the relevant parts containing pointers to other objects</span><br><span class="line">	 * to avoid false negatives.</span><br><span class="line">	 */</span><br><span class="line">	kmemleak_scan_area(&amp;va-&gt;rb_node, SIZE_MAX, gfp_mask &amp; GFP_RECLAIM_MASK);</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	spin_lock(&amp;vmap_area_lock);</span><br><span class="line">	/*</span><br><span class="line">	 * Invalidate cache if we have more permissive parameters.</span><br><span class="line">	 * cached_hole_size notes the largest hole noticed _below_</span><br><span class="line">	 * the vmap_area cached in free_vmap_cache: if size fits</span><br><span class="line">	 * into that hole, we want to scan from vstart to reuse</span><br><span class="line">	 * the hole instead of allocating above free_vmap_cache.</span><br><span class="line">	 * Note that __free_vmap_area may update free_vmap_cache</span><br><span class="line">	 * without updating cached_hole_size or cached_align.</span><br><span class="line">	 */</span><br><span class="line">	if (!free_vmap_cache || /* 缓存为空, 并且在下面条件满足的时候不使用缓存 */</span><br><span class="line">			size &lt; cached_hole_size || /* 至少有一个空洞可以复用, 直接从头开始搜索 */</span><br><span class="line">			vstart &lt; cached_vstart || /* 别缓存的起点小 */</span><br><span class="line">			align &lt; cached_align) &#123; /* 对齐大小比缓存的小 */</span><br><span class="line">nocache:</span><br><span class="line">		cached_hole_size = 0;</span><br><span class="line">		free_vmap_cache = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	/* record if we encounter less permissive parameters */</span><br><span class="line">	cached_vstart = vstart;</span><br><span class="line">	cached_align = align;</span><br><span class="line"></span><br><span class="line">	/* find starting point for our search */</span><br><span class="line">	if (free_vmap_cache) &#123; /* 这个地方是用缓存上次搜索的结果, 每次找到以后会存到这里 */</span><br><span class="line">		first = rb_entry(free_vmap_cache, struct vmap_area, rb_node);</span><br><span class="line">		addr = ALIGN(first-&gt;va_end, align);</span><br><span class="line">		if (addr &lt; vstart) /* 缓存的末尾对齐之后超出了范围从头开始搜索 */</span><br><span class="line">			goto nocache;</span><br><span class="line">		if (addr + size &lt; addr) /* 整数溢出 */</span><br><span class="line">			goto overflow;</span><br><span class="line"></span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		addr = ALIGN(vstart, align);</span><br><span class="line">		if (addr + size &lt; addr)</span><br><span class="line">			goto overflow;</span><br><span class="line"></span><br><span class="line">		n = vmap_area_root.rb_node;</span><br><span class="line">		first = NULL;</span><br><span class="line"></span><br><span class="line">		while (n) &#123; /* 用对齐之后的vstart正好&lt;=va_ned&amp;&amp;&gt;=va_start的节点 */</span><br><span class="line">			struct vmap_area *tmp;</span><br><span class="line">			tmp = rb_entry(n, struct vmap_area, rb_node);</span><br><span class="line">			if (tmp-&gt;va_end &gt;= addr) &#123;</span><br><span class="line">				first = tmp;</span><br><span class="line">				if (tmp-&gt;va_start &lt;= addr)</span><br><span class="line">					break;</span><br><span class="line">				n = n-&gt;rb_left;</span><br><span class="line">			&#125; else</span><br><span class="line">				n = n-&gt;rb_right;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!first)</span><br><span class="line">			goto found;</span><br><span class="line">	&#125;</span><br><span class="line">	/* from the starting point, walk areas until a suitable hole is found */</span><br><span class="line">	while (addr + size &gt; first-&gt;va_start &amp;&amp; addr + size &lt;= vend) &#123;</span><br><span class="line">		if (addr + cached_hole_size &lt; first-&gt;va_start) /* cached_hole_size */</span><br><span class="line">			cached_hole_size = first-&gt;va_start - addr; /* 缓存最大的空洞大小 */</span><br><span class="line">		addr = ALIGN(first-&gt;va_end, align);</span><br><span class="line">		if (addr + size &lt; addr)</span><br><span class="line">			goto overflow;</span><br><span class="line"></span><br><span class="line">		if (list_is_last(&amp;first-&gt;list, &amp;vmap_area_list))</span><br><span class="line">			goto found;</span><br><span class="line"></span><br><span class="line">		first = list_next_entry(first, list);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">	if (addr + size &gt; vend)</span><br><span class="line">		goto overflow;</span><br><span class="line"></span><br><span class="line">	va-&gt;va_start = addr;</span><br><span class="line">	va-&gt;va_end = addr + size;</span><br><span class="line">	va-&gt;flags = 0;</span><br><span class="line">	__insert_vmap_area(va); /* 插入到红黑书和链表当中 */</span><br><span class="line">	free_vmap_cache = &amp;va-&gt;rb_node;</span><br><span class="line">	spin_unlock(&amp;vmap_area_lock);</span><br><span class="line"></span><br><span class="line">	BUG_ON(!IS_ALIGNED(va-&gt;va_start, align));</span><br><span class="line">	BUG_ON(va-&gt;va_start &lt; vstart);</span><br><span class="line">	BUG_ON(va-&gt;va_end &gt; vend);</span><br><span class="line"></span><br><span class="line">	return va;</span><br><span class="line"></span><br><span class="line">overflow:</span><br><span class="line">	spin_unlock(&amp;vmap_area_lock);</span><br><span class="line">	if (!purged) &#123;</span><br><span class="line">		purge_vmap_area_lazy();</span><br><span class="line">		purged = 1;</span><br><span class="line">		goto retry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (gfpflags_allow_blocking(gfp_mask)) &#123;</span><br><span class="line">		unsigned long freed = 0;</span><br><span class="line">		blocking_notifier_call_chain(&amp;vmap_notify_list, 0, &amp;freed);</span><br><span class="line">		if (freed &gt; 0) &#123;</span><br><span class="line">			purged = 0;</span><br><span class="line">			goto retry;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (printk_ratelimit())</span><br><span class="line">		pr_warn(&quot;vmap allocation for size %lu failed: use vmalloc=&lt;size&gt; to increase size\n&quot;,</span><br><span class="line">			size);</span><br><span class="line">	kfree(va);</span><br><span class="line">	return ERR_PTR(-EBUSY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="建立映射"><a href="#建立映射" class="headerlink" title="建立映射"></a>建立映射</h2><p>成功分配好<code>vm_struct</code>之后就可以建立映射了.<br><code>__vmalloc_area_node</code>的过程首先是分配物理页,调用<code>alloc_kmem_pages</code>,这个函数和<code>alloc_pages</code>不同的是套了一层cgroup的kmem计数器,来限制内存分配, 然后再调用<code>map_vm_area</code>在页表上建立映射,内部调用的是<code>vmap_page_range</code>,指定了<code>vm_struct</code>的start和end, 而<code>vmap_page_range</code>则调用了<code>vmap_page_range_noflush</code>迭代去初始化各级页表. 内核的虚拟地址的映射就全部完成了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *</span><br><span class="line"> * Set up page tables in kva (addr, end). The ptes shall have prot &quot;prot&quot;, and</span><br><span class="line"> * will have pfns corresponding to the &quot;pages&quot; array.</span><br><span class="line"> * 这里的kva指的是kernel virtual address.</span><br><span class="line"> * Ie. pte at addr+N*PAGE_SIZE shall point to pfn corresponding to pages[N]</span><br><span class="line"> */</span><br><span class="line">static int vmap_page_range_noflush(unsigned long start, unsigned long end,</span><br><span class="line">				   pgprot_t prot, struct page **pages)</span><br><span class="line">&#123;</span><br><span class="line">	pgd_t *pgd;</span><br><span class="line">	unsigned long next;</span><br><span class="line">	unsigned long addr = start;</span><br><span class="line">	int err = 0;</span><br><span class="line">	int nr = 0;</span><br><span class="line"></span><br><span class="line">	BUG_ON(addr &gt;= end);</span><br><span class="line">	pgd = pgd_offset_k(addr); /* 把虚拟地址hash到pgd */</span><br><span class="line">	do &#123;</span><br><span class="line">		next = pgd_addr_end(addr, end); /* 获取下一个pgd */</span><br><span class="line">		err = vmap_pud_range(pgd, addr, next, prot, pages, &amp;nr); /* 再去初始化 pud pmd pte */</span><br><span class="line">		if (err)</span><br><span class="line">			return err;</span><br><span class="line">	&#125; while (pgd++, addr = next, addr != end);</span><br><span class="line"></span><br><span class="line">	return nr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应的调用关系如图.</p>
<img data-src="/zh-CN/2016/09/05/vmalloc-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D/vmalloc-callgraph.png" class="">

<h2 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h2><p>释放的入口是<code>vfree</code>, 这个函数首先通过<code>in_interrupt</code>检查是否在中断上下文, 如果是正处于中断中则使用<code>workqueue</code>传入<code>vfree_deferred</code>用workqueue进行释放, 不然就直接调用<code>__vunmap</code>来释放, 它会调用<code>remove_vm_area</code>, 最终调用用<code>unmap_vmap_area</code>重置页表, 然后用<code>free_vmap_area_noflush</code>把<code>vmp_area</code>加入到<code>vmap_purge_list</code>这个链表当中, 放入这个链表之后只有链表长度超过阈值才会尝试调用<code>try_purge_vmap_area_lazy</code>真正释放掉<code>vmap_area</code>,释放过程主要是从红黑树中移除, 然后把自己也给free掉, 这是一个延迟的释放过程, 最后把把<code>vm_struct</code>自己和它管理的物理页全部释放. 调用图如图所示.</p>
<img data-src="/zh-CN/2016/09/05/vmalloc-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D/vfree-callgraph.png" class="">


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>vmalloc主要是针对连续地址分配的需求, 涉及两个部分, 一个是虚拟地址的管理以及到物理地址的映射. 其中虚拟地址的管理比较麻烦一点, 用链表红黑树保存了每个<code>vmap_area</code>并且寻找合适的<code>空洞</code>用于分配虚拟地址. 而物理地址的分配之前我的博客已经讲过了, 建立映射只要设置对应的页表项就OK了.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p> <a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-25845340-id-3251137.html">《LINUX3.0内核源代码分析》第四章: 内存管理</a></p>
</li>
<li><p> <a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-20786208-id-4888173.html">linux内存管理之vmalloc</a></p>
</li>
<li><p> <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/gorman/html/understand/understand010.html">lkvm</a></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">buddy-system-内核物理页管理的实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-08-31 02:20:53" itemprop="dateCreated datePublished" datetime="2016-08-31T02:20:53+08:00">2016-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/08/31/buddy-system-内核物理页分配的实现/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>很多人看内核物理页的分配都喜欢从<code>__alloc_pages</code>开始看，喜欢从程序的执行流程去看问题，其实可换个思路，从开发或者说实现的角度去理解物理页的分配效果可能更好，所以这篇博客，反其道而行之，基于4.7.2的内核代码, 由内向外解释物理页的分配过程的细节.</p>
<h2 id="binary-buddy-system-allocation-算法"><a href="#binary-buddy-system-allocation-算法" class="headerlink" title="binary buddy system allocation 算法"></a>binary buddy system allocation 算法</h2><p>伙伴分配器算法的流程如下:</p>
<ol>
<li>如果内存被分配<ol>
<li>寻找一个合适大小的内存(要求是: 大于 requested memory, 同时以\(2^k\)为量纲最小的块,　也就是分配一个满足要求的最小块)<ol start="2">
<li> 如果找到了直接分配</li>
<li>如果没有找到, 需要进行如下尝试<ol>
<li> 拆分一个比 requested memory 更大的内存块(比如比之前没找到的\(2^x\)大的\(2^{x+1}\), 分成两半.</li>
<li> 如果拆分出来的一半满足requested memory, 并且不能再分了, 已经是最小的了, 就分配该块.</li>
<li> 重复1, 寻找合适大小的内存块.</li>
<li> 重复这个流程直到找到合适的内存块.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如果内存被释放<ol>
<li> 释放\(2^k\)内存块</li>
<li> 查看内存块的伙伴也就是分配之后的另一半\(2^k\)块是否也free了</li>
<li> 如果是，则会回到2并且重复执行直到所有内存被释放或者有一个伙伴没有被free掉, 无法合并.</li>
</ol>
</li>
</ol>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p>内存碎片有两种，一种是External fragmentation和Internal Fragmentation, 前者是因为内存块划分的太小而无法满足大的内存分配的需要, 在这点上内核遇到的大内存块分配其实并不多, 而且通过<code>vmalloc</code>把不连续的物理地址映射成连续的虚拟地址很好的解决了这个问题. 后者的解决方法是引入了<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/">slab allocator</a>, 对小内存进行了有效的缓存, 避免了Internal fragmentation的情况.</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>每个<code>struct zone</code>结构有一个<code>struct free_area        free_area[MAX_ORDER];</code>的定义, 对应的结构如下.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct free_area &#123;</span><br><span class="line">	struct list_head	free_list[MIGRATE_TYPES];</span><br><span class="line">	unsigned long		nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以整个的空闲块的管理结构如图.</p>
<img data-src="/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/buddy-system-free.png" class="">
<p>每一个free_area用来存储一种\(2^k\)块,用链表链接,<code>MAX_ORDER</code>表示的允许最大的块就是\(2^{MAX_ORDER}\)大小.</p>
<h3 id="migratetype"><a href="#migratetype" class="headerlink" title="migratetype"></a>migratetype</h3><p>图中省略了<code>MIGRATE_TYPES</code>的表示, 仔细观察<code>free_list</code>是一个数组每个代表了一种migratetype, 用于page分配从node之间迁移的,  让内存尽量分配在离CPU近的node上, 这个特性是在2.6.32.25引入的, 同时对外部碎片的现象进行了优化, 这一点是这么理解的, 外部碎片是因为小内存块的分配位置可能占据了某个地方, 导致大的内存块无法分配出来, 比如说如果这个页是一些内核的永久数据可能这个碎片就会一直存在, 但是我们提前从可移动页分配一大块内存来给不可移动页, 那么内存碎片就不会影响到可移动页的分配, 这样就不会让内核初始化的时候分配的一些永久性的内存导致碎片影响了其他内存的分配,下面我们看看迁移类型的具体定义.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * PAGE_ALLOC_COSTLY_ORDER is the order at which allocations are deemed</span><br><span class="line"> * costly to service.  That is between allocation orders which should</span><br><span class="line"> * coalesce naturally under reasonable reclaim pressure and those which</span><br><span class="line"> * will not.</span><br><span class="line"> */</span><br><span class="line"> /* 内核认为超过8个页算是大的内存分配 */</span><br><span class="line">#define PAGE_ALLOC_COSTLY_ORDER 3</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">	MIGRATE_UNMOVABLE,</span><br><span class="line">	MIGRATE_MOVABLE,</span><br><span class="line">	MIGRATE_RECLAIMABLE,</span><br><span class="line">	MIGRATE_PCPTYPES,	/* the number of types on the pcp lists */</span><br><span class="line">	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line">#ifdef CONFIG_CMA</span><br><span class="line">	/*</span><br><span class="line">	 * MIGRATE_CMA migration type is designed to mimic the way</span><br><span class="line">	 * ZONE_MOVABLE works.  Only movable pages can be allocated</span><br><span class="line">	 * from MIGRATE_CMA pageblocks and page allocator never</span><br><span class="line">	 * implicitly change migration type of MIGRATE_CMA pageblock.</span><br><span class="line">	 *</span><br><span class="line">	 * The way to use it is to change migratetype of a range of</span><br><span class="line">	 * pageblocks to MIGRATE_CMA which can be done by</span><br><span class="line">	 * __free_pageblock_cma() function.  What is important though</span><br><span class="line">	 * is that a range of pageblocks must be aligned to</span><br><span class="line">	 * MAX_ORDER_NR_PAGES should biggest page be bigger then</span><br><span class="line">	 * a single pageblock.</span><br><span class="line">	 */</span><br><span class="line">	MIGRATE_CMA,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_MEMORY_ISOLATION</span><br><span class="line">	MIGRATE_ISOLATE,	/* can&#x27;t allocate from here */</span><br><span class="line">#endif</span><br><span class="line">	MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里简单解释一下:</p>
<ol>
<li>MIGRATE_UNMOVABLE<pre><code> 这种类型的页的位置是固定不变的, 不可以移动, 内核中大部分数据是这样的.
</code></pre>
</li>
<li>MIGRATE_MOVABLE<pre><code> 不能够直接移动,但是可以删除,而内容则可以从某些源重新生成.如文件数据映射的页面则归属此类.
</code></pre>
</li>
<li>MIGRATE_RECLAIMABLE<pre><code> 可以移动。分配给用户态程序运行的用户空间页面则为该类.由于是通过页面映射而得,将其复制到新位置后,更新映射表项,重新映射,应用程序是不感知的.
</code></pre>
</li>
<li>MIGRATE_PCPTYPES<pre><code> 是一个分界数,小于这个数的都是在pcplist上的.
</code></pre>
</li>
<li>MIGRATE_CMA      <pre><code> 连续内存分配，用于避免预留大块内存导致系统可用内存减少而实现的，即当驱动不使用内存时，将其分配给用户使用，而需要时则通过回收或者迁移的方式将内存腾出来。
</code></pre>
</li>
<li>MIGRATE_ISOLATE<pre><code> 表示NUMA不能夸node迁移page, 让cpu和节点之间保持亲和性.
</code></pre>
</li>
<li>MIGRATE_TYPES<pre><code> 分界数, 低于这个才是迁移类型.
</code></pre>
</li>
</ol>
<h3 id="实现概要"><a href="#实现概要" class="headerlink" title="实现概要"></a>实现概要</h3><p>实际上的合并对应的是通过小块合并成大块从下级的<code>free_area</code>的链表中移除, 然后添加到上一层<code>free_area</code>当中. 拆分则相反, 从上级<code>free_area</code>当中删除大块, 并且拆分成两个小块, 加入到下层<code>free_area</code>的list当中, 当然, 如果有一块符合需求就直接分配了. 这就是整个物理页分配的核心内容.</p>
<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>整个算法的入口是<code>__rmqueue</code>, 从伙伴分配器中分配对应\( 2^{order} \) 的物理块.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Do the hard work of removing an element from the buddy allocator.</span><br><span class="line"> * Call me with the zone-&gt;lock already held.</span><br><span class="line"> */</span><br><span class="line">static struct page *__rmqueue(struct zone *zone, unsigned int order,</span><br><span class="line">				int migratetype)</span><br><span class="line">&#123;</span><br><span class="line">	struct page *page;</span><br><span class="line"></span><br><span class="line">	page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line">	if (unlikely(!page)) &#123;</span><br><span class="line">		if (migratetype == MIGRATE_MOVABLE)</span><br><span class="line">			page = __rmqueue_cma_fallback(zone, order); /* MOVABLE的失败优先从cma迁移 */</span><br><span class="line"></span><br><span class="line">		if (!page)</span><br><span class="line">			page = __rmqueue_fallback(zone, order, migratetype); /* 失败的话会从其他备选迁移类型当中迁移page */</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">	return page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分配失败退化的行为在后面讨论,先看主要路径, 算法主要体现在<code>__rmqueue_smallest</code>这个函数上, 依次从order开始向上寻找free_area并从list当中取出page块.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Go through the free lists for the given migratetype and remove</span><br><span class="line"> * the smallest available page from the freelists</span><br><span class="line"> */</span><br><span class="line">static inline</span><br><span class="line">struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,</span><br><span class="line">						int migratetype)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int current_order;</span><br><span class="line">	struct free_area *area;</span><br><span class="line">	struct page *page;</span><br><span class="line"></span><br><span class="line">	/* Find a page of the appropriate size in the preferred list */</span><br><span class="line">	for (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		page = list_first_entry_or_null(&amp;area-&gt;free_list[migratetype],</span><br><span class="line">							struct page, lru);</span><br><span class="line">		if (!page)</span><br><span class="line">			continue; /* 如果失败就尝试更大的块 */</span><br><span class="line">		list_del(&amp;page-&gt;lru); /* 这个lru取决他的上下文，比如在这里就是free_list */</span><br><span class="line">		rmv_page_order(page); /* 设置flags */</span><br><span class="line">		area-&gt;nr_free--; /* free计数器-1 */</span><br><span class="line">		expand(zone, page, order, current_order, area, migratetype);</span><br><span class="line">		set_pcppage_migratetype(page, migratetype);/* 设置page的migratetype */</span><br><span class="line">		return page;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从下往上找到合适的块以后再从上往下进行拆分, 这依赖于<code>expand</code>函数完成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The order of subdivision here is critical for the IO subsystem.</span><br><span class="line"> * Please do not alter this order without good reasons and regression</span><br><span class="line"> * testing. Specifically, as large blocks of memory are subdivided,</span><br><span class="line"> * the order in which smaller blocks are delivered depends on the order</span><br><span class="line"> * they&#x27;re subdivided in this function. This is the primary factor</span><br><span class="line"> * influencing the order in which pages are delivered to the IO</span><br><span class="line"> * subsystem according to empirical testing, and this is also justified</span><br><span class="line"> * by considering the behavior of a buddy system containing a single</span><br><span class="line"> * large block of memory acted on by a series of small allocations.</span><br><span class="line"> * This behavior is a critical factor in sglist merging&#x27;s success.</span><br><span class="line"> *</span><br><span class="line"> * -- nyc</span><br><span class="line"> */</span><br><span class="line">static inline void expand(struct zone *zone, struct page *page,</span><br><span class="line">	int low, int high, struct free_area *area,</span><br><span class="line">	int migratetype)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long size = 1 &lt;&lt; high;</span><br><span class="line"></span><br><span class="line">	while (high &gt; low) &#123; /* 从高阶向低阶迭代 */</span><br><span class="line">		area--;</span><br><span class="line">		high--;</span><br><span class="line">		size &gt;&gt;= 1;</span><br><span class="line">		VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line">        /* guardpage TODO */</span><br><span class="line">		if (IS_ENABLED(CONFIG_DEBUG_PAGEALLOC) &amp;&amp;</span><br><span class="line">			debug_guardpage_enabled() &amp;&amp;</span><br><span class="line">			high &lt; debug_guardpage_minorder()) &#123;</span><br><span class="line">			/*</span><br><span class="line">			 * Mark as guard pages (or page), that will allow to</span><br><span class="line">			 * merge back to allocator when buddy will be freed.</span><br><span class="line">			 * Corresponding page table entries will not be touched,</span><br><span class="line">			 * pages will stay not present in virtual address space</span><br><span class="line">			 */</span><br><span class="line">			set_page_guard(zone, &amp;page[size], high, migratetype);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		list_add(&amp;page[size].lru, &amp;area-&gt;free_list[migratetype]); /* 把page放到area的free_list里面, 这个page是一个数组形式的 比如之前是8 这里变成4,那么后半部分会被留下来，前半部分会继续用于迭代 */</span><br><span class="line">		area-&gt;nr_free++; /* 空闲块计数器+1 */</span><br><span class="line">		set_page_order(&amp;page[size], high); /* 相当于page-&gt;private = high 表示自己属于order为high的阶的block中 */</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>expand 就是向下一层的free_area留一半, 然后接着用另一半进行迭代.</p>
<p>举个例子说明分配的过程:</p>
<p>假设当前需要从<code>zone</code>当中分配一个order为1的page,   就会从下往上找到一个可以分配的块.</p>
<img data-src="/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/buddy-alloc-1.png" class="">
<p>从1开始迭代到2, 发现2有可以分配的\(2^3\)page, 然后进入expand, 进行拆分.</p>
<img data-src="/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/buddy-alloc-2.png" class="">

<p>拆分以后一半用于分配一半进入了同一层的free_list当中,如图所示,  核心流程非常简洁明了.</p>
<p>现在再重新回到<code>__rmqueue</code>,分析这个函数后半部分的fallback行为是如何迁移的.<br>首先如果编译选项带了CMA就会有具体内容, 其实就是再尝试从MIGRATE_CMA当中再分配一次page.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_CMA</span><br><span class="line">static struct page *__rmqueue_cma_fallback(struct zone *zone,</span><br><span class="line">					unsigned int order)</span><br><span class="line">&#123;</span><br><span class="line">	return __rmqueue_smallest(zone, order, MIGRATE_CMA);</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">static inline struct page *__rmqueue_cma_fallback(struct zone *zone,</span><br><span class="line">					unsigned int order) &#123; return NULL; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后是一般性的退化流程是<code>__rmqueue_fallback</code>这个函数.<br>说这个函数之前需要看一张表.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This array describes the order lists are fallen back to when</span><br><span class="line"> * the free lists for the desirable migrate type are depleted</span><br><span class="line"> */</span><br><span class="line">static int fallbacks[MIGRATE_TYPES][4] = &#123;</span><br><span class="line">	[MIGRATE_UNMOVABLE]   = &#123; MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES &#125;,</span><br><span class="line">	[MIGRATE_RECLAIMABLE] = &#123; MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES &#125;,</span><br><span class="line">	[MIGRATE_MOVABLE]     = &#123; MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES &#125;,</span><br><span class="line">#ifdef CONFIG_CMA</span><br><span class="line">	[MIGRATE_CMA]         = &#123; MIGRATE_TYPES &#125;, /* Never used */</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_MEMORY_ISOLATION</span><br><span class="line">	[MIGRATE_ISOLATE]     = &#123; MIGRATE_TYPES &#125;, /* Never used */</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这张表描述的是当一种类型无法满足时退化选择的迁移类型的一个顺序.接下来看函数的实现.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* Remove an element from the buddy allocator from the fallback list */</span><br><span class="line">static inline struct page *</span><br><span class="line">__rmqueue_fallback(struct zone *zone, unsigned int order, int start_migratetype)</span><br><span class="line">&#123;</span><br><span class="line">	struct free_area *area;</span><br><span class="line">	unsigned int current_order;</span><br><span class="line">	struct page *page;</span><br><span class="line">	int fallback_mt;</span><br><span class="line">	bool can_steal;</span><br><span class="line"></span><br><span class="line">	/* Find the largest possible block of pages in the other list */</span><br><span class="line">	for (current_order = MAX_ORDER-1;</span><br><span class="line">				current_order &gt;= order &amp;&amp; current_order &lt;= MAX_ORDER-1;</span><br><span class="line">				--current_order) &#123;</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		/* 遍历fallback table 找到合适的fallback migratetype 要综合考虑: 是否有超过一定阈值的空闲页,并且是可以退化的页类型 */</span><br><span class="line">		fallback_mt = find_suitable_fallback(area, current_order,</span><br><span class="line">				start_migratetype, false, &amp;can_steal);</span><br><span class="line">		if (fallback_mt == -1)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		page = list_first_entry(&amp;area-&gt;free_list[fallback_mt],</span><br><span class="line">						struct page, lru);</span><br><span class="line">		/* 从对应迁类型中&quot;偷取&quot;page TODO:具体如何迁移的 我感觉应该是很抽象的迁移就可以了 */</span><br><span class="line">		if (can_steal)</span><br><span class="line">			steal_suitable_fallback(zone, page, start_migratetype);</span><br><span class="line"></span><br><span class="line">		/* Remove the page from the freelists */</span><br><span class="line">		area-&gt;nr_free--;</span><br><span class="line">		list_del(&amp;page-&gt;lru);</span><br><span class="line">		rmv_page_order(page);</span><br><span class="line"></span><br><span class="line">		expand(zone, page, order, current_order, area,</span><br><span class="line">					start_migratetype);</span><br><span class="line">		/*</span><br><span class="line">		 * The pcppage_migratetype may differ from pageblock&#x27;s</span><br><span class="line">		 * migratetype depending on the decisions in</span><br><span class="line">		 * find_suitable_fallback(). This is OK as long as it does not</span><br><span class="line">		 * differ for MIGRATE_CMA pageblocks. Those can be used as</span><br><span class="line">		 * fallback only via special __rmqueue_cma_fallback() function</span><br><span class="line">		 */</span><br><span class="line">		set_pcppage_migratetype(page, start_migratetype);</span><br><span class="line"></span><br><span class="line">		trace_mm_page_alloc_extfrag(page, order, current_order,</span><br><span class="line">			start_migratetype, fallback_mt);</span><br><span class="line"></span><br><span class="line">		return page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和主要分配路径不同的事, 迭代器是从最大的阶数开始迭代的,这个代表的意思是说我尽量多迁移一点空间给你, 不然你还要迁移的时候我又分配一小块空间给你, 你的碎片间接导致了我的碎片产生, 所以从大到小开始迭代.</p>
<p>整个核心部分分析完以后, 按照从里向外分析的思路,这是基于<code>__rmqueu</code>的一套更高层次的函数, 再倒回来看alloc_pages的实现会发现非常容易理解.首先<code>__alloc_pages</code>调用<code>__alloc_pages_nodemask</code>. 这里补充一个结构体.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Structure for holding the mostly immutable allocation parameters passed</span><br><span class="line"> * between functions involved in allocations, including the alloc_pages*</span><br><span class="line"> * family of functions.</span><br><span class="line"> *</span><br><span class="line"> * nodemask, migratetype and high_zoneidx are initialized only once in</span><br><span class="line"> * __alloc_pages_nodemask() and then never change.</span><br><span class="line"> *</span><br><span class="line"> * zonelist, preferred_zone and classzone_idx are set first in</span><br><span class="line"> * __alloc_pages_nodemask() for the fast path, and might be later changed</span><br><span class="line"> * in __alloc_pages_slowpath(). All other functions pass the whole strucure</span><br><span class="line"> * by a const pointer.</span><br><span class="line"> */</span><br><span class="line">struct alloc_context &#123;</span><br><span class="line">	struct zonelist *zonelist;</span><br><span class="line">	nodemask_t *nodemask;</span><br><span class="line">	struct zoneref *preferred_zoneref;</span><br><span class="line">	int migratetype;</span><br><span class="line">	enum zone_type high_zoneidx;</span><br><span class="line">	bool spread_dirty_pages;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个结构体主要是一些内存分配的参数, 因为从上到下的调用都一直有用到这几个参数所以合成一个<code>context</code>向下传递.</p>
<p><code>__alloc_pages_nodemask</code>第一步会检查<code>cpusets</code>的功能是否打开, 这个是一个<code>cgroup</code>的子模块, 如果没有设置<code>nodemask</code>就会用<code>cpusets</code>配置的<code>cpuset_current_mems_allowed</code>来限制在哪个node上分配, 这个也是在NUMA结构当中才会有用的. 之后会用到<code>might_sleep_if</code>,判断<code>gfp_mask &amp; __GFP_DIRECT_RECLAIM)</code>, 表示当前内存压力比较大需要直接回收内存, 会循环睡眠同步等待页可用, 而<code>might_sleep_if</code>是一个debug函数,标记当前函数在<code>if</code>为<code>true</code>的时候表示可能会进入睡眠, 如果当前调用进入了一个不可睡眠的上下文就会报错. <code>should_fail_alloc_page</code>会做一些预检查, 一些无法分配的条件会直接报错.<br>接着获取<code>read_mems_allowed_begin</code>,这个会拿到<code>current</code>当前进程的cpusets允许的节点分配掩码, 这个结果的读取通过顺序锁(<code>seqcount_t</code>)进行, 如果在分配page期间这个值发生了改变(通过<code>read_mems_allowed_retry</code>判断), 那么读操作需要重新进行尝试.<br>调用<code>first_zones_zonelist</code>会从<code>zonelist</code>这个表示分配page的zone的优先顺序链表里获取第一个<code>zoneref</code>, <code>zoneref</code>是一个链表节点用于迭代之后的<code>zone</code>选项.<br>接着就会调用关键函数<code>get_page_from_freelist</code>从而分配到页.<br>分配完页如果失败会调用<code>__alloc_pages_slowpath</code>唤起<code>swapd</code>进程进行页回收从而获取可用的页, 再尝试调用<code>get_page_from_free_list</code>.<br>函数的调用图如下.</p>
<img data-src="/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/callgraph__alloc_pages.png" class="">

<p>这是最外层的一个过程, 但是内核往往经过了很多实践才会有这么一套机制, 内核在这一层之前加了一套缓存, 来加速物理页的分配,  <code>get_page_from_free_list</code>到伙伴分配器之间还有一层高速缓存. 这个结构是一个percpu结构, 每个cpu独有一份链表缓存分配的页,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct per_cpu_pages &#123;</span><br><span class="line">	int count;		/* number of pages in the list */</span><br><span class="line">	int high;		/* high watermark, emptying needed */</span><br><span class="line">	int batch;		/* chunk size for buddy add/remove */</span><br><span class="line"></span><br><span class="line">	/* Lists of pages, one per migrate type stored on the pcp-lists */</span><br><span class="line">	struct list_head lists[MIGRATE_PCPTYPES];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct per_cpu_pageset &#123;</span><br><span class="line">	struct per_cpu_pages pcp;</span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">	s8 expire;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">	s8 stat_threshold;</span><br><span class="line">	s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个zone都会有一个这个结构用于缓存页的分配, 中文一般就叫高速缓存.</p>
<p>缓存的过程是这样的, 首先通过<code>for_next_zone_zonelist_nodemask</code>遍历每个zone 会选择合适的zone, 选择合适的zone一笔带过但其实考虑了很多因素比如是否满足分配的wartermark, 是否需要均衡到别的zone当中, 是否被cpusets禁止了分配等等, 然后调用<code>buffered_rmqueue</code>这个函数, 这个函数就是构建对buddy分配器裹了一层高速缓存. 这个函数在只分配1页(order=0)的情况下,会判断是不是”冷”页, <code>    bool cold = ((gfp_flags &amp; __GFP_COLD) != 0)</code>, 冷页的区别是会放到高速缓存的末尾, 相反热页会放到高速缓存的头部. 然后尝试获取高速缓存的page, 如果高速缓存为空就调用<code>rmqueue_bulk</code>分配一段<code>batch</code>大小的页块到高速缓存中继续尝试分配, 而<code>rmqueue_bulk</code>就是循环了<code>batch</code>次分配了order=0的page逐个添加到高速缓存当中. 如果需要分配的order不为0的话还是会直接从buddy-system当中分配不依靠高速缓存. 高速缓存主要是缓存单页的分配.</p>
<p>所以调整后的走高速缓存的主流程就如下图所示.</p>
<img data-src="/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/callgraph__alloc_pages-2.png" class="">


<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>还是从伙伴系统的最内部实现向外说, 释放对应的是<code>__free_one_page</code>, 指定释放\(2^{order}\)的物理页块, 地址为page, 可以说释放过程是拆分过程的一个逆过程.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Freeing function for a buddy system allocator.</span><br><span class="line"> *</span><br><span class="line"> * The concept of a buddy system is to maintain direct-mapped table</span><br><span class="line"> * (containing bit values) for memory blocks of various &quot;orders&quot;.</span><br><span class="line"> * The bottom level table contains the map for the smallest allocatable</span><br><span class="line"> * units of memory (here, pages), and each level above it describes</span><br><span class="line"> * pairs of units from the levels below, hence, &quot;buddies&quot;.</span><br><span class="line"> * At a high level, all that happens here is marking the table entry</span><br><span class="line"> * at the bottom level available, and propagating the changes upward</span><br><span class="line"> * as necessary, plus some accounting needed to play nicely with other</span><br><span class="line"> * parts of the VM system.</span><br><span class="line"> * At each level, we keep a list of pages, which are heads of continuous</span><br><span class="line"> * free pages of length of (1 &lt;&lt; order) and marked with _mapcount</span><br><span class="line"> * PAGE_BUDDY_MAPCOUNT_VALUE. Page&#x27;s order is recorded in page_private(page)</span><br><span class="line"> * field.</span><br><span class="line"> * So when we are allocating or freeing one, we can derive the state of the</span><br><span class="line"> * other.  That is, if we allocate a small block, and both were</span><br><span class="line"> * free, the remainder of the region must be split into blocks.</span><br><span class="line"> * If a block is freed, and its buddy is also free, then this</span><br><span class="line"> * triggers coalescing into a block of larger size.</span><br><span class="line"> *</span><br><span class="line"> * -- nyc</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">static inline void __free_one_page(struct page *page, /*  把page加回到free_list里面 */</span><br><span class="line">		unsigned long pfn,</span><br><span class="line">		struct zone *zone, unsigned int order,</span><br><span class="line">		int migratetype)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long page_idx;</span><br><span class="line">	unsigned long combined_idx;</span><br><span class="line">	unsigned long uninitialized_var(buddy_idx);</span><br><span class="line">	struct page *buddy;</span><br><span class="line">	unsigned int max_order;</span><br><span class="line"></span><br><span class="line">	max_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1); /* 获取最大的阶数 */</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!zone_is_initialized(zone)); /* 检查wait_table是否存在来表示zone是否初始化过 里面用到了双感叹号表示强制1或者0 */</span><br><span class="line">	VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(migratetype == -1);</span><br><span class="line">	if (likely(!is_migrate_isolate(migratetype))) /* 是isolate类型 */</span><br><span class="line">		__mod_zone_freepage_state(zone, 1 &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">	page_idx = pfn &amp; ((1 &lt;&lt; MAX_ORDER) - 1); /* 获取page的下标 */</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(page_idx &amp; ((1 &lt;&lt; order) - 1), page);</span><br><span class="line">	VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line">continue_merging:</span><br><span class="line">	while (order &lt; max_order - 1) &#123;</span><br><span class="line">		buddy_idx = __find_buddy_index(page_idx, order);/* 获取buddy的下标 */</span><br><span class="line">		buddy = page + (buddy_idx - page_idx); /* 根据相对距离得到buddy page */</span><br><span class="line">		if (!page_is_buddy(page, buddy, order)) /* 如果不是buddy就结束合并 */</span><br><span class="line">			goto done_merging;</span><br><span class="line">		/*</span><br><span class="line">		 * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,</span><br><span class="line">		 * merge with it and move up one order.</span><br><span class="line">		 */</span><br><span class="line">		if (page_is_guard(buddy)) &#123;</span><br><span class="line">			clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">		    /* 把buddy从free_area当中移除 */</span><br><span class="line">			list_del(&amp;buddy-&gt;lru);</span><br><span class="line">			zone-&gt;free_area[order].nr_free--;</span><br><span class="line">			rmv_page_order(buddy);</span><br><span class="line">		&#125;</span><br><span class="line">		combined_idx = buddy_idx &amp; page_idx;</span><br><span class="line">		page = page + (combined_idx - page_idx);</span><br><span class="line">		page_idx = combined_idx;</span><br><span class="line">		order++; /* 向上合并 */</span><br><span class="line">	&#125;</span><br><span class="line">	if (max_order &lt; MAX_ORDER) &#123;</span><br><span class="line">		/* If we are here, it means order is &gt;= pageblock_order.</span><br><span class="line">		 * We want to prevent merge between freepages on isolate</span><br><span class="line">		 * pageblock and normal pageblock. Without this, pageblock</span><br><span class="line">		 * isolation could cause incorrect freepage or CMA accounting.</span><br><span class="line">		 *</span><br><span class="line">		 * We don&#x27;t want to hit this code for the more frequent</span><br><span class="line">		 * low-order merging.</span><br><span class="line">		 */</span><br><span class="line">		 /* 在这里说明已经超出了pageblock的order, 可能在不同的migratetype的block边界了,这里再检查一次是不是isolate, 不允许节点间迁移的page, 如果是的话就要结束合并的迭代,不然继续向上合并 */</span><br><span class="line">		if (unlikely(has_isolate_pageblock(zone))) &#123;</span><br><span class="line">			int buddy_mt;</span><br><span class="line"></span><br><span class="line">			buddy_idx = __find_buddy_index(page_idx, order);</span><br><span class="line">			buddy = page + (buddy_idx - page_idx);</span><br><span class="line">			buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line">			if (migratetype != buddy_mt</span><br><span class="line">					&amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">						is_migrate_isolate(buddy_mt)))</span><br><span class="line">				goto done_merging;</span><br><span class="line">		&#125;</span><br><span class="line">		max_order++;</span><br><span class="line">		goto continue_merging;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">	set_page_order(page, order);/* 结束合并自后设置合并之后的阶数 */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If this is not the largest possible page, check if the buddy</span><br><span class="line">	 * of the next-highest order is free. If it is, it&#x27;s possible</span><br><span class="line">	 * that pages are being freed that will coalesce soon. In case,</span><br><span class="line">	 * that is happening, add the free page to the tail of the list</span><br><span class="line">	 * so it&#x27;s less likely to be used soon and more likely to be merged</span><br><span class="line">	 * as a higher order page</span><br><span class="line">	 */</span><br><span class="line">	if ((order &lt; MAX_ORDER-2) &amp;&amp; pfn_valid_within(page_to_pfn(buddy))) &#123; /* 这个条件判断没有合并到最大块, 内核认为很有可能接下来这个块和其他free的块合并, 从减少碎片的角度来说会更倾向于放到链表的末尾, 让这个块的free状态保持久一点, 更有机会被合并成更大的块 */</span><br><span class="line">		struct page *higher_page, *higher_buddy;</span><br><span class="line">		combined_idx = buddy_idx &amp; page_idx; /* 合并后的idx */</span><br><span class="line">		higher_page = page + (combined_idx - page_idx); /* 合并后的page */</span><br><span class="line">		buddy_idx = __find_buddy_index(combined_idx, order + 1); /* 向上寻找buddy */</span><br><span class="line">		higher_buddy = higher_page + (buddy_idx - combined_idx);</span><br><span class="line">		if (page_is_buddy(higher_page, higher_buddy, order + 1)) &#123;</span><br><span class="line">			list_add_tail(&amp;page-&gt;lru,</span><br><span class="line">				&amp;zone-&gt;free_area[order].free_list[migratetype]);</span><br><span class="line">			goto out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_add(&amp;page-&gt;lru, &amp;zone-&gt;free_area[order].free_list[migratetype]); </span><br><span class="line">	/* 把page加入到对应的order当中 */</span><br><span class="line">out:</span><br><span class="line">	zone-&gt;free_area[order].nr_free++; /* free_area nr_free 空闲块加1 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数就是从order开始迭代不断寻找自己的buddy, 寻找buddy的函数是<code>__find_buddy_index</code>, 首先要说的是page是以数组的形式存放在<code>mem_map</code>当中, 整个page是可以通过index线性索引的.要找到自己的buddy只要在对应的order位进行抑或即可.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline unsigned long</span><br><span class="line">__find_buddy_index(unsigned long page_idx, unsigned int order)</span><br><span class="line">&#123;</span><br><span class="line">	/* idx 抑或 2^order order那位是0, 那么buddy应该是1 </span><br><span class="line">	 * order那位是1, 那么buddy应该是0 */</span><br><span class="line">	return page_idx ^ (1 &lt;&lt; order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后层层递归把低层的<code>free_area</code>中的page块向高层移动,最后有一个优化, 内核认为刚释放的page很可能相关的buddy页也会释放, 所以把刚释放的页放到末尾让他更晚被分配出去从而得到更多的机会被合并成大块.</p>
<p>现在再从外层看物理页的分配.</p>
<p>入口函数是<code>__free_pages</code>, 其实知道了分配的过程对于释放的过程可以说是轻而易举就能理解的.首先这个函数<code>put_page_testzero</code>会减少引用计数, 如果到达0才真正执行释放操作.释放路径有两个一个是order为0和不为0的情况, 为0很好理解, 需要交回到高速缓存即可, 如果高速缓存满了再交回给buddy system, 不为0说明也没有缓存过,就直接调用<code>free_one_page</code>,这个函数会调用<code>__free_one_page</code>,最终还给buddy system. 所以这里主要看一下代缓存的路径, 先是调用<code>free_hot_cold_page</code>, 指定是热页也就是添加到高速缓存的头，如果计数器超过阈值<code>pcp-&gt;count &gt;= pcp-&gt;high</code>调用<code>free_pcppages_bulk</code>交还给buddy system,  这个函数可以遍历高速缓存中的migratetype,然后根据指定的count从高速缓存中交还给buddy system的页, 当前路径是整个batch个的页都会还回去.</p>
<p>带高速缓存的释放的调用图如图所示.</p>
<img data-src="/zh-CN/2016/08/31/buddy-system-%E5%86%85%E6%A0%B8%E7%89%A9%E7%90%86%E9%A1%B5%E5%88%86%E9%85%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/callgraph__free_pages.png" class="">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>伙伴分配器的确是一个非常简洁的算法(我认为可以递归表示和迭代表示算法都美妙无比), 但是内核对于这样一个简单的算法也结合了很多实际工程的内容还有一些优化,比如迁移类型还有冷热页的标记和高速缓存等等. 充分理解内核的物理页分配对于接下来理解slab分配起和内核虚拟内存的相关内容有很好的帮助作用. 文末给出了许多参考链接, 我结合了前人的知识进行总结, 并且基于最新的4.7.2的内核重新走了一遍分析之路, 做了解释和补充, 对自己的学习是一个积累, 同时希望对大家有帮助.</p>
<p>参考</p>
<ol>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/vanbreaker/article/details/7626670">迁移类型 实现反碎片</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-26859697-id-4939357.html">页面迁移</a></li>
<li> <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/gorman/html/understand/understand009.html">LVMM 的Physical Page Allocation 章节</a></li>
<li> <a target="_blank" rel="noopener" href="http://www.ilinuxkernel.com/files/Linux_Physical_Memory_Page_Allocation.pdf">Linux 物理页面分配</a></li>
<li> <a target="_blank" rel="noopener" href="http://guojing.me/linux-kernel-architecture/posts/seqlock/">顺序锁</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/04/23/qlang-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2016/04/23/qlang-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">language-vm-给编程语言加入虚拟机作为后端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-04-23 16:03:47" itemprop="dateCreated datePublished" datetime="2016-04-23T16:03:47+08:00">2016-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/04/23/qlang-%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E8%BD%AC%E6%8D%A2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/04/23/qlang-源代码到字节码的转换/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>qlang[1]是用Go实现的一套基于虚拟机实现的动态语言,这里主要分解一下虚拟机的实现如何嵌入到解释器当中的.</p>
<p>我们用tpl定义了一套语法,类似于yacc的语法,首先是运算优先级.</p>
<p><code>*</code>代表匹配至少0个,<code>/</code>表示回调动作,<code>|</code>表示或,这是语法的第一部分,属于基本表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">term1 = factor *(&#x27;*&#x27; factor/mul | &#x27;/&#x27; factor/quo | &#x27;%&#x27; factor/mod)</span><br><span class="line"></span><br><span class="line">term2 = term1 *(&#x27;+&#x27; term1/add | &#x27;-&#x27; term1/sub)</span><br><span class="line"></span><br><span class="line">term31 = term2 *(&#x27;&lt;&#x27; term2/lt | &#x27;&gt;&#x27; term2/gt | &quot;==&quot; term2/eq | &quot;&lt;=&quot; term2/le | &quot;&gt;=&quot; term2/ge | &quot;!=&quot; term2/ne)</span><br><span class="line"></span><br><span class="line">term3 = term31 *(&quot;&lt;-&quot; term31/chin)</span><br><span class="line"></span><br><span class="line">term4 = term3 *(&quot;&amp;&amp;&quot;/_mute term3/_code/_unmute/and)</span><br><span class="line"></span><br><span class="line">expr = term4 *(&quot;||&quot;/_mute term4/_code/_unmute/or)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以<code>term1</code>表示乘性运算,相似的<code>term2</code>表示加性运算,<code>term3</code>表示逻辑运算,<code>term4</code>表示与,expr表示表达式.<br>这里有一个特点就是优先级越高的运算在语法上写在了越前面,这是有原因的.</p>
<p>由上向下的递归推导可以看做是把输入的记号流转化成一颗语法树,从根节点按先序遍历进行.所以对应的也是寻找一个最左推导的过程.<br>递归方式的遍历也是一种实现,比如说如果我要匹配<code>1+2</code>那么就会构建一颗树形结构如下图的第一个.但是如果要匹配<code>1+2*3</code>这样的表达式就有可能出现问题,既可以是图中的第二种情况也可以是第三种情况.这里就关系到优先级的问题.因为递归向下的解析过程是深度优先的也就是意味着如果最先选择匹配,就能先形成语法结构,比如说,当输入是<code>1+2*3</code>时,如果先匹配加法,那么前三个token就是<code>1+2</code>就会构成一个结点,之后3就只能作为<code>*</code>的右边的因数加入到语法树中,但是如果乘法在语法顺序中靠前,那么匹配到<code>1+</code>的时候,就会去匹配<code>term1</code>这个语法,然后<code>term1</code>就会把乘法匹配完,这样就能构成下图中第三个语法树.这种优先级可以推而广之,同级优先的运算作为一个语法,高优先级的语法排在较前即可.</p>
<p><img data-src="tree.png" alt="语法树"></p>
<p>下面语句的部分:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">sexpr = expr (</span><br><span class="line">        &#x27;=&#x27;/tovar! expr/assign |</span><br><span class="line">        &#x27;,&#x27;/tovar! expr/tovar % &#x27;,&#x27;/ARITY &#x27;=&#x27; expr % &#x27;,&#x27;/ARITY /massign |</span><br><span class="line">        &quot;++&quot;/tovar/inc | &quot;--&quot;/tovar/dec |</span><br><span class="line">        &quot;+=&quot;/tovar! expr/adda | &quot;-=&quot;/tovar! expr/suba |</span><br><span class="line">        &quot;*=&quot;/tovar! expr/mula | &quot;/=&quot;/tovar! expr/quoa | &quot;%=&quot;/tovar! expr/moda | 1/pop)</span><br><span class="line"></span><br><span class="line">s = &quot;if&quot;/_mute! expr/_code body *(&quot;elif&quot; expr/_code body)/_ARITY ?(&quot;else&quot; body)/_ARITY/_unmute/if |</span><br><span class="line">        &quot;switch&quot;/_mute! ?(~&#x27;&#123;&#x27; expr)/_code &#x27;&#123;&#x27; swbody &#x27;&#125;&#x27;/_unmute/switch |</span><br><span class="line">        &quot;for&quot;/_mute/_urange! fhead body/_unmute/for |</span><br><span class="line">        &quot;return&quot;! expr %= &#x27;,&#x27;/ARITY /return |</span><br><span class="line">        &quot;break&quot; /brk |</span><br><span class="line">        &quot;continue&quot; /cont |</span><br><span class="line">        &quot;include&quot;! STRING/include |</span><br><span class="line">        &quot;import&quot;! (STRING ?(&quot;as&quot; IDENT/name)/ARITY)/import |</span><br><span class="line">        &quot;export&quot;! IDENT/name % &#x27;,&#x27;/ARITY /export |</span><br><span class="line">        &quot;defer&quot;/_mute! expr/_code/_unmute/defer |</span><br><span class="line">        &quot;go&quot;/_mute! expr/_code/_unmute/go |</span><br><span class="line">        sexpr</span><br><span class="line"></span><br><span class="line">doc = ?s *(&#x27;;&#x27; ?s)</span><br><span class="line"></span><br><span class="line">body = &#x27;&#123;&#x27; doc/_code &#x27;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">fhead = (~&#x27;&#123;&#x27; s)/_code %= &#x27;;&#x27;/_ARITY</span><br><span class="line"></span><br><span class="line">frange = ?(IDENT/name % &#x27;,&#x27;/ARITY &#x27;=&#x27;)/ARITY &quot;range&quot; expr</span><br><span class="line"></span><br><span class="line">swbody = *(&quot;case&quot;! expr/_code &#x27;:&#x27; doc/_code)/_ARITY ?(&quot;default&quot;! &#x27;:&#x27; doc/_code)/_ARITY</span><br><span class="line"></span><br><span class="line">fnbody = &#x27;(&#x27; IDENT/name %= &#x27;,&#x27;/ARITY ?&quot;...&quot;/ARITY &#x27;)&#x27; &#x27;&#123;&#x27;/_mute doc/_code &#x27;&#125;&#x27;/_unmute</span><br><span class="line"></span><br><span class="line">afn = &#x27;&#123;&#x27;/_mute doc/_code &#x27;&#125;&#x27;/_unmute/afn</span><br><span class="line"></span><br><span class="line">clsname = &#x27;(&#x27; IDENT/ref &#x27;)&#x27; | IDENT/ref</span><br><span class="line"></span><br><span class="line">newargs = ?(&#x27;(&#x27; expr %= &#x27;,&#x27;/ARITY &#x27;)&#x27;)/ARITY</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>语句主要支持的是赋值表达式,if语句,switch语句,for语句,return语句,break语句,continue语句,include语句,import语句,export语句,defer语句,go语句和单表达式构成的语句.</p>
<p>if语句类似于<code>if expr body elif expr else body</code>,<br>switch语句类似于<code>switch expr &#123; swbody &#125;</code>,swbody的定义又是类似于<code>case expr: body default: body</code>的形式.<br>for语句类似于<code>for stmt;stmt;stmt body</code>的形式.<br>retur语句比较简答,对应的是<code>return expr</code>.<br>break,continue语句只有<code>continue</code>和<code>break. include,import语句则是</code>include STRING<code>和</code>import STRING<code>的形式. defer语句是</code>defer expr<code>的形式. go语句是</code>go expr`的形式,这里的go语句就是起一个routine进行执行.</p>
<p>从这里可以说一下这门语言的设计,类似于lua从简实现.因为继承了Go通道的特性所以语法中出现了类似<code>&lt;-</code>的语法,并且支持类和成员函数.支持复合类型比如说slice,map和chan.</p>
<p>接着是单一元素的定义.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">classb = &quot;fn&quot;! IDENT/name fnbody ?&#x27;;&#x27;/mfn</span><br><span class="line"></span><br><span class="line">atom =</span><br><span class="line">	&#x27;(&#x27; expr %= &#x27;,&#x27;/ARITY ?&quot;...&quot;/ARITY ?&#x27;,&#x27; &#x27;)&#x27;/call |</span><br><span class="line">	&#x27;.&#x27; (IDENT|&quot;class&quot;|&quot;new&quot;|&quot;recover&quot;|&quot;main&quot;)/mref |</span><br><span class="line">	&#x27;[&#x27; ?expr/ARITY ?&#x27;:&#x27;/ARITY ?expr/ARITY &#x27;]&#x27;/index</span><br><span class="line"></span><br><span class="line">factor =</span><br><span class="line">	INT/pushi |</span><br><span class="line">	FLOAT/pushf |</span><br><span class="line">	STRING/pushs |</span><br><span class="line">	CHAR/pushc |</span><br><span class="line">	(IDENT/ref | &#x27;(&#x27;! expr &#x27;)&#x27; |</span><br><span class="line">	&quot;fn&quot;! (~&#x27;&#123;&#x27; fnbody/fn | afn) | &#x27;[&#x27; expr %= &#x27;,&#x27;/ARITY ?&#x27;,&#x27; &#x27;]&#x27;/slice) *atom |</span><br><span class="line">	&quot;new&quot;! clsname newargs /new |</span><br><span class="line">	&quot;range&quot;! expr/_range |</span><br><span class="line">	&quot;class&quot;! &#x27;&#123;&#x27; *classb/ARITY &#x27;&#125;&#x27;/class |</span><br><span class="line">	&quot;recover&quot;! &#x27;(&#x27; &#x27;)&#x27;/recover |</span><br><span class="line">	&quot;main&quot;! afn |</span><br><span class="line">	&#x27;&#123;&#x27;! (expr &#x27;:&#x27; expr) %= &#x27;,&#x27;/ARITY ?&#x27;,&#x27; &#x27;&#125;&#x27;/map |</span><br><span class="line">	&#x27;!&#x27; factor/not |</span><br><span class="line">	&#x27;-&#x27; factor/neg |</span><br><span class="line">	&quot;&lt;-&quot; factor/chout |</span><br><span class="line">	&#x27;+&#x27; factor</span><br></pre></td></tr></table></figure>
<p>atom是个比较常见的定义,作为一个变量的atom,就是类似于<code>fn(expr)</code>,<code>var.selector</code>或者<code>indent[index]</code>构成atom定义,作为元素的一部分.<br>整数(INT),浮点数(FLOAT),字符串(STRING),字符(CHAR),组合atom的元素(INDENT atom,fn{}atom,[expr,expr…]atom)等都可能是一个元素.<br>支持语法级别的<code>new</code>返回的对象,支持<code>range</code>,从panic中<code>recover</code>也可能是一个返回值,以及一些单操作符可以表达的字符串.</p>
<p>以上是整个语法的定义.qlang运行的环境是自行编写的虚拟机环境,实现一个虚拟机主要是要实现各种字节码的实现,还有对应的系统调用.<br>但是目前的实现没有定义中间状态的字节码,而是以一个库的形式,用接口的形式作为字节码执行的接口.</p>
<p>任何字节码的定义都要满足这样的接口,第一个参数是当前的栈,第二个参数是执行的上下文.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Instr interface &#123;</span><br><span class="line">        Exec(stk *Stack, ctx *Context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的实现者为<code>Class</code>,<code>iAnonymFn</code>(匿名函数),<code>iAs</code>,</p>
<p><code>iAssign</code>(赋值),<code>iCall</code>(调用),<code>iDefer</code>,isExport`,</p>
<p><code>iForRange</code>,<code>iFunc</code>,<code>iGo</code>,<code>iMacro</code>,<code>iMemberRef</code>,</p>
<p><code>iModule</code>,<code>iMultiAssign</code>,<code>iMultiAssingFromSlice</code>,</p>
<p><code>iOp1Assign</code>,<code>iOp3</code>,<code>iOpAssign</code>,<code>iPush</code>,<code>iRef</code>,</p>
<p><code>iRem</code>,<code>iUnSet</code>,<code>iAnd</code>,<code>iCallFn</code>,<code>iCallFnv</code>,</p>
<p><code>iCase</code>,<code>iGo</code>,<code>iChanIn</code>,<code>iClear</code>,<code>iJmp</code>,</p>
<p><code>iJmpIfFalse</code>,<code>iNew</code>,<code>iOr</code>,<code>iPop</code>,<code>iPopEx</code>,</p>
<p><code>iRecover</code>,<code>iReturn</code>,等等这些字节码都是通过构造函数变作为<code>Insrt</code>接口返回的.</p>
<p>其实编程语言的虚拟机说白了就是一种提供字节码的运行环境,比如我定义<code>add x1,x2</code>和<code>sub x1,x2</code>两条指令作为我的虚拟机的集合,那么我的虚拟寄字节码就支持加法和乘法,也就可以完成一个简易计算器的算式到字节码的转化,再把得到的字节码按照我们的需要进行转换.</p>
<p>比如LLVM[2]就是把自己定义的一套字节码(也就是类似于平台无关的虚拟汇编,其实这种汇编要稍微好用一点点,因为里面的寄存器是无限多个的,不需要自己考虑寄存器不够的情况),然后把这些字节码转化成平台相关的汇编,最后变成二进制文件.所以实现一套编程语言虚拟机就是要定义一套字节码的集合和对应的实现方式.</p>
<p>这里我们用Go实现虚拟机是通过Go来运行的,所以没有静态语言的性质,只是跑在Go的运行时上的虚拟机.这里我们举个例子看一下具体的实现.</p>
<p>现在以<code>switch</code>语法为例说一下运行流程<br>在C转汇编的过程中,<code>switch case</code>是通过跳转表来实现的,比如下面的C代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int f(int x)</span><br><span class="line">&#123;</span><br><span class="line">	switch(x)</span><br><span class="line">	&#123;</span><br><span class="line">		case 1:</span><br><span class="line">			printf(&quot;1&quot;);	</span><br><span class="line">			break;</span><br><span class="line">		case 2: </span><br><span class="line">			printf(&quot;2&quot;);</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			printf(&quot;default&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	f(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>转成汇编的话就是如下代码,f为<code>switch case</code>的部分的实现.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	.file	&quot;main.c&quot;</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;default&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	f</span><br><span class="line">	.type	f, @function</span><br><span class="line">f:</span><br><span class="line">	pushq	%rbp // 保存栈base指针</span><br><span class="line">	movq	%rsp, %rbp  // 移动栈指针到rbp</span><br><span class="line">	subq	$16, %rsp // 因为leaf function,可以开辟red zone[3]  128个字节</span><br><span class="line">	movl	%edi, -4(%rbp) // 栈指针开始第4个字节,也就是第一个参数,0(%rbp)是callee保留的rbp.</span><br><span class="line">	movl	-4(%rbp), %eax //　移动到eax中</span><br><span class="line">	cmpl	$1, %eax //和1比较跳到L3</span><br><span class="line">	je	.L3</span><br><span class="line">	cmpl	$2, %eax //和2比较跳到L4</span><br><span class="line">	je	.L4</span><br><span class="line">	jmp	.L7 // default跳到L7</span><br><span class="line">.L3:</span><br><span class="line">	movl	$49, %edi // 放入参数&#x27;1&#x27;调用putchar,这里只打印一个字符,被优化成了putchar.</span><br><span class="line">	call	putchar</span><br><span class="line">	jmp	.L6</span><br><span class="line">.L4:</span><br><span class="line">	movl	$50, %edi // 放入参数&#x27;2&#x27;</span><br><span class="line">	call	putchar</span><br><span class="line">	jmp	.L6</span><br><span class="line">.L7:</span><br><span class="line">	movl	$.LC0, %edi // 让如.LC0,也就是字符串&quot;default&quot;的地址放入edi作为printf的参数</span><br><span class="line">	movl	$0, %eax</span><br><span class="line">	call	printf</span><br><span class="line">.L6:</span><br><span class="line">	leave</span><br><span class="line">	ret</span><br><span class="line">	.size	f, .-f</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	movl	$3, %edi</span><br><span class="line">	call	f</span><br><span class="line">	popq	%rbp</span><br><span class="line">	ret</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.1) 4.8.4&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从汇编可以看出<code>switch case</code>其实本身其实是可以通过<code>goto</code>实现的,<code>switch case</code>只是<code>goto</code>的一个高级封装的实现技巧而已.如何放到虚拟机中<br>其实就是提供类似的<code>goto</code>机制来满足跳转的需求.</p>
<p>switch解析的时候首先注册了<code>$switch</code>的回调函数,如果匹配了<code>&quot;switch&quot;/_mute! ?(~&#39;&#123;&#39; expr)/_code &#39;&#123;&#39; swbody &#39;&#125;&#39;/_unmute/switch</code>就会调用<code>Compiler.Switch函数进行处理</code>.</p>
<p><code>_mute</code>会禁止回调函数的运行,除了<code>_</code>开头的回调函数,<code>_unmute</code>则是解开禁止.<br><code>_code</code>的作用是把匹配到的语法记号流(tokens []tpl.Token)入栈.</p>
<p>swith boyd 是按照如下定义的:</p>
<p><code>swbody = *(&quot;case&quot;! expr/_code &#39;:&#39; doc/_code)/_ARITY ?(&quot;default&quot;! &#39;:&#39; doc/_code)/_ARITY</code></p>
<p><code>_ARITY</code>获取的是语法匹配的次数,分别记录了<code>case</code>和<code>default</code>匹配的次数,<code>case</code>可以匹配<code>*</code>次,<code>default</code>可以匹配<code>?</code>次.</p>
<p>然后可以看下Switch如何处理的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">func (p *Compiler) Switch(e interpreter.Engine) &#123;</span><br><span class="line"></span><br><span class="line">	var defaultCode interface&#123;&#125;</span><br><span class="line">	// 之前push了一个 ? 的匹配次数, 如果是1那么就有default的代码, 所以把defaultCode pop出来.</span><br><span class="line">	defaultArity := p.popArity()</span><br><span class="line">	if defaultArity == 1 &#123;</span><br><span class="line">		defaultCode, _ = p.gstk.Pop()</span><br><span class="line">	&#125;</span><br><span class="line">	// 获取case的匹配次数</span><br><span class="line">	caseArity := p.popArity()</span><br><span class="line">	// case 中有个expression,case:后面有一个statment,所以乘2</span><br><span class="line">	casebr := p.gstk.PopNArgs(caseArity &lt;&lt; 1) // 2 * caseArity</span><br><span class="line">	// 这switch:后面跟着的expression的代码取出</span><br><span class="line">	switchCode, _ := p.gstk.Pop()</span><br><span class="line">	// 保存老的块上下文</span><br><span class="line">	old := p.bctx</span><br><span class="line">	p.bctx = blockCtx&#123;&#125;</span><br><span class="line">	// switchCode有两种 , 一种是 switch , 一种是 switch expr.</span><br><span class="line">	// 这里处理的是switch &#123;&#125;的形式,每个case中都是条件表达式,就变成了if语句.</span><br><span class="line">	if switchCode == nil &#123;</span><br><span class="line">		// 执行case branch,和default branch</span><br><span class="line">		p.doIf(e, casebr, defaultCode, caseArity)</span><br><span class="line">		p.bctx.MergeSw(&amp;old, p.code.Len())</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	// 转换switchCode</span><br><span class="line">	// reserved2 是一组空的指令,用于最后填充跳转指令跳到switch body的末尾.</span><br><span class="line">	reserved2 := make([]exec.ReservedInstr, caseArity)</span><br><span class="line">	if err := e.EvalCode(p, &quot;expr&quot;, switchCode); err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	// 解析switchCode完毕,添加一行代码</span><br><span class="line">	p.CodeLine(switchCode)</span><br><span class="line">	for i := 0; i &lt; caseArity; i++ &#123;</span><br><span class="line">		caseCode := casebr[i&lt;&lt;1]</span><br><span class="line">		// 解析表达式</span><br><span class="line">		if err := e.EvalCode(p, &quot;expr&quot;, caseCode); err != nil &#123;</span><br><span class="line">			panic(err)</span><br><span class="line">		&#125;</span><br><span class="line">		// 记录解析过的一行代码</span><br><span class="line">		p.CodeLine(caseCode)</span><br><span class="line">		</span><br><span class="line">		// 保留指令一行空指令留待插入 case的跳转指令</span><br><span class="line">		reserved1 := p.code.Reserve()</span><br><span class="line">		bodyCode := casebr[(i&lt;&lt;1)+1]</span><br><span class="line">		// 解析块代码</span><br><span class="line">		bctx := evalDocCode(e, p, bodyCode)</span><br><span class="line">		// 把当前作用域中break,continue指令加入到p.bctx中</span><br><span class="line">		// 等最后到解析末尾再把跳转距离计算出来</span><br><span class="line">		bctx.MergeTo(&amp;p.bctx)</span><br><span class="line">		// 把当前位置留空.	</span><br><span class="line">		// 解析到了case :&#123;&#125;结尾作为跳转到结尾的指令的插入位置.</span><br><span class="line">		reserved2[i] = p.code.Reserve()</span><br><span class="line">		// 把reserved1保留的位置插入跳转到reserved2的保留的地址的地方.</span><br><span class="line">		// 相当于 Case delta,如果case 成功那么就跳到body的末尾,reserved2[i]</span><br><span class="line">		reserved1.Set(exec.Case(reserved2[i].Delta(reserved1)))</span><br><span class="line">	&#125;</span><br><span class="line">	// 类似的解析default的case</span><br><span class="line">	p.code.Block(exec.Default)</span><br><span class="line">	bctx := evalDocCode(e, p, defaultCode)</span><br><span class="line">	bctx.MergeTo(&amp;p.bctx)</span><br><span class="line"></span><br><span class="line">	end := p.code.Len()</span><br><span class="line">	for i := 0; i &lt; caseArity; i++ &#123;</span><br><span class="line">		// 设置跳转到末尾的指令</span><br><span class="line">		reserved2[i].Set(exec.Jmp(end - reserved2[i].Next()))</span><br><span class="line">	&#125;</span><br><span class="line">	// 设置break指令的跳转地址.</span><br><span class="line">	// 并把旧bctx换回来,也就是说break,continue</span><br><span class="line">	// 跳转范围就终止在 switch 的作用域内.</span><br><span class="line">	p.bctx.MergeSw(&amp;old, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>比如下面的代码进行转化的话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x=1</span><br><span class="line">switch(x)&#123;</span><br><span class="line">case 1:</span><br><span class="line">        x=4</span><br><span class="line">        break</span><br><span class="line">case 2:</span><br><span class="line">        x=2</span><br><span class="line">        break</span><br><span class="line">case 3:</span><br><span class="line">        x=3</span><br><span class="line">        break</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就跳到执行块的末尾,最后的翻译结果就是下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">==&gt; 0000: Var &amp;&#123;x&#125; // 变量x</span><br><span class="line">==&gt; 0001: Push &amp;&#123;1&#125; // 压入1</span><br><span class="line">==&gt; 0002: AssignEx 0 // x=1</span><br><span class="line">==&gt; 0003: Ref &amp;&#123;x&#125; // 引用x</span><br><span class="line">==&gt; 0004: Push &amp;&#123;1&#125; // 压入1</span><br><span class="line">==&gt; 0005: Case 5 // case是自己定义的字节码,等于pop 1 再和当前栈顶的x比较,如果成功向下跳转5</span><br><span class="line">==&gt; 0006: Var &amp;&#123;x&#125; // 引用x</span><br><span class="line">==&gt; 0007: Push &amp;&#123;4&#125; // 压入4</span><br><span class="line">==&gt; 0008: AssignEx 0 // x=4</span><br><span class="line">==&gt; 0009: Jmp 16 // break 跳到结尾</span><br><span class="line">==&gt; 0010: Jmp 15 // case 不会继续执行,也是跳到结尾</span><br><span class="line">==&gt; 0011: Push &amp;&#123;2&#125; // 后面是类似的</span><br><span class="line">==&gt; 0012: Case 5</span><br><span class="line">==&gt; 0013: Var &amp;&#123;x&#125;</span><br><span class="line">==&gt; 0014: Push &amp;&#123;2&#125;</span><br><span class="line">==&gt; 0015: AssignEx 0</span><br><span class="line">==&gt; 0016: Jmp 9</span><br><span class="line">==&gt; 0017: Jmp 8</span><br><span class="line">==&gt; 0018: Push &amp;&#123;3&#125;</span><br><span class="line">==&gt; 0019: Case 5</span><br><span class="line">==&gt; 0020: Var &amp;&#123;x&#125;</span><br><span class="line">==&gt; 0021: Push &amp;&#123;3&#125;</span><br><span class="line">==&gt; 0022: AssignEx 0</span><br><span class="line">==&gt; 0023: Jmp 2</span><br><span class="line">==&gt; 0024: Jmp 1</span><br><span class="line">==&gt; 0025: Pop 0 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>比起汇编,我们定义的字节码稍微高级一点不需要构造跳转表，而是用Case指令替代,和栈顶的值比较,如果为true就顺序执行,不然就会跳转<br>相对距离的位置,到这里为止,我们的转换就结束了.</p>
<p>最后总结一下,现代编译器的实现已经非常方便了,前端有lex,yacc,后端有llvm,比如object-c和clang,以及rust的后端都是llvm,所以llvm还是很靠谱的,而前端手写或者用工具生成各有利弊,但是并不是什么决定因素.</p>
<p>而这里实现的qlang主要是优势是短小精悍无依赖,全部前后端自行实现,可以作为Golang的项目的嵌入脚本语言,类似于lua.</p>
<p>[1] <a target="_blank" rel="noopener" href="https://github.com/qiniu/qlang">https://github.com/qiniu/qlang</a><br>[2] <a target="_blank" rel="noopener" href="http://llvm.org/">http://llvm.org/</a><br>[3] <a target="_blank" rel="noopener" href="http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/">http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/04/06/go-parser-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2016/04/06/go-parser-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">go-parser-语法分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-04-06 11:04:37" itemprop="dateCreated datePublished" datetime="2016-04-06T11:04:37+08:00">2016-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/04/06/go-parser-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/04/06/go-parser-语法分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>每一种语言都会有一个定义良好的语法结构.函数是由申明和语句构成的,而语句又是由表达式构成的.<br>经常用来描述语法的是BNF[1].Go使用的是相应的变种,在Go的官方文档中有很详细的spec描述[2].一门语言的设计其实就在这份描述当中,这是一门语言的语法和规则的定义,是表面程序员可以接触到的部分,而运行时却可以改变,这相当于和程序员约定的接口,只要按照这个接口编写源代码,就能产生正常可以编译的二进制文件,但是最后的二进制文件如何运行,对于每条语法转换成了什么,有什么优化都是编译器优化和运行时的工作.所以一门语言必须有一个详尽的描述,这和一个网络协议一样,是非常重要的部分.</p>
<p>语法分析器也是有工具可以自动生成的,比如yacc[3].我在之前提到过使用工具的利弊,就不赘述了.</p>
<p>本文主要看一下Go的语法分析是如何进行.Go的parser接受的输入是源文件,内嵌了一个scanner,最后把scanner生成的token变成一颗抽象语法树(AST).<br>编译时的错误也是在这个时候报告的,但是大部分编译器编译时的错误系统并不是很完美,有时候报的错误文不对题,这主要是因为写对的方式有几种<br>但是写错的方式有很多种,编译器只能把一些错误进行归类,并且指出当前认为可疑的地方,并不能完完全全的知道到底是什么语法错误.这个需要结合给出的错误进行判断,clang作为一个C编译器做得好很多,这都是开发者不断地添加错误处理的结果,比gcc的报错完善很多.然而Go的编译时的错误处理也是秉承了gcc的风格,并不明确,但是会指出可疑的地方,在大多数场景下或者对语言标准熟悉的情况下也不是很麻烦.<br>下面看一下Go是怎么定义这些语法结构.这些结构都在<code>go/ast</code>当中.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// All node types implement the Node interface.</span><br><span class="line">type Node interface &#123;</span><br><span class="line">        Pos() token.Pos // position of first character belonging to the node</span><br><span class="line">        End() token.Pos // position of first character immediately after the node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// All expression nodes implement the Expr interface.</span><br><span class="line">type Expr interface &#123;</span><br><span class="line">        Node</span><br><span class="line">        exprNode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// All statement nodes implement the Stmt interface.</span><br><span class="line">type Stmt interface &#123;</span><br><span class="line">        Node</span><br><span class="line">        stmtNode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// All declaration nodes implement the Decl interface.</span><br><span class="line">type Decl interface &#123;</span><br><span class="line">        Node</span><br><span class="line">        declNode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>语法有三个主体,表达式(expression),语句(statement),声明(declaration),Node是基类,用于标记该节点的位置的开始和结束.<br>而三个主体的函数没有实际意义,只是用三个interface来划分不同的语法单位,如果某个语法是Stmt的话,就实现一个空的<code>stmtNode</code>函数即可.<br>这样的好处是可以对语法单元进行<code>comma,ok</code>来判断类型,并且保证只有这些变量可以赋值给对应的interface.但是实际上这个划分不是很严格,比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (*ArrayType) exprNode()     &#123;&#125;</span><br><span class="line">func (*StructType) exprNode()    &#123;&#125;</span><br><span class="line">func (*FuncType) exprNode()      &#123;&#125;</span><br><span class="line">func (*InterfaceType) exprNode() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>就是类型,但是属于Expr,而真正的表达式比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (*BasicLit) exprNode()       &#123;&#125;</span><br><span class="line">func (*FuncLit) exprNode()        &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>是可以赋值给Exprt的.</p>
<p>了解了这个设计,再来看整个内容其实就是定义了源文件中可能出现的语法结构.列表如下,这个列表很长,扫一眼就可以,具体可以再回来看.</p>
<ol>
<li>普通Node,不是特定语法结构,属于某个语法结构的一部分.<ul>
<li>  Comment 表示一行注释 // 或者 /* */</li>
<li>  CommentGroup 表示多行注释</li>
<li>  Field 表示结构体中的一个定义或者变量,或者函数签名当中的参数或者返回值</li>
<li>  FieldList 表示以”{}”或者”()”包围的Filed列表</li>
</ul>
</li>
<li>Expression &amp; Types (都划分成Expr接口)<ul>
<li>  BadExpr 用来表示错误表达式的占位符</li>
<li>  Ident 比如报名,函数名,变量名</li>
<li>  Ellipsis 省略号表达式,比如参数列表的最后一个可以写成<code>arg...</code></li>
<li>  BasicLit 基本字面值,数字或者字符串</li>
<li>  FuncLit 函数定义</li>
<li>  CompositeLit 构造类型,比如{1,2,3,4}</li>
<li>  ParenExpr 括号表达式,被括号包裹的表达式</li>
<li>  SelectorExpr 选择结构,类似于a.b的结构</li>
<li>  IndexExpr 下标结构,类似这样的结构 expr[expr]</li>
<li>  SliceExpr 切片表达式,类似这样 expr[low:mid:high]</li>
<li>  TypeAssertExpr 类型断言类似于 X.(type)</li>
<li>  CallExpr 调用类型,类似于 expr()</li>
<li>  StarExpr *表达式,类似于 *X</li>
<li>  UnaryExpr 一元表达式</li>
<li>  BinaryExpr 二元表达式</li>
<li>  KeyValueExp 键值表达式 key:value</li>
<li>  ArrayType 数组类型</li>
<li>  StructType  结构体类型</li>
<li>  FuncType 函数类型</li>
<li>  InterfaceType 接口类型</li>
<li>  MapType map类型</li>
<li>  ChanType 管道类型</li>
</ul>
</li>
<li>Statements<ul>
<li>  BadStmt 错误的语句</li>
<li>  DeclStmt 在语句列表里的申明</li>
<li>  EmptyStmt 空语句</li>
<li>  LabeledStmt 标签语句类似于 indent:stmt</li>
<li>  ExprStmt 包含单独的表达式语句</li>
<li>  SendStmt chan发送语句</li>
<li>  IncDecStmt 自增或者自减语句</li>
<li>  AssignStmt 赋值语句</li>
<li>  GoStmt Go语句</li>
<li>  DeferStmt 延迟语句</li>
<li>  ReturnStmt return 语句</li>
<li>  BranchStmt 分支语句 例如break continue </li>
<li>  BlockStmt 块语句 {} 包裹</li>
<li>  IfStmt If 语句</li>
<li>  CaseClause case 语句</li>
<li>  SwitchStmt switch 语句</li>
<li>  TypeSwitchStmt 类型switch 语句 switch x:=y.(type)</li>
<li>  CommClause 发送或者接受的case语句,类似于 case x &lt;-: </li>
<li>  SelectStmt select 语句</li>
<li>  ForStmt for 语句</li>
<li>  RangeStmt range 语句</li>
</ul>
</li>
<li>Declarations<ul>
<li>Spec type<ul>
<li>  Import Spec</li>
<li>  Value Spec</li>
<li>  Type Spec</li>
</ul>
</li>
<li>  BadDecl 错误申明</li>
<li>  GenDecl 一般申明(和Spec相关,比如 import “a”,var a,type a)</li>
<li>  FuncDecl 函数申明</li>
</ul>
</li>
<li>Files and Packages<ul>
<li>  File 代表一个源文件节点,包含了顶级元素.</li>
<li>  Package 代表一个包,包含了很多文件.</li>
</ul>
</li>
</ol>
<p>上面就是整个源代码的所有组成元素,接下来就来看一下语法分析是如何进行的,也就是最后的AST是如何构建出来的.</p>
<p>先看一下<code>parser</code>结构体的定义,parser是以file为单位的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// The parser structure holds the parser&#x27;s internal state.</span><br><span class="line">type parser struct &#123;</span><br><span class="line">        file    *token.File</span><br><span class="line">        errors  scanner.ErrorList // 解析过程中遇到的错误列表</span><br><span class="line">        scanner scanner.Scanner // 词法分析器.</span><br><span class="line"></span><br><span class="line">        // Tracing/debugging</span><br><span class="line">        mode   Mode // parsing mode // 解析模式</span><br><span class="line">        trace  bool // == (mode &amp; Trace != 0)</span><br><span class="line">        indent int  // indentation used for tracing output</span><br><span class="line"></span><br><span class="line">        // Comments 列表</span><br><span class="line">        comments    []*ast.CommentGroup</span><br><span class="line">        leadComment *ast.CommentGroup // last lead comment</span><br><span class="line">        lineComment *ast.CommentGroup // last line comment</span><br><span class="line"></span><br><span class="line">        // Next token</span><br><span class="line">        pos token.Pos   // token position</span><br><span class="line">        tok token.Token // one token look-ahead</span><br><span class="line">        lit string      // token literal</span><br><span class="line"></span><br><span class="line">        // Error recovery</span><br><span class="line">        // (used to limit the number of calls to syncXXX functions</span><br><span class="line">        // w/o making scanning progress - avoids potential endless</span><br><span class="line">        // loops across multiple parser functions during error recovery)</span><br><span class="line">        syncPos token.Pos // last synchronization position 解析错误的同步点.</span><br><span class="line">        syncCnt int       // number of calls to syncXXX without progress</span><br><span class="line"></span><br><span class="line">        // Non-syntactic parser control</span><br><span class="line">        // 非语法性的控制</span><br><span class="line">        // &lt;0 在控制语句中, &gt;= 在表达式中.</span><br><span class="line">        exprLev int  // &lt; 0: in control clause, &gt;= 0: in expression</span><br><span class="line">        // 正在解析右值表达式</span><br><span class="line">        inRhs   bool // if set, the parser is parsing a rhs expression</span><br><span class="line"></span><br><span class="line">        // Ordinary identifier scopes</span><br><span class="line">        pkgScope   *ast.Scope        // pkgScope.Outer == nil</span><br><span class="line">        topScope   *ast.Scope        // top-most scope; may be pkgScope</span><br><span class="line">        unresolved []*ast.Ident      // unresolved identifiers</span><br><span class="line">        imports    []*ast.ImportSpec // list of imports</span><br><span class="line"></span><br><span class="line">        // Label scopes</span><br><span class="line">        // (maintained by open/close LabelScope)</span><br><span class="line">        labelScope  *ast.Scope     // label scope for current function</span><br><span class="line">        targetStack [][]*ast.Ident // stack of unresolved labels</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解析的入口是<code>ParseFile</code>,首先调用<code>init</code>,再调用<code>parseFile</code>进行解析.<br>整个解析是一个递归向下的过程也就是最low但是最实用的手写实现的方式.像yacc[4]生成的是我们编译里学的LALR[5]文法,牛逼的一逼,但是<br>gcc和Go都没用自动生成的解析器,也就是手写个几千行代码的事,所以为了更好的掌握编译器的细节,都选择了手写最简单的递归向下的方式.</p>
<p>通过<code>init</code>初始化<code>scanner</code>等.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode Mode) &#123;</span><br><span class="line">        p.file = fset.AddFile(filename, -1, len(src))</span><br><span class="line">        var m scanner.Mode</span><br><span class="line">        if mode&amp;ParseComments != 0 &#123;</span><br><span class="line">                m = scanner.ScanComments</span><br><span class="line">        &#125;</span><br><span class="line">        // 错误处理函数是在错误列表中添加错误.</span><br><span class="line">        eh := func(pos token.Position, msg string) &#123; p.errors.Add(pos, msg) &#125;</span><br><span class="line">        p.scanner.Init(p.file, src, eh, m)</span><br><span class="line"></span><br><span class="line">        p.mode = mode</span><br><span class="line">        p.trace = mode&amp;Trace != 0 // for convenience (p.trace is used frequently)</span><br><span class="line"></span><br><span class="line">        p.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>parseFile</code>的简化流程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">       // package clause</span><br><span class="line">       // 获取源文件开头的doc注释,从这里递归向下的解析开始了</span><br><span class="line">       doc := p.leadComment</span><br><span class="line">       // expect 从scanner获取一个token,并且返回位置pos.</span><br><span class="line">       pos := p.expect(token.PACKAGE)</span><br><span class="line">       // parseIdent 获取一个token并且转化为indent,如果不是报错.</span><br><span class="line">       ident := p.parseIdent()</span><br><span class="line">       if ident.Name == &quot;_&quot; &amp;&amp; p.mode&amp;DeclarationErrors != 0 &#123;</span><br><span class="line">               p.error(p.pos, &quot;invalid package name _&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">       // 作用域开始,标记解释器当前开始一个新的作用域</span><br><span class="line">       p.openScope()</span><br><span class="line">       // pkgScope 就是现在进入的作用域</span><br><span class="line">       p.pkgScope = p.topScope </span><br><span class="line">       // 解析 import 申明</span><br><span class="line">       for p.tok == token.IMPORT &#123;</span><br><span class="line">	// parseGenDecl解析的是 </span><br><span class="line">	// import (</span><br><span class="line">	// )</span><br><span class="line">	// 这样的结构,如果有括号就用parseImportSpec解析列表</span><br><span class="line">	// 没有就单独解析.</span><br><span class="line">	// 而parseImportSpec解析的是 一个可选的indent token和一个字符串token.</span><br><span class="line">	// 并且加入到imports列表中.</span><br><span class="line">               decls = append(decls, p.parseGenDecl(token.IMPORT, p.parseImportSpec))</span><br><span class="line">       &#125;</span><br><span class="line">// 解析全局的申明,包括函数申明</span><br><span class="line">       if p.mode&amp;ImportsOnly == 0 &#123;</span><br><span class="line">               // rest of package body</span><br><span class="line">               for p.tok != token.EOF &#123;</span><br><span class="line">                       decls = append(decls, p.parseDecl(syncDecl))</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">// 标记从当前作用域离开.</span><br><span class="line">p.closeScope()</span><br><span class="line">// 最后返回ast.File文件对象.</span><br><span class="line">       return &amp;ast.File&#123;</span><br><span class="line">               Doc:        doc,</span><br><span class="line">               Package:    pos,</span><br><span class="line">               Name:       ident,</span><br><span class="line">               Decls:      decls,</span><br><span class="line">               Scope:      p.pkgScope,</span><br><span class="line">               Imports:    p.imports,</span><br><span class="line">               Unresolved: p.unresolved[0:i],</span><br><span class="line">               Comments:   p.comments,</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看一下<code>parseDecl</code>主要是根据类型的不同调用不同的解析函数,<code>parseValueSpec</code>解析Value类型,<code>parseTypeSpec</code>解析Type类型,<code>parseFuncDecl</code>解析函数.<br>解析定义和解析类型的都是解析了,类似于<code>var|type ( ident valueSpec|typeSpec)</code>的token结构.因为<code>parseFuncDecl</code>里面也会解析这些内容,所以直接从函数解析来看也可以.<br>因为外一层的top scope其实就是相当于一个抽象的函数作用域而已,这样是为什么<code>len</code>和<code>new</code>这样的内嵌函数在函数内是可以做变量名的原因,因为可以在子作用域覆盖top作用域.整个解析过程简化过程如下.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 解析一个func.</span><br><span class="line">       pos := p.expect(token.FUNC)</span><br><span class="line">// 开一个新的作用域,topScope作为父Scope.</span><br><span class="line">       scope := ast.NewScope(p.topScope) // function scope</span><br><span class="line">// 解析一个ident作为函数名</span><br><span class="line">ident := p.parseIdent()	</span><br><span class="line">// 解析函数签名,也就是参数和返回值</span><br><span class="line">params, results := p.parseSignature(scope)</span><br><span class="line">// 再解析body</span><br><span class="line">body = p.parseBody(scope)</span><br><span class="line">// 最后返回函数申明.</span><br><span class="line">       decl := &amp;ast.FuncDecl&#123;</span><br><span class="line">               Doc:  doc,</span><br><span class="line">               Recv: recv,</span><br><span class="line">               Name: ident,</span><br><span class="line">               Type: &amp;ast.FuncType&#123;</span><br><span class="line">                       Func:    pos,</span><br><span class="line">                       Params:  params,</span><br><span class="line">                       Results: results,</span><br><span class="line">               &#125;,</span><br><span class="line">               Body: body,</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解析参数和返回值就是解析(filed,filed)这样的格式,每个filed是<code>indent type</code>的token,最后构造成函数签名.然后来到<code>parseBody</code>,这个函数其实就是解析了左右花括号,然后向下开始解析Statement列表,类似于body -&gt; { stmt_list },然后进入stmt_list的解析,不断地解析statement.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for p.tok != token.CASE &amp;&amp; p.tok != token.DEFAULT &amp;&amp; p.tok != token.RBRACE &amp;&amp; p.tok != token.EOF &#123;</span><br><span class="line">        list = append(list, p.parseStmt())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parseStmt</code>最后会进入到语句的解析,然后根据不同的token选择进入不同的解析流程,比如看到<code>var</code>,<code>type</code>,<code>const</code>就是申明,碰到标识符和数字等等可能就是单独的表达式,<br>如果碰到<code>go</code>,就知道是一个go语句,如果看到defer和return都能判断出相应的语句并按规则解析,看到<code>break</code>等条件关键字就解析条件语句,看到<code>&#123;</code>就解析块语句.都是可以递归去解析的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func (p *parser) parseStmt() (s ast.Stmt) &#123;</span><br><span class="line">        if p.trace &#123;</span><br><span class="line">                defer un(trace(p, &quot;Statement&quot;))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch p.tok &#123;</span><br><span class="line">        case token.CONST, token.TYPE, token.VAR:</span><br><span class="line">                s = &amp;ast.DeclStmt&#123;Decl: p.parseDecl(syncStmt)&#125;</span><br><span class="line">        case</span><br><span class="line">                // tokens that may start an expression</span><br><span class="line">                token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operands</span><br><span class="line">                token.LBRACK, token.STRUCT, token.MAP, token.CHAN, token.INTERFACE, // composite types</span><br><span class="line">                token.ADD, token.SUB, token.MUL, token.AND, token.XOR, token.ARROW, token.NOT: // unary operators</span><br><span class="line">                s, _ = p.parseSimpleStmt(labelOk)</span><br><span class="line">                // because of the required look-ahead, labeled statements are</span><br><span class="line">                // parsed by parseSimpleStmt - don&#x27;t expect a semicolon after</span><br><span class="line">                // them</span><br><span class="line">                if _, isLabeledStmt := s.(*ast.LabeledStmt); !isLabeledStmt &#123;</span><br><span class="line">                        p.expectSemi()</span><br><span class="line">                &#125;</span><br><span class="line">        case token.GO:</span><br><span class="line">                s = p.parseGoStmt()</span><br><span class="line">        case token.DEFER:</span><br><span class="line">                s = p.parseDeferStmt()</span><br><span class="line">        case token.RETURN:</span><br><span class="line">                s = p.parseReturnStmt()</span><br><span class="line">        case token.BREAK, token.CONTINUE, token.GOTO, token.FALLTHROUGH:</span><br><span class="line">                s = p.parseBranchStmt(p.tok)</span><br><span class="line">        case token.LBRACE:</span><br><span class="line">                s = p.parseBlockStmt()</span><br><span class="line">	...省略</span><br></pre></td></tr></table></figure>

<p>举个例子看一下<code>parseSimpleStmt()</code>的简化流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">       // 解析左列表 一般是 l := r 或者 l1,l2 = r1,r2 或者 l &lt;- r 或者 l++</span><br><span class="line">       x := p.parseLhsList()</span><br><span class="line">       switch p.tok &#123;</span><br><span class="line">       case</span><br><span class="line">               token.DEFINE, token.ASSIGN, token.ADD_ASSIGN,</span><br><span class="line">               token.SUB_ASSIGN, token.MUL_ASSIGN, token.QUO_ASSIGN,</span><br><span class="line">               token.REM_ASSIGN, token.AND_ASSIGN, token.OR_ASSIGN,</span><br><span class="line">               token.XOR_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.AND_NOT_ASSIGN:</span><br><span class="line">	// 如果看到range,range作为一种运算符按照range rhs来解析</span><br><span class="line">	// 如果没看到就按正常赋值语句解析 lhs op rhs 来解析op可以是上面那些token中的一种.</span><br><span class="line">               pos, tok := p.pos, p.tok</span><br><span class="line">               p.next()</span><br><span class="line">               var y []ast.Expr</span><br><span class="line">               isRange := false</span><br><span class="line">               if mode == rangeOk &amp;&amp; p.tok == token.RANGE &amp;&amp; (tok == token.DEFINE || tok == token.ASSIGN) &#123;</span><br><span class="line">                       pos := p.pos</span><br><span class="line">                       p.next()</span><br><span class="line">                       y = []ast.Expr&#123;&amp;ast.UnaryExpr&#123;OpPos: pos, Op: token.RANGE, X: p.parseRhs()&#125;&#125;</span><br><span class="line">                       isRange = true</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                       y = p.parseRhsList()</span><br><span class="line">               &#125;</span><br><span class="line">               as := &amp;ast.AssignStmt&#123;Lhs: x, TokPos: pos, Tok: tok, Rhs: y&#125;</span><br><span class="line"></span><br><span class="line">// 碰到&quot;:&quot;找一个ident, 构成 goto: indent 之类的语句.</span><br><span class="line">case token.COLON:</span><br><span class="line">               colon := p.pos</span><br><span class="line">               p.next()</span><br><span class="line">               if label, isIdent := x[0].(*ast.Ident); mode == labelOk &amp;&amp; isIdent &#123;</span><br><span class="line">                       // Go spec: The scope of a label is the body of the function</span><br><span class="line">                       // in which it is declared and excludes the body of any nested</span><br><span class="line">                       // function.</span><br><span class="line">                       stmt := &amp;ast.LabeledStmt&#123;Label: label, Colon: colon, Stmt: p.parseStmt()&#125;</span><br><span class="line">                       p.declare(stmt, nil, p.labelScope, ast.Lbl, label)</span><br><span class="line">                       return stmt, false</span><br><span class="line">               &#125;</span><br><span class="line">// 碰到&quot;&lt;-&quot;,就构成 &lt;- rhs 这样的语句.</span><br><span class="line">       case token.ARROW:</span><br><span class="line">               // send statement</span><br><span class="line">               arrow := p.pos</span><br><span class="line">               p.next()</span><br><span class="line">               y := p.parseRhs()</span><br><span class="line">               return &amp;ast.SendStmt&#123;Chan: x[0], Arrow: arrow, Value: y&#125;, false</span><br><span class="line"></span><br><span class="line">// 碰到&quot;++&quot;或者&quot;--&quot;就构成一个单独的自增语句.</span><br><span class="line">       case token.INC, token.DEC:</span><br><span class="line">               // increment or decrement</span><br><span class="line">               s := &amp;ast.IncDecStmt&#123;X: x[0], TokPos: p.pos, Tok: p.tok&#125;</span><br><span class="line">               p.next()</span><br><span class="line">               return s, false</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来就不一一解释每段代码了,具体情况具体看就可以.这里举个例子.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;go/ast&quot;</span><br><span class="line">        &quot;go/parser&quot;</span><br><span class="line">        &quot;go/token&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">        fset := token.NewFileSet()</span><br><span class="line">        f, err := parser.ParseFile(fset, &quot;&quot;, ` </span><br><span class="line">package main</span><br><span class="line">func main()&#123;</span><br><span class="line">        // comments</span><br><span class="line">        x:=1</span><br><span class="line">        go println(x)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">        `, parser.ParseComments)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                panic(err)</span><br><span class="line">        &#125;</span><br><span class="line">        ast.Print(fset, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>产生的结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"> 0  *ast.File &#123;</span><br><span class="line"> 1  .  Package: 2:1						|PACKAGE token</span><br><span class="line"> 2  .  Name: *ast.Ident &#123;					|IDENT token</span><br><span class="line"> 3  .  .  NamePos: 2:9					|</span><br><span class="line"> 4  .  .  Name: &quot;main&quot;					|</span><br><span class="line"> 5  .  &#125;							|整个构成了顶部的 package main</span><br><span class="line"> 6  .  Decls: []ast.Decl (len = 1) &#123;			|最上层的申明列表</span><br><span class="line"> 7  .  .  0: *ast.FuncDecl &#123;				|func main的函数申明</span><br><span class="line"> 8  .  .  .  Name: *ast.Ident &#123;				|IDENT token</span><br><span class="line"> 9  .  .  .  .  NamePos: 3:6				|</span><br><span class="line">10  .  .  .  .  Name: &quot;main&quot;				|</span><br><span class="line">11  .  .  .  .  Obj: *ast.Object &#123;				|Objec是一个用于表达语法对象的结构</span><br><span class="line">12  .  .  .  .  .  Kind: func				|表示之前存在过,Decl指向了7,也就是第7行的FuncDecl.</span><br><span class="line">13  .  .  .  .  .  Name: &quot;main&quot;				|</span><br><span class="line">14  .  .  .  .  .  Decl: *(obj @ 7)				|</span><br><span class="line">15  .  .  .  .  &#125;						|</span><br><span class="line">16  .  .  .  &#125;						|</span><br><span class="line">17  .  .  .  Type: *ast.FuncType &#123;				|函数类型,也就是函数签名</span><br><span class="line">18  .  .  .  .  Func: 3:1					|参数和返回值都是空的</span><br><span class="line">19  .  .  .  .  Params: *ast.FieldList &#123;			|</span><br><span class="line">20  .  .  .  .  .  Opening: 3:10</span><br><span class="line">21  .  .  .  .  .  Closing: 3:11</span><br><span class="line">22  .  .  .  .  &#125;</span><br><span class="line">23  .  .  .  &#125;</span><br><span class="line">24  .  .  .  Body: *ast.BlockStmt &#123;				|块语句,也就是main的body</span><br><span class="line">25  .  .  .  .  Lbrace: 3:12</span><br><span class="line">26  .  .  .  .  List: []ast.Stmt (len = 2) &#123;		|语句列表</span><br><span class="line">27  .  .  .  .  .  0: *ast.AssignStmt &#123;			|赋值语句</span><br><span class="line">28  .  .  .  .  .  .  Lhs: []ast.Expr (len = 1) &#123;		|左值是x</span><br><span class="line">29  .  .  .  .  .  .  .  0: *ast.Ident &#123;</span><br><span class="line">30  .  .  .  .  .  .  .  .  NamePos: 5:2			|</span><br><span class="line">31  .  .  .  .  .  .  .  .  Name: &quot;x&quot;</span><br><span class="line">32  .  .  .  .  .  .  .  .  Obj: *ast.Object &#123;		|</span><br><span class="line">33  .  .  .  .  .  .  .  .  .  Kind: var</span><br><span class="line">34  .  .  .  .  .  .  .  .  .  Name: &quot;x&quot;			|</span><br><span class="line">35  .  .  .  .  .  .  .  .  .  Decl: *(obj @ 27)</span><br><span class="line">36  .  .  .  .  .  .  .  .  &#125;</span><br><span class="line">37  .  .  .  .  .  .  .  &#125;					|</span><br><span class="line">38  .  .  .  .  .  .  &#125;</span><br><span class="line">39  .  .  .  .  .  .  TokPos: 5:3				|:=和它的位置</span><br><span class="line">40  .  .  .  .  .  .  Tok: :=</span><br><span class="line">41  .  .  .  .  .  .  Rhs: []ast.Expr (len = 1) &#123;		|右边是一个数字类型的token</span><br><span class="line">42  .  .  .  .  .  .  .  0: *ast.BasicLit &#123;</span><br><span class="line">43  .  .  .  .  .  .  .  .  ValuePos: 5:5</span><br><span class="line">44  .  .  .  .  .  .  .  .  Kind: INT</span><br><span class="line">45  .  .  .  .  .  .  .  .  Value: &quot;1&quot;</span><br><span class="line">46  .  .  .  .  .  .  .  &#125;</span><br><span class="line">47  .  .  .  .  .  .  &#125;</span><br><span class="line">48  .  .  .  .  .  &#125;</span><br><span class="line">49  .  .  .  .  .  1: *ast.GoStmt &#123;				|接下来是go语句</span><br><span class="line">50  .  .  .  .  .  .  Go: 6:2</span><br><span class="line">51  .  .  .  .  .  .  Call: *ast.CallExpr &#123;			|一个调用表达式</span><br><span class="line">52  .  .  .  .  .  .  .  Fun: *ast.Ident &#123;			|IDENT token是println</span><br><span class="line">53  .  .  .  .  .  .  .  .  NamePos: 6:5</span><br><span class="line">54  .  .  .  .  .  .  .  .  Name: &quot;println&quot;</span><br><span class="line">55  .  .  .  .  .  .  .  &#125;</span><br><span class="line">56  .  .  .  .  .  .  .  Lparen: 6:12			|左括号的位置</span><br><span class="line">57  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) &#123;	|参数列表</span><br><span class="line">58  .  .  .  .  .  .  .  .  0: *ast.Ident &#123;			|是一个符号INDENT,并且指向的是32行的x</span><br><span class="line">59  .  .  .  .  .  .  .  .  .  NamePos: 6:13</span><br><span class="line">60  .  .  .  .  .  .  .  .  .  Name: &quot;x&quot;</span><br><span class="line">61  .  .  .  .  .  .  .  .  .  Obj: *(obj @ 32)</span><br><span class="line">62  .  .  .  .  .  .  .  .  &#125;</span><br><span class="line">63  .  .  .  .  .  .  .  &#125;</span><br><span class="line">64  .  .  .  .  .  .  .  Ellipsis: -</span><br><span class="line">65  .  .  .  .  .  .  .  Rparen: 6:14			|右括号的位置</span><br><span class="line">66  .  .  .  .  .  .  &#125;</span><br><span class="line">67  .  .  .  .  .  &#125;</span><br><span class="line">68  .  .  .  .  &#125;</span><br><span class="line">69  .  .  .  .  Rbrace: 8:1</span><br><span class="line">70  .  .  .  &#125;</span><br><span class="line">71  .  .  &#125;</span><br><span class="line">72  .  &#125;</span><br><span class="line">73  .  Scope: *ast.Scope &#123;					|最顶级的作用域</span><br><span class="line">74  .  .  Objects: map[string]*ast.Object (len = 1) &#123;</span><br><span class="line">75  .  .  .  &quot;main&quot;: *(obj @ 11)</span><br><span class="line">76  .  .  &#125;</span><br><span class="line">77  .  &#125;</span><br><span class="line">78  .  Unresolved: []*ast.Ident (len = 1) &#123;			|这里有个没有定义的符号println,是因为是内置符号,会另外处理</span><br><span class="line">79  .  .  0: *(obj @ 52)					|从源文件上是表现不出来的.</span><br><span class="line">80  .  &#125;</span><br><span class="line">81  .  Comments: []*ast.CommentGroup (len = 1) &#123;		|评论列表,以及位置和内容.</span><br><span class="line">82  .  .  0: *ast.CommentGroup &#123;</span><br><span class="line">83  .  .  .  List: []*ast.Comment (len = 1) &#123;</span><br><span class="line">84  .  .  .  .  0: *ast.Comment &#123;</span><br><span class="line">85  .  .  .  .  .  Slash: 4:2</span><br><span class="line">86  .  .  .  .  .  Text: &quot;// comments&quot;</span><br><span class="line">87  .  .  .  .  &#125;</span><br><span class="line">88  .  .  .  &#125;</span><br><span class="line">89  .  .  &#125;</span><br><span class="line">90  .  &#125;</span><br><span class="line">91  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是Go的整个语法分析和最后产生的语法树的结构.</p>
<p>废话说了这么多其实实现很简单,问题是如何把一个语言的spec定义好,很重要,早期语言设计不是很固定的.都是慢慢尝试不断改进的过程.最早的一次spec文档[6]其实和现在差了很多很多.就是把TOKEN记号流从左至右匹配规则(可能会向前看几个token),然后递归解析语法树,最后得到AST.<br>我在我的字符画转换器里用的也是类似的方式[7],做了自顶向下递归解析语法的方式,但是错误处理都是速错,不会做错误恢复找到一个可以同步的节点继续分析.<br>所以这里补充一点,Go是如何进行错误处理的同步问题,寄希望于能够向使用者提供更多的错误.主要是parser当中的两个结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syncPos token.Pos // last synchronization position</span><br><span class="line">syncCnt int       // number of calls to syncXXX without progress</span><br></pre></td></tr></table></figure>

<p><code>syncPos</code>错误的同步位置,也就类似于游戏的存档点,如果发生错误那就从这个地方开始跳过(BadStmt|BadExpr)继续解析,在每次完成语句,申明或者表达式的解析之后就会保存一个同步点.虽然这种继续解析的行为不一定能够给出很精确的错误提示,但的确够用了.当然如果错误实在太多了,从同步点恢复也没有太大意义,就会主动放弃,所以记录了没有成功解析而同步的次数.</p>
<p>因为之前造过轮子了,所以我发现其实编译器的前端用手写是一个很繁琐并且需要花很多时间去做的一件事情,如果语言有设计良好,那么也至少需要花实现的时间,如果设计不好,实现也要跟着修修补补,那就更麻烦,虽然整个编译器的前端也就不到万行代码,但是的确是很考验耐心的一件事情,而且用递归向下的方式解析也没什么效率问题,编译器编译慢一点也不是很要紧,所以有轮子还是用轮子吧,这只是一件苦力活,的确没什么高科技.</p>
<p>最后附带一个用Go实现的Go语法的子集的动态语言版本,只有几十行.</p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/ggaaooppeenngg/dff0fff8f0c9194d93c70550d50edbfa">https://gist.github.com/ggaaooppeenngg/dff0fff8f0c9194d93c70550d50edbfa</a></p>
<p>参考:</p>
<ol>
<li> <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form</a></li>
<li> <a target="_blank" rel="noopener" href="https://golang.org/ref/spec">https://golang.org/ref/spec</a></li>
<li> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Yacc">https://zh.wikipedia.org/wiki/Yacc</a></li>
<li> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/Yacc">https://zh.wikipedia.org/zh-cn/Yacc</a></li>
<li> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LALR%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">https://zh.wikipedia.org/wiki/LALR语法分析器</a></li>
<li> <a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/18c5b488a3b2e218c0e0cf2a7d4820d9da93a554">https://github.com/golang/go/commit/18c5b488a3b2e218c0e0cf2a7d4820d9da93a554</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/04/01/go-lexer-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2016/04/01/go-lexer-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">go-lexer-词法分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-04-01 14:40:36" itemprop="dateCreated datePublished" datetime="2016-04-01T14:40:36+08:00">2016-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/04/01/go-lexer-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/04/01/go-lexer-词法分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>词法分析一般是编译器的第一部分,而且词法分析很简单,就是一个有限状态机.<br>开始词法分析的过程就是把源文件转换成一组预先定义好的token的过程.<br>这一组被统一表现的token之后会被送入语法分析器进行语法解析,这里我们主要关注如何进行词法分析.</p>
<p>做词法分析就几种方法:</p>
<ol>
<li> 直接使用工具比如lex.</li>
<li> 使用更低一层的正则表达式.</li>
<li> 使用状态动作,构造一个状态机.</li>
</ol>
<p>而真正实现一个语言的话,使用工具没有什么错,但是问题是,很难获得正确的错误提示.<br>工具生成的错误处理很弱.而且需要学习另一门规则或特定的语法.生成的代码可能性能不好,难以优化,但是用工具可以非常简单实现词法分析.<br>早期编译器的设计阶段都会使用lex来做词法分析器,比如gcc和Go都是这么做的,但是到了后期一个真正生产化的语言可能不能依赖生成的代码,而需要做自己特定的修改和优化,所以自己实现一个词法分析器就显得比较重要了.</p>
<p>正则表达被人诟病的一个话题就是效率问题,比如perl拥有功能最强大的正则表达式,但是整个正则表达式引擎的效率却很低,Go在这方面牺牲了一些正则表达式的特性来保证正则表达式的效率不至于过低,但是正则表达式对于大量文本处理体现的弱势却是很明显的.因为可能我们要处理的状态其实不需要一个繁重的正则表达来解决.</p>
<p>其实实现一个词法分析器很简单,而且这种技能是基本不会变的,如果写过一次,以后都是同样的实现方式.</p>
<p>先看一下Go的实现,在Go的源码下面<code>go/token/token.go</code>目录里面是这么定义token的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Token is the set of lexical tokens of the Go programming language.</span><br><span class="line">type Token int</span><br></pre></td></tr></table></figure>
<p>其实就是个枚举类型,对于每种类型的字面值都有对应的token.<br>实际上这个只能算是一个token的类型.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// The list of tokens.</span><br><span class="line">const (</span><br><span class="line">        // Special tokens</span><br><span class="line">        ILLEGAL Token = iota</span><br><span class="line">        EOF</span><br><span class="line">        COMMENT</span><br><span class="line"></span><br><span class="line">        literal_beg</span><br><span class="line">        // Identifiers and basic type literals</span><br><span class="line">        // (these tokens stand for classes of literals)</span><br><span class="line">        IDENT  // main</span><br><span class="line">        INT    // 12345</span><br><span class="line">        FLOAT  // 123.45</span><br><span class="line">        IMAG   // 123.45i</span><br><span class="line">        CHAR   // &#x27;a&#x27;</span><br><span class="line">        STRING // &quot;abc&quot;</span><br><span class="line">	// 省略</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>枚举所有可以碰到的token类型.</p>
<p><code>go/token/position.go</code> 当中是关于token位置相关的定义.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// -----------------------------------------------------------------------------</span><br><span class="line">// Positions</span><br><span class="line"></span><br><span class="line">// Position describes an arbitrary source position</span><br><span class="line">// including the file, line, and column location.</span><br><span class="line">// A Position is valid if the line number is &gt; 0.</span><br><span class="line">//</span><br><span class="line">type Position struct &#123;</span><br><span class="line">        Filename string // filename, if any</span><br><span class="line">        Offset   int    // offset, starting at 0 </span><br><span class="line">        Line     int    // line number, starting at 1   </span><br><span class="line">        Column   int    // column number, starting at 1 (byte count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个很简单就是标示在文件中的位置,比较有意思的是<code>Pos</code>的定义<code>type Pos int</code>,这是位置标示的紧凑表示.接下来看看Pos和Position之间是如何转换的.</p>
<p>首先定义了一个<code>FileSet</code>,可以理解为把<code>File</code>的内容字节按顺序存放的一个大数组,而某个文件则属于数组的一个区间[base,base+size]中,base是文件的第一个字节在大数组中的位置,size是这个文件的大小,某个文件中的<code>Pos</code>是在[base,base+size]这个区间里的一个小标.</p>
<p>所以最后<code>Pos</code>能够压缩成一个整数来表示一个文件当中的位置,当需要使用的使用再从<code>FileSet</code>中转换出完整的<code>Position</code>对象.</p>
<p><code>go/token/serialize.go</code> 是对<code>FileSet</code>序列化,这里就略过了.</p>
<p>所以整个<code>go/token</code>包只是对token的一些定义和转化,词法分析的部分在<code>go/scanner</code>当中.</p>
<p>scan的主流程如下,主体是一个switch case表示的状态机,<br>比如碰到字符那么扫描到不为字符为止就作为一个标识符,比如碰到数字那么可能按照扫描数字,然后向后看一次小数字再扫描数字,直到没有数字为止.<br>scan每次会返回一个被扫描的token,压缩表示的位置,和字面值的字符串,这样就能够把一个源文件转化成一个token的记号流,也就是tokenize或者lexical analysis的过程.</p>
<pre><code>func (s *Scanner) Scan() (pos token.Pos, tok token.Token, lit string) &#123;
scanAgain:
        s.skipWhitespace() 
        // current token start
        pos = s.file.Pos(s.offset)
        // determine token value
        insertSemi := false
        switch ch := s.ch; &#123;
    /* 字符开头,开始扫描标识符 */
        case isLetter(ch):
                lit = s.scanIdentifier()
                if len(lit) &gt; 1 &#123;
                        // keywords are longer than one letter - avoid lookup otherwise
                        tok = token.Lookup(lit)
                        switch tok &#123;
                        case token.IDENT, token.BREAK, token.CONTINUE, token.FALLTHROUGH, token.RETURN:
                                insertSemi = true
                        &#125;
                &#125; else &#123;
                        insertSemi = true
                        tok = token.IDENT
                &#125; 
    /* 数字开头,扫描数字 */
        case &#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;:
                insertSemi = true
                tok, lit = s.scanNumber(false)
        default:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">看一下例子的结果.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
func ExampleScanner_Scan() &#123;
        // src is the input that we want to tokenize.
    // 需要记号化的源文件
        src := []byte(&quot;cos(x) + 1i*sin(x) // Euler&quot;)

        // Initialize the scanner.
        var s scanner.Scanner
        fset := token.NewFileSet()                      // positions are relative to fset
    // 添加到文件集合中
        file := fset.AddFile(&quot;&quot;, fset.Base(), len(src)) // register input &quot;file&quot;
    // 初始化scanner
        s.Init(file, src, nil /* no error handler */, scanner.ScanComments)

        // Repeated calls to Scan yield the token sequence found in the input.
        for &#123;
                pos, tok, lit := s.Scan()
                if tok == token.EOF &#123;
                        break
                &#125;
                fmt.Printf(&quot;%s\t%s\t%q\n&quot;, fset.Position(pos), tok, lit)
        &#125;
    // 不断扫描就能得到如下结果
    // 词法分析就是做这样一件事情.
        // output:
        // 1:1  IDENT   &quot;cos&quot;
        // 1:4  (       &quot;&quot;
        // 1:5  IDENT   &quot;x&quot;
        // 1:6  )       &quot;&quot;
        // 1:8  +       &quot;&quot;
        // 1:10 IMAG    &quot;1i&quot;
        // 1:12 *       &quot;&quot;
        // 1:13 IDENT   &quot;sin&quot;
        // 1:16 (       &quot;&quot;
        // 1:17 IDENT   &quot;x&quot;
        // 1:18 )       &quot;&quot;
        // 1:20 ;       &quot;\n&quot;
        // 1:20 COMMENT &quot;// Euler&quot;
&#125;

```

我在我的数据结构字符画生成工具[1]里面就实现了一个词法分析器,方便我用简单的语法构造一个字符画,然后插入到注释中辅助解释.
唯一的不同的是,我使用了channel读取token记号,来增加并发,而go本身的记号化是串行的,当然,这点区别其实没有多大,而且这个设计
在Go的模板包里面使用了,Rob Pike也有过相关的演讲[2].

1.  https://github.com/ggaaooppeenngg/cpic/blob/master/lex.go
2.  http://cuddle.googlecode.com/hg/talk/lex.html#landing-slide
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/03/18/git-commit-message-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2016/03/18/git-commit-message-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD/" class="post-title-link" itemprop="url">git-commit-message- 如何写好</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-03-18 13:00:50" itemprop="dateCreated datePublished" datetime="2016-03-18T13:00:50+08:00">2016-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/03/18/git-commit-message-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/03/18/git-commit-message-如何写好/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="commit-message"><a href="#commit-message" class="headerlink" title="commit message"></a>commit message</h1><p>git commit message 是我们经常要用到的东西，但是大部分人都写得很随便，翻 git log 看到的信息也是不明觉厉，这里结合其他资料阐述一下如何写好一个 commit message。</p>
<p>其实 git commit message 对于不同的项目有不同的要求。 比如 Angular 的 commit message<br>标题要加分类，比如是属于 refactor 还是 docs , 还有影响范围（例如 属于全部、*, 还是编译器 $compiler)，但是在 Linux Kernel 和类似的 GNU style 的项目里面是类似这样的 commit header。</p>
<p>“mm, tracing: unify mm flags handling in tracepoints and printk”</p>
<p>如果没有子系统要求开头大写，如果有涉及的子系统就说明涉及的子系统并且跟上冒号做解释，冒号后的小写。这个根据具体的场景有不同的要求，但是核心就是简洁明了，另外要使用祈使句。</p>
<p>这样的好处，就能通过<code>git log --pretty=format:%s</code>来遍历所有的 log message，对于修改一目了然。</p>
<h1 id="commit-header"><a href="#commit-header" class="headerlink" title="commit header"></a>commit header</h1><p>第一条规则因项目而异。<br>比如 Angular 的规则是：<code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></p>
<p>type（必需），scope（可选）和 subject（必需）</p>
<p>angular 要求的 type 有几种</p>
<ul>
<li>  feat: 新功能 (feature)</li>
<li>  fix: 修补 bug</li>
<li>  docs: 文档 (documentation)</li>
<li>  style: 格式（不影响代码运行的变动）</li>
<li>  refactor: 重构（即不是新增功能，也不是修改 bug 的代码变动）</li>
<li>  test: 增加测试</li>
<li>  chore: 构建过程或辅助工具的变动</li>
</ul>
<p>scope 表示影响的范围，subject 开头小写，使用祈使句，结尾不用。号。</p>
<p>但是在 runc 里面要求比较简单，使用祈使句，并且开头大写就可以，结尾不带。号。</p>
<p>kernel 的 subject 如果带上子系统比如 (mm)，就要 mm: 开头，然后不用大写。<br>不然也要开头大写。总之 subject 的部分要求根据项目不同有一些不同，但是 body 部分要求是类似的。</p>
<h1 id="commit-body"><a href="#commit-body" class="headerlink" title="commit body"></a>commit body</h1><p>body 要和 header 空格一行，每行不要超过 72 个字符，并且对改动进行解释。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在 50 个字符内概括你的改动标题</span><br><span class="line"></span><br><span class="line">更详细的解释，限制到 72 个字符，和标题隔开一行。</span><br><span class="line">有什么副作用或者后遗症也要指出。</span><br><span class="line"></span><br><span class="line">如果有任务管理器，可以在结尾指定。</span><br><span class="line"></span><br><span class="line">Resolves: #123</span><br><span class="line">See also: #456, #789</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>Angular</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fix($compile): couple of unit tests for IE9</span><br><span class="line"></span><br><span class="line">Older IEs serialize html uppercased, but IE9 does not...</span><br><span class="line">Would be better to expect case insensitive, unfortunately jasmine does</span><br><span class="line">not allow to user regexps for throw expectations.</span><br><span class="line"></span><br><span class="line">Closes #392</span><br><span class="line">Breaks foo.bar api, foo.baz should be used instead</span><br></pre></td></tr></table></figure>

<p>GNU style</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Author: Aleksa Sarai &lt;asarai@suse.de&gt;</span><br><span class="line">Date:   Sun Mar 13 04:53:20 2016 +1100</span><br><span class="line"></span><br><span class="line">    libcontainer: add pids.max to PidsStats</span><br><span class="line"></span><br><span class="line">    In order to allow nice usage statistics (in terms of percentages and</span><br><span class="line">    other such data), add the value of pids.max to the PidsStats struct</span><br><span class="line">    returned from the pids cgroup controller.</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Aleksa Sarai &lt;asarai@suse.de&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Author: Alexander Morozov &lt;lk4d4@docker.com&gt;</span><br><span class="line">Date:   Fri Mar 27 10:50:32 2015 -0700</span><br><span class="line"></span><br><span class="line">    Use syscall.Kill instead of p.cmd.Process.Kill</span><br><span class="line"></span><br><span class="line">    We need this to unmask syscall.ESRCH error, which handled in docker and</span><br><span class="line">    can be handled by other clients.</span><br><span class="line"></span><br><span class="line">    Closes #457</span><br><span class="line"></span><br><span class="line">    Signed-off-by: Alexander Morozov &lt;lk4d4@docker.com&gt;</span><br><span class="line">    Acked-by: Hugh Dickins &lt;hughd@google.com&gt;</span><br><span class="line">    Reviewed-by: Michal Hocko &lt;mhocko@suse.com&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在进行 code review 的时候，一般会带上签名 <code>Signed-off-by</code> 表示自己对这段改动负责，matainer 也会查看这段代码如果理解这段代码并且进行了测试同样对这段代码负责也要签名，如果只是保证自己觉得代码无误要使用 <code>Reviewed-by</code>，如果表示只是知道这个带动就带上<code>Acked-by</code>。 <code>git commit -s</code> 可以自动带上 <code>Signed-off-by</code>。</p>
<p>总之，一个好的 commit message 是一个好习惯，如果项目从一开始打 commit message 就很随便，那 commit log 的意义就没有了，导致根本没人会看。如果有意义整个代码就有据可查了，看起来也很漂亮。</p>
<p>参考：</p>
<ol>
<li> <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></li>
<li> <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/process/submitting-patches.html">Submitting patches: the essential guide to getting your code into the kernel</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/02/09/timer%E5%9C%A8go%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E7%B2%BE%E7%A1%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2016/02/09/timer%E5%9C%A8go%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E7%B2%BE%E7%A1%AE/" class="post-title-link" itemprop="url">timer 在 Golang 中可以有多精确？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-02-09 01:58:52" itemprop="dateCreated datePublished" datetime="2016-02-09T01:58:52+08:00">2016-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/02/09/timer%E5%9C%A8go%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E7%B2%BE%E7%A1%AE/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/02/09/timer在go可以有多精确/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文主要讨论 timer heap 在 Go 中的管理，以及运行时对于时间是如何获取的问题，从而引出一个结论，我们对于 timer 的准确度可以有多大的依赖。</p>
<p>首先我们看一下 Go 是如何获取时间的，找到<code>time.Now</code>, 发现最终调用的是下面这个汇编函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// func now() (sec int64, nsec int32)</span><br><span class="line">TEXT time·now(SB),NOSPLIT,$16</span><br><span class="line">	// Be careful. We&#x27;re calling a function with gcc calling convention here.</span><br><span class="line">	// We&#x27;re guaranteed 128 bytes on entry, and we&#x27;ve taken 16, and the</span><br><span class="line">	// call uses another 8.</span><br><span class="line">	// That leaves 104 for the gettime code to use. Hope that&#x27;s enough!</span><br><span class="line">	// 这里只能保证调用 gettime 函数的时候有 104 个字节给这个函数作为栈</span><br><span class="line">	// 因为返回值用了 16 个字节，这个函数本身会用 8 个字节，到调用 gettime 的时候只剩 104 个字节可以用。</span><br><span class="line">	MOVQ	runtime·__vdso_clock_gettime_sym(SB), AX</span><br><span class="line">	CMPQ	AX, $0</span><br><span class="line">	JEQ	fallback</span><br><span class="line">	MOVL	$0, DI // CLOCK_REALTIME</span><br><span class="line">	LEAQ	0(SP), SI</span><br><span class="line">	CALL	AX</span><br><span class="line">	MOVQ	0(SP), AX	// sec</span><br><span class="line">	MOVQ	8(SP), DX	// nsec</span><br><span class="line">	MOVQ	AX, sec+0(FP)</span><br><span class="line">	MOVL	DX, nsec+8(FP)</span><br><span class="line">	RET</span><br><span class="line">fallback:</span><br><span class="line">	LEAQ	0(SP), DI</span><br><span class="line">	MOVQ	$0, SI</span><br><span class="line">	MOVQ	runtime·__vdso_gettimeofday_sym(SB), AX</span><br><span class="line">	CALL	AX</span><br><span class="line">	MOVQ	0(SP), AX	// sec</span><br><span class="line">	MOVL	8(SP), DX	// usec</span><br><span class="line">	IMULQ	$1000, DX</span><br><span class="line">	MOVQ	AX, sec+0(FP)</span><br><span class="line">	MOVL	DX, nsec+8(FP)</span><br><span class="line">	RET</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一行<code>TEXT time·now(SB),NOSPLIT,$16</code>, 其中<code>time·now(SB)</code>表示函数<code>now</code>的地址，<code>NOSPLIT</code>标志不依赖参数，<code>$16</code>表示返回的内容是 16 个字节，Go 的汇编语法具体可以参考 Go asm 文档 [1].</p>
<p>首先是取出<code>__vdso_clock_gettime_sym(SB)</code>（这是一个符号，指向的其实是 clock_gettime 函数，man clock_gettime 可以看到 glibc 的定义）的地址，如果符号不为空的话就把栈顶的地址计算出来传入 SI(LEA 指令）. DI 和 SI 分别是<code>system call</code>的前两个参数的寄存器，这个相当于调用<code>clock_gettime(0,&amp;ret)</code>. fallback 分支是当对应的符号没有初始化就退而求其次调用<code>gettimeofday</code>(man gettimeofday 可以看到 libc 的定义）这个函数。</p>
<p>Go 的函数调用确保会有至少 128 个字节的栈（注意不是 goroutine 的栈）, 具体可以参考<code>runtime/stack.go</code>里的<code>_StackSmall</code>, 但是进入对应的 c 函数以后，栈的增长就不能够由 Go 控制了，所以剩下的 104 个字节要确保这个调用不会栈溢出.（不过一般不会，因为这两个获取时间的函数不复杂）.</p>
<p>先说函数符号的事，查阅相关资料可以看出来，VDSO 是 Virtual Dynamic Shared Object, 就是内核提供的虚拟的.so, 这个.so 文件不在磁盘上，而是在内核里头，映射到了用户空间。具体细节可以看 so 上的一个回答 [2]. 其中一个链接中有一些描述 [3].</p>
<blockquote>
<p> One way of obtaining a fast gettimeofday() is by writing the current time in a fixed place, on a page mapped into the memory of all applications, and updating this location on each clock interrupt.<br> These applications could then read this fixed location with a single instruction - no system call required.<br> Concerning gettimeofday(), a vsyscall version for the x86-64 is already part of the vanilla kernel.<br> Patches for i386 exist. (An example of the kind of timing differences: John Stultz reports on an experiment where he measures gettimeofday() and finds 1.67 us for the int 0x80 way, 1.24 us for the sysenter way, and 0.88 us for the vsyscall.)</p>
</blockquote>
<p>简单来说就是一种加速系统调用的机制加兼容模式。像<code>gettimeofday</code>这样的函数如果像普通系统调用一样的话，有太多的上下文切换，特别是一些频繁获取时间的程序，所以一般<code>gettimeofday</code>是通过这种机制调用的. 单独在用户空间映射了一段地址，在里面的是内核暴露的一些系统调用，具体可能是 syscall 或者 int 80 或者 systenter 的方式，由内核决定更快的调用方式，防止出现 glibc 版本和 kernel 版本不兼容的问题.(vDSO 是 vsyscall 的一个升级版本，避免了一些安全问题，映射不再静态固定）.</p>
<p>从内核中可以看出获取系统调用是由时间中断更新的，其调用栈如下 [5].</p>
<blockquote>
<p> Hardware timer interrupt (generated by the Programmable Interrupt Timer - PIT)<br> -&gt; tick_periodic();<br>   -&gt; do_timer(1);<br>     -&gt; update_wall_time();<br>       -&gt; timekeeping_update(tk, false);<br>         -&gt; update_vsyscall(tk);</p>
</blockquote>
<p><code>update_wall_time</code>使用的是时钟源 (clock source) 的时间，精度能达到 ns 级别。<br>但是一般 Linux kernel 的时间中断是 100HZ, 高的也有 1000HZ 的，也就是说这个时间一般是在 10ms 或者 1ms 中断处理时更新一次。<br>从操作系统的角度看时间粒度大概是 ms 级别. 但是，这个只是一个基准值. 每次获取时间的时候还是会取得时钟源<br>的时间（时钟源有很多种 [9]，可能是硬件的计数器，也可能就是中断的 jiffy，一般是可以达到 ns）. 获取时间的精度还是能到 us 和几百 ns 之间。<br>因为系统调用本身还要花时间，理论上更精确的时间就不是通过这个系统调用获得了，而是需要直接用汇编指令”rdtsc”读 CPU 的 cycle 来得到精确时间。</p>
<p>接下来说，获取时间的函数符号的寻找过程又涉及了 ELF 的一些内容，其实就是动态链接的过程，把.so 中的函数符号的地址解析到并且存入函数指针中，比如<code>__vdso_clock_gettime_sym</code>, 关于链接的内容可以阅读”程序员的自我修养”这本书 [4].</p>
<p>其他函数例如<code>TEXT runtime·nanotime(SB),NOSPLIT,$16</code>也是类似的过程. 这个函数就能获取时间。</p>
<p>看完时间获取的过程，再来看看 Go 运行时的部分，瞧瞧<code>timer heap</code>是如何管理的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Package time knows the layout of this structure.</span><br><span class="line">// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.</span><br><span class="line">// For GOOS=nacl, package syscall knows the layout of this structure.</span><br><span class="line">// If this struct changes, adjust ../syscall/net_nacl.go:/runtimeTimer.</span><br><span class="line">type timer struct &#123;</span><br><span class="line">        i int // heap index</span><br><span class="line"></span><br><span class="line">        // Timer wakes up at when, and then at when+period, ... (period &gt; 0 only)</span><br><span class="line">        // each time calling f(now, arg) in the timer goroutine, so f must be</span><br><span class="line">        // a well-behaved function and not block.</span><br><span class="line">        when   int64</span><br><span class="line">        period int64</span><br><span class="line">        f      func(interface&#123;&#125;, uintptr)</span><br><span class="line">        arg    interface&#123;&#125;</span><br><span class="line">        seq    uintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timer 是以 heap 的形式管理的，heap 是个完全二叉树，用数组就可以存下，i 是 heap 的 index.<br>when 是 goroutine 被唤醒的时间，period 是唤醒的间隙，下次唤醒的时间是 when+period, 依次类推。<br>调用函数<code>f(now, arg)</code>, now 是时间戳。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var timers struct &#123;</span><br><span class="line">        lock         mutex</span><br><span class="line">        gp           *g</span><br><span class="line">        created      bool</span><br><span class="line">        sleeping     bool</span><br><span class="line">        rescheduling bool</span><br><span class="line">        waitnote     note</span><br><span class="line">        t            []*timer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个的 timer heap 由<code>timers</code>管理.gp 指向的是一个<code>g</code>的指针，也就是调度器当中的 G 结构，一个 goroutine 的状态维护的结构，指向的是时间管理器的单独的一个 goroutine, 这个不属于用户而是运行时启动的 goroutine.（当然只有使用了 timer 才会启动，不然不会有这个 goroutine).<code>lock</code>保证 timers 的线程安全.waitnote 是一个条件变量。</p>
<p>看一下<code>addtimer</code>函数，他是整个计时器开始的入口，当然本身只是加了锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func addtimer(t *timer) &#123;</span><br><span class="line">        lock(&amp;timers.lock)</span><br><span class="line">        addtimerLocked(t)</span><br><span class="line">        unlock(&amp;timers.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看<code>addtimerLocked</code>可以看到就是入 heap 的过程了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// Add a timer to the heap and start or kick the timer proc.</span><br><span class="line">// If the new timer is earlier than any of the others.</span><br><span class="line">// Timers are locked.</span><br><span class="line">func addtimerLocked(t *timer) &#123;</span><br><span class="line">        // when must never be negative; otherwise timerproc will overflow</span><br><span class="line">        // during its delta calculation and never expire other runtime·timers.</span><br><span class="line">        if t.when &lt; 0 &#123;</span><br><span class="line">                t.when = 1&lt;&lt;63 - 1</span><br><span class="line">        &#125;</span><br><span class="line">        t.i = len(timers.t)</span><br><span class="line">        timers.t = append(timers.t, t)</span><br><span class="line">        siftupTimer(t.i)</span><br><span class="line">        if t.i == 0 &#123;</span><br><span class="line">                // siftup moved to top: new earliest deadline.</span><br><span class="line">                if timers.sleeping &#123;</span><br><span class="line">                        timers.sleeping = false</span><br><span class="line">                        notewakeup(&amp;timers.waitnote)</span><br><span class="line">                &#125;</span><br><span class="line">                if timers.rescheduling &#123;</span><br><span class="line">                        timers.rescheduling = false</span><br><span class="line">                        goready(timers.gp, 0)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if !timers.created &#123;</span><br><span class="line">                timers.created = true</span><br><span class="line">                go timerproc()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先从下面的<code>if !timers.created</code>分支看起，如果 timers 对应没有创建就 go 一个 timerproc, timeproc 的定义如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// Timerproc runs the time-driven events.</span><br><span class="line">// It sleeps until the next event in the timers heap.</span><br><span class="line">// If addtimer inserts a new earlier event, addtimer1 wakes timerproc early.</span><br><span class="line">func timerproc() &#123;</span><br><span class="line">        timers.gp = getg()</span><br><span class="line">        for &#123;</span><br><span class="line">                lock(&amp;timers.lock)</span><br><span class="line">                timers.sleeping = false</span><br><span class="line">                now := nanotime()</span><br><span class="line">                delta := int64(-1)</span><br><span class="line">                for &#123;</span><br><span class="line">                        if len(timers.t) == 0 &#123;</span><br><span class="line">                                delta = -1</span><br><span class="line">                                break</span><br><span class="line">                        &#125;</span><br><span class="line">                        t := timers.t[0]</span><br><span class="line">                        delta = t.when - now</span><br><span class="line">                        if delta &gt; 0 &#123;</span><br><span class="line">                                break</span><br><span class="line">                        &#125;</span><br><span class="line">                        if t.period &gt; 0 &#123;</span><br><span class="line">                                // leave in heap but adjust next time to fire</span><br><span class="line">                                t.when += t.period * (1 + -delta/t.period)</span><br><span class="line">                                siftdownTimer(0)</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                                // remove from heap</span><br><span class="line">                                last := len(timers.t) - 1</span><br><span class="line">                                if last &gt; 0 &#123;</span><br><span class="line">                                        timers.t[0] = timers.t[last]</span><br><span class="line">                                        timers.t[0].i = 0</span><br><span class="line">                                &#125;</span><br><span class="line">                                timers.t[last] = nil</span><br><span class="line">                                timers.t = timers.t[:last]</span><br><span class="line">                                if last &gt; 0 &#123;</span><br><span class="line">                                        siftdownTimer(0)</span><br><span class="line">                                &#125;</span><br><span class="line">                                t.i = -1 // mark as removed</span><br><span class="line">                        &#125;</span><br><span class="line">                        f := t.f</span><br><span class="line">                        arg := t.arg</span><br><span class="line">                        seq := t.seq</span><br><span class="line">                        unlock(&amp;timers.lock)</span><br><span class="line">                        if raceenabled &#123;</span><br><span class="line">                                raceacquire(unsafe.Pointer(t))</span><br><span class="line">                        &#125;</span><br><span class="line">                        f(arg, seq)</span><br><span class="line">                        lock(&amp;timers.lock)</span><br><span class="line">                &#125;</span><br><span class="line">                if delta &lt; 0 || faketime &gt; 0 &#123;</span><br><span class="line">                        // No timers left - put goroutine to sleep.</span><br><span class="line">                        timers.rescheduling = true</span><br><span class="line">			// 如果没有 timers 剩余，就让 G 进入 sleep 状态。</span><br><span class="line">			// goparkunlock 的作用是解开 G 和 M 的联系，让 goroutine sleep 而 M</span><br><span class="line">			// 寻找下一个 G 来执行。</span><br><span class="line">                        goparkunlock(&amp;timers.lock, &quot;timer goroutine (idle)&quot;, traceEvGoBlock, 1)</span><br><span class="line">                        continue</span><br><span class="line">                &#125;</span><br><span class="line">                // At least one timer pending.  Sleep until then.</span><br><span class="line">                timers.sleeping = true</span><br><span class="line">		// 清零 waitnote.</span><br><span class="line">                noteclear(&amp;timers.waitnote)</span><br><span class="line">                unlock(&amp;timers.lock)</span><br><span class="line">		// 调用 M 结构对应的 OS-dependent, OS-thread 的信号量让 M 进入 sleep 状态。</span><br><span class="line">		// 只会在超时的时候或者条件变量 waitnote 触发才会被唤醒。</span><br><span class="line">                notetsleepg(&amp;timers.waitnote, delta)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>timeproc 的主体就是从最小堆中取出 timer 然后回调函数，如果 period 大于 0 就把 timer 的 when 修改并且存回 heap 并调整，如果小于 0 就直接删除（对应的分别是标准库的 ticker 和 timer), 进入 OS 信号量中睡眠等待下次处理，（当然可以被 waitnote 变量唤醒）, 这样一直循环，说白了就是靠信号量的超时机制来实现了运行时的 sleep[8]. 然后当完全没有 timer 剩余的时候，G 结构表示的 goroutine 进入睡眠状态，承载 goroutine 的 M 结构所代表的 OS-thread 会寻找其它可运行的 goroutine 执行. 具体关于运行时调度的细节可以参考雨痕大叔的笔记 [7].</p>
<p>看完这一路 case, 回到<code>addtimerLocked</code>, 当加入一个新的<code>timer</code>时，会作依次检查，也就是说最新插入的<code>timer</code>是在堆顶的话，会唤醒睡眠的 timergorountine 开始从 heap 上检查过时的<code>timer</code>并执行. 这里的唤醒和之前的睡眠是两种对应的状态<code>timers.sleeping</code>是进入了 M 的 os 信号量睡眠。<br><code>timers.rescheduling</code>是进入了 G 的调度睡眠，而 M 并没有睡眠，让 G 重新进入可运行状态. 时间超时和新 timer 的加入，两者结合成为了<code>timer</code>运行时的驱动力。</p>
<p>看完了 time 的实现，再回过头来回答文章最初的问题”timer 可以有多精确”, 其实和两个原因有关，一个是操作系统本身的时间粒度，一般是 us 级别的，时间基准更新是 ms 级别的，时间精度能到 us 级别，另外一个就是<code>timer</code>本身的 goroutine 的调度问题，如果运行时的负载过大或者操作系统本身的负载过大，会导致<code>timer</code>本身的 goroutine 响应不及时，导致 timer 触发并不及时，可能导致一个 20ms 的 timer 和一个 30ms 的 timer 之间像是并发的一样（这也是笔者碰到的问题，特别是一些被 cgroup 限制了的容器环境，cpu 时间分配很少的条件下）, 所以有时候我们不能过分相信 timer 的时序来保证程序的正常运行.<code>NewTimer</code>的注释也强调了”NewTimer creates a new Timer that will send the current time on its channel after <strong>at least</strong> duration d.”, 没有人能保证 timer 按点执行，当然如果你的间隔离谱的大的话其实就可以忽略这方面的影响了：)</p>
<pre><code>
参考链接：

1.  Go Assembly https://golang.org/doc/asm
2.  http://stackoverflow.com/questions/19938324/what-are-vdso-and-vsyscall
3.  http://www.win.tue.nl/~aeb/linux/lk/lk-4.html
4.  http://book.douban.com/subject/3652388/
5.  http://linuxmogeb.blogspot.com/2013/10/how-does-clockgettime-work.html
6.  时钟源 http://blog.csdn.net/droidphone/article/details/7975694
7.  Go 源码剖析 https://github.com/qyuhen/book/blob/master
    /Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.pdf
8.  带超时的信号量的实现 http://lxr.free-electrons.com/source/kernel/locking/semaphore.c#L204
9.  内核的时钟源 http://blog.csdn.net/droidphone/article/details/7975694
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2014 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ggaaooppeenngg</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"ggaaooppeenngg","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
