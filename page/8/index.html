<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_85tctgPWrqH2EPVuuD5IT6KE-tW8nH0hTISJDMnShg">
  <meta name="baidu-site-verification" content="bb16c5b1fd3302c18e0015bef11eea42">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ggaaooppeenngg.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:type" content="website">
<meta property="og:title" content="ggaaooppeenngg">
<meta property="og:url" content="https://ggaaooppeenngg.github.io/page/8/index.html">
<meta property="og:site_name" content="ggaaooppeenngg">
<meta property="og:description" content="为什么计算机科学是无限的但生命是有限的">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ggaaooppeenngg">
<meta property="article:tag" content="ggaaooppeenngg,kernel,sysml,golang,python,rust">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ggaaooppeenngg.github.io/page/8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ggaaooppeenngg</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-62096626-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-62096626-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?bb16c5b1fd3302c18e0015bef11eea42"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ggaaooppeenngg</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">为什么计算机科学是无限的但生命是有限的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">135</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">14</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">79</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ggaaooppeenngg</p>
  <div class="site-description" itemprop="description">为什么计算机科学是无限的但生命是有限的</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">135</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ggaaooppeenngg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ggaaooppeenngg" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:peng.gao.dut@gmail.com" title="E-Mail → mailto:peng.gao.dut@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2015/12/22/VFS-%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2015/12/22/VFS-%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84/" class="post-title-link" itemprop="url">VFS- 内核是如何抽象文件系统的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-12-22 00:30:06" itemprop="dateCreated datePublished" datetime="2015-12-22T00:30:06+08:00">2015-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">内核</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%86%85%E6%A0%B8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">文件系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%86%85%E6%A0%B8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/VFS/" itemprop="url" rel="index"><span itemprop="name">VFS</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2015/12/22/VFS-%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2015/12/22/VFS-内核是如何抽象文件系统的/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>UNIX 的哲学之一就是一切皆文件，所以可以看出文件系统在操作系统层面是非常重要的，很多基本单元都是通过文件系统展开的，所以了解文件系统有利于分析整个操作系统的脉络。</p>
<p>在 Linux 当中文件系统千奇百种，比较常见的有 EXT3、EXT4，还有基于内存的 ramfs、tmpfs 和基于网络的 nfs，和基于用户态的 fuse，当然 fuse 应该不能完全的文件系统，只能算是一个能把文件系统实现放到用户态的模块，满足了内核文件系统的接口，他们都是文件系统的一种实现。这个 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File_system#Linux">wiki</a> 上列出了很多 Linux 的文件系统类型。</p>
<p>对于这些文件系统，Linux 做了一层抽象就是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Virtual_file_system">VFS</a> 虚拟文件系统，这个其实就是软件设计必然的过程，对于不同的实现规定统一的接口，也就是定义与实现分离，如果想要自己实现一个文件系统的话只要实现一个满足 VFS 层的文件系统就能加入到内核当中。所以其实内核的文件和我们普通理解的文件其实有点不一样，这里的文件更像是一个接口，只不过最初是从磁盘上的文件衍生过来的，最后抽象成了一种可以对接各种功能的接口。</p>
<p>下面就开始剖析 VFS 的主要内容。</p>
<p>VFS 有几个必不可少的元素，<code>filesystem_type，super_block</code>, <code>dentry</code>, <code>inode</code>, <code>file</code>, <code>vfsmount</code>, <code>nameidata</code> 等等。这里抛开具体的代码，先从概念入手，下一篇博文，我会实现一个简单的文件系统，再基于代码分析具体的概念。</p>
<p>首先是 <code>filesystem_type</code> 和 <code>super_block</code>，这两者的关系有点类似于软件中的 <code>class</code> 和 <code>object</code> 的关系。在内核当中有一个全局的<code>file_systems</code>链表串接了所有的文件系统类型的代表<code>filesystem_type</code>，对于文件系统的注册和删除就是在链表当中增加和删除对应的节点。而<code>super_block</code>就是一个文件系统的实例。本身也是通过全局链表串连起来的。<code>filesystem_type</code>本身非常简单，定义了获取和删除<code>super_block</code>的接口，和一些共同的相关信息。</p>
<p>对于<code>super_block</code>来说超级块定义了文件系统的具体信息和对应文件系统的接口，比如<code>write_super</code>,<code>alloc_inode</code>,<code>sync_fs</code>等，这些都是有具体的文件系统实现的。所有的<code>inode</code>都链接到了<code>super_block</code>。</p>
<p>对于文件系统来说挂载点是个很有意思的点，在内核当中挂载点用<code>vfsmount</code>表示，挂载点是文件系统之间的衔接部分，如果要添加一个新的文件系统势必要将文件系统挂载在某个目录下面使得文件系统生效，<code>vfsmount</code>就是这样一个接口。当文件系统挂载以后原目录将不可见。<code>vfsmount</code>的主要内容是<code>vfsmount</code>的拓扑关系以及指向的目录和<code>super_block</code>。所以从宏观的角度来说，整个文件系统的组织是如图这样的。</p>
<p><img data-src="fs.png" alt="fs.png"></p>
<p>这是文件系统本身这个结构在操作系统里的组织结构，接下来分析文件系统满足 VFS 要包含哪些内容。</p>
<p>第一个要说的就是 dentry，dentry 表现的是文件在文件系统中的树状关系，dentry 也要实现相应的接口，包括 <code>d_delete</code>，<code>d_release</code>，<code>d_compare</code>等接口。<br>dentry 代表的是目录结构中的一个文件，而文件其实就是没有子目录的文件。dentry 链接到了超级快和父 dentry 和子 dentry 以及对应的 inode。</p>
<p>接下来是 inode, inode 本身代表的一个文件，保存的信息很多，包括文件的大小，创建时间，文件的块大小等参数，以及文件的读写缓存等信息，还要定义对应的针对文件的函数接口，包括增删改查等等。没有文件名，因为它代表的是文件的原信息，具体的路径的表示依赖<code>dentry</code>。</p>
<p>dentry 和 inode 的关系是多对一的，即多个 dentry 可以指向同一个文件，这和 linux 当中的文件链接有关。</p>
<p>接下来就是 file，file 虽然叫 file 但是对应的却不像 inode 一样，它对应的是一个进程所打开的文件。例如两个不同的进程打开了磁盘上的同一个文件，那么他们对应的 inode 是相同的，这也是 inode 意义。但是不同进程之间的 file 不是同一个引用，file 本身的结构还是和文件操作有关的。</p>
<p>整个关系如图所示。</p>
<p><img data-src="file.png" alt="file.png"></p>
<p>对应的文件目录如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── a</span><br><span class="line">│   └── ab</span><br><span class="line">└── b</span><br><span class="line">    ├── bc -&gt; ../a/ab</span><br><span class="line">    └── bd</span><br></pre></td></tr></table></figure>


<p>图中展示了一个硬链接代表着 bc 和 ab 的 dentry 指向了同一个<code>inode</code>，硬链接是不同 dentry 指向同一个<code>inode</code>，这也是为什么硬链接不能夸文件系统，因为<code>inode</code>是属于特定文件系统的。<br>图中其实<code>inode</code>是串联在<code>super_block</code>上的，<code>super_block</code>维护了文件系统中`inodes，因为画上去太乱了所以省略了。</p>
<p>VFS 的整体结构就是这样，接下来简要地说几个具体内容：</p>
<p>所谓的打开文件描述符其实就是进程的 files 数组这个文件描述符表的下标，通过对应的 fd 就能找到 file 结构。例如 dentry，vfsmount 这样的结构都有一个 hashtable 来缓存搜索的内容，这样就能加开目录的遍历搜索。</p>
<p>inode 其实也有一个全局的 hashtable 用于快速查找，inode 本身能代表的东西很多，一切皆文件就体现在他身上，他既可以表示一个 socket，也可以表示一个管道，还可以表示块设备、字符设备，然后就是普通文件了。</p>
<p>以上讲的就是整个内核当中 VFS 层的抽象，并没有牵涉到具体的文件系统，在下一篇博客我将会实现一个简单的文件系统，不就具体的代码分析，来熟悉这里提到的这些概念。<br>其实了解了概念以后，就会给人一种不过如此的感觉，真正值得玩味的是下层的实现，这也是我后面的博客将会介绍的内容。比如基于磁盘的文件系统更多的是要关注 I\O 层的东西。</p>
<p>其实内核的 I\O 路径是这样的：user space -&gt; VFS -&gt; FS -&gt; I\O layer -&gt; I\O scheduler(optional) -&gt; block_driver -&gt; block_device, 一个 I\O 经过了这些才真正到达了对应的存储上。</p>
<p>一个用户态的系统调用先通过 VFS 找到对应的文件系统再向下传递 I\O，这是 I\O 的一般路径。所以说对于用户来说，一切都是操作文件了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2015/11/19/map%E5%BD%93%E4%B8%ADbool%E7%9C%9F%E7%9A%84%E5%80%BC%E5%BE%97%E4%BC%98%E5%8C%96%E6%88%90struct-%E5%90%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2015/11/19/map%E5%BD%93%E4%B8%ADbool%E7%9C%9F%E7%9A%84%E5%80%BC%E5%BE%97%E4%BC%98%E5%8C%96%E6%88%90struct-%E5%90%97/" class="post-title-link" itemprop="url">map当中bool真的值得优化成struct{}{}吗?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-11-19 14:51:55" itemprop="dateCreated datePublished" datetime="2015-11-19T14:51:55+08:00">2015-11-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2015/11/19/map%E5%BD%93%E4%B8%ADbool%E7%9C%9F%E7%9A%84%E5%80%BC%E5%BE%97%E4%BC%98%E5%8C%96%E6%88%90struct-%E5%90%97/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2015/11/19/map当中bool真的值得优化成struct-吗/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先抛出一个问题,在Go中当我们想实现一个集合的时候,可以用map来实现.而map本身就可以通过”comma ok”机制来获取该建是否存在,例如<code>_ , ok := map[&quot;key&quot;]</code>,如果没有对应的值,ok为false,以此就可以实现集合.有时候我们会选择<code>map[string]bool</code>这类方式来定义这个集合,但是因为有了”comma ok”这个语法,还可以定义成<code>map[string]struct&#123;&#125;</code>的形式,值不再占用内存.</p>
<p>后者可以表示两种状态有或者无,而前者其实有三种状态,有的时候表示true或者false,或者没有.<br>很多时候我们会选择<code>map[string]struct&#123;&#125;</code>来表示集合的实现,但是这样真得值得么?</p>
<p>这里要从map的实现说起.map的实现是一个hash表.表结构由两个结构体表示,分别是hmap和bmap,前者表示这个map结构,后者表示了map的hash表下的bucket结构.</p>
<p>一切要从map的实现开始讲起.</p>
<p>map是由桶数组组成的,每个桶的表示如下.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// A bucket for a Go map.</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">        tophash [bucketCnt]uint8</span><br><span class="line">	// 这里的bucetCnt是8,是个固定值,每个桶跟8个k-v对.</span><br><span class="line">	// 先是8个key,后是8个value.</span><br><span class="line">	// 最后是一个overflow指针指向串联的bucket.</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而hmap表示如下,其实就是一个头信息.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// A header for a Go map.</span><br><span class="line">type hmap struct &#123;</span><br><span class="line">        flags uint8 // 一些标志j</span><br><span class="line">        B     uint8  // bucket数量的log_2</span><br><span class="line">        hash0 uint32 // hash 种子</span><br><span class="line"></span><br><span class="line">        buckets    unsafe.Pointer // buckets 数组的指针.</span><br><span class="line">        oldbuckets unsafe.Pointer // 增长时需要被替换的数组的指针.</span><br><span class="line">        nevacuate  uintptr        // 被提升的桶的数量(增长时,桶会从oldbuckets移到buckets当中)</span><br><span class="line"></span><br><span class="line">        overflow *[2]*[]*bmap // 指向串联桶的指针.</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>bmap这个结构类似于C的定义,后面其实还有一些成员,但是需要动态申请(runtime自己的malloc),没有定义.<br>一个bmap会有8个字节的tophash用于定位到桶中对应的entry.每个entry表示一个k-v,这个tophash是key的hash的高位字节.<br>而定位桶用的是hash的低位字节.在go中每个类型都会有自己的hash方法.</p>
<p>为了防止对齐问题,所以先排8个key,再排8个value.举个例子如果是map[int8]int64,那么k-v排在一起的话,就会空7个字节,非常浪费.<br>但是先排8个int8的话就不会出现对齐的问题.最后一个结构是桶指针,指向串联的桶.</p>
<p>而整个hmap是一个bmap的数组,主要是管理信息.</p>
<p>内存分布如图.</p>
<p><img data-src="map.png" alt="hmap"></p>
<p>hmap的增长是依赖于负载系数的,在go里面负载系数(loadFactor)是6.5,这个值是一个通过测试得到的比较理想的一个值.<br>这个值的意思表示的是,每个桶平均装下的entry数量是6.5个,之前我们提到了每个桶的大小是8.也就是说bucket一般都不会装满.</p>
<p>如果要负载系数高,也就是桶尽量装满,就会导致hash碰撞率较高(可以hash到的空间不大),这样会产生过多的overflow的bucket.<br>如果要负载系数低,hash碰撞率比较低,这样会使得空间很大,导致真正利用率(存入的数据/全部bucket空间)相对变小.<br>所以综合情况负载系数6.5是一个比较理想的值,这也是go现在采用的值.</p>
<p>这个可以通过决定增长的关键代码发现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ; hint &gt; bucketCnt &amp;&amp; float32(hint) &gt; loadFactor*float32(uintptr(1)&lt;&lt;B); B++ &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2^B是桶的数量,hint是申请的map的大小,bucketCnt就是8,因为预先会分配一个桶,如果一个桶都不会超过的话就不增加了.<br>关键是hint要保证大于负载系数*桶的数量,换句话说要保证平均每个桶装6.5个k-v能容得下hint这么多对k-v.<br>上面说得是静态分配,动态增长的时候oldbuckets是buckets的一半,也就是翻倍增长.</p>
<p>hmap在增长的时候会把bueckets变成oldbuckets然后再申请新的buckets.buckets中的k-v是不会移动到别的桶当中去的.<br>这样保证了遍历时候的一致性.hashmap按照range遍历的时候是按bucket数组的一个bucket开始然后bucket的串联bucket再回到<br>bucket数组的下个元素依次遍历.</p>
<p>删除非常简单,仅仅是把对应的key和value置为空.</p>
<p>现在把map的实现说清楚以后我们可以算一笔账.假设我们的map定义为<code>map[string]struct&#123;&#125;&#123;&#125;</code>,<br>在64bit的操作系统下面一个桶的大小是 8 + 8<em>16 + 8</em>0 + 8 = 144个字节(string 是常量只含一个指针和一个len值).<br>如果是<code>map[string]bool&#123;&#125;</code>,那么一个桶的大小是 8 + 8<em>16 + 8</em>1 = 152个字节.</p>
<p>换算下来节省的空间大概是5.2%,考虑到负载系数是6.5,换成百分比是81.25%这个程度,省8个字节的事情完全是多余的.</p>
<p>与其牺牲语义取巧节省这几个字节不如定义一个表示清晰的map来的更直接.<br>所以我的结论是<code>map[string]struct&#123;&#125;</code>并不可取.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2015/10/24/%E5%9C%A8Go%E9%87%8C%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E5%B1%8F%E8%94%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2015/10/24/%E5%9C%A8Go%E9%87%8C%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E5%B1%8F%E8%94%BD/" class="post-title-link" itemprop="url">在Go里对方法进行屏蔽</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-10-24 01:46:15" itemprop="dateCreated datePublished" datetime="2015-10-24T01:46:15+08:00">2015-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2015/10/24/%E5%9C%A8Go%E9%87%8C%E8%BF%9B%E8%A1%8C%E6%96%B9%E6%B3%95%E5%B1%8F%E8%94%BD/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2015/10/24/在Go里进行方法屏蔽/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天hack标准库里的<a target="_blank" rel="noopener" href="https://golang.org/src/debug/elf/file.go?s=1157:1466#L53">debug/elf</a>,里面有一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// A Section represents a single section in an ELF file.</span><br><span class="line">type Section struct &#123;</span><br><span class="line">        SectionHeader</span><br><span class="line"></span><br><span class="line">        // Embed ReaderAt for ReadAt method.</span><br><span class="line">        // Do not embed SectionReader directly</span><br><span class="line">        // to avoid having Read and Seek.</span><br><span class="line">        // If a client wants Read and Seek it must use</span><br><span class="line">        // Open() to avoid fighting over the seek offset</span><br><span class="line">        // with other clients.</span><br><span class="line">        io.ReaderAt</span><br><span class="line">        sr *io.SectionReader</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个结构很特别的一点是为了能够只使用<code>SectionReader</code>的ReadAt方法而不使用其他方法防止Seek出现竞争问题把一个interface <code>io.ReaderAt</code>包含了进来.<br><code>io.ReaderAt</code>是包含<code>ReadAt</code>方法的interface，以此目的来达到屏蔽其他方法的目的.如果真的要使用Read+Seek需要另外再调用Open函数.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Open returns a new ReadSeeker reading the ELF section.</span><br><span class="line">func (s *Section) Open() io.ReadSeeker &#123; return io.NewSectionReader(s.sr, 0, 1&lt;&lt;63-1) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里可以看到就是new了一个<code>SectionReader</code>出来用，这样就防止了竞争的问题.</p>
<p>实现的基础就是私有结构的方法是不暴露的,而共有借口的方法是可以暴露的,这样怎么做到呢?<br>我把代码做了一个抽象,写了一个demo如下.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type S struct &#123;</span><br><span class="line">	MethodsMask</span><br><span class="line">	i Implementer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewS() *S &#123;</span><br><span class="line">	s := new(S)</span><br><span class="line">	s.MethodsMask = s.i</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MethodsMask interface &#123;</span><br><span class="line">	F1()</span><br><span class="line">&#125;</span><br><span class="line">type Implementer struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (i Implementer) F1() &#123;</span><br><span class="line">	fmt.Println(&quot;F1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (i Implementer) F2() &#123;</span><br><span class="line">	fmt.Println(&quot;F2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s := NewS()</span><br><span class="line">	s.F1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个程序运行的结果就是<code>F1</code>,注意最关键的部分就在于函数<code>NewS</code>.<br>把实现者赋值给了接口,因为接口是公开的,所以对应的方法就变成共有的了.<br>而除此之外的方法还是不能被调用.这样就把一个实现者裁剪了.<br>当然了,这样的裁剪主要还是为了Seek的竞争.</p>
<p>我觉得适用的场景就是两个借口的并集构成了一个结构体的方法,但是这两个借口泾渭分明的时候就可以这样做.<br>就像标准库里面分成了<code>io.ReaderAt</code>和<code>io.ReadSeeker</code>一样.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2015/10/18/%E7%A6%BB%E5%BC%80%E9%98%BF%E9%87%8C%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8F%8D%E6%80%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2015/10/18/%E7%A6%BB%E5%BC%80%E9%98%BF%E9%87%8C%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8F%8D%E6%80%9D/" class="post-title-link" itemprop="url">离开阿里之后的反思</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-10-18 02:32:32" itemprop="dateCreated datePublished" datetime="2015-10-18T02:32:32+08:00">2015-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">实习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">工作</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/%E5%B7%A5%E4%BD%9C/%E9%98%BF%E9%87%8C/" itemprop="url" rel="index"><span itemprop="name">阿里</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AE%9E%E4%B9%A0/%E5%B7%A5%E4%BD%9C/%E9%98%BF%E9%87%8C/%E7%94%9F%E6%B4%BB/" itemprop="url" rel="index"><span itemprop="name">生活</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2015/10/18/%E7%A6%BB%E5%BC%80%E9%98%BF%E9%87%8C%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8F%8D%E6%80%9D/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2015/10/18/离开阿里之后的反思/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>  很意外地在九月底结束了在阿里的实习,五个月的时间的确收获了很多.其中被实习离职然后惨淡度过十月份先按下不表.主要想总结一下自己第一次工作之后<br>对于整个过程的思考.</p>
<p>  当初兴冲冲的来到内核组,的确是因为觉得搞内核很厉害,感觉很有前途,所以充满期待地就来了.</p>
<p>  先对工作做一个总结吧.第一个任务就是在ksplice [1] 上面搭建一个热升级补丁的工具,当然通过这个主要是使用了一些RPC的调用,在多个主机上面制作热升级的补丁,完成了一个简单的小型分布式系统,当然很简单就是,完全是一个单点的架构.这当中看了一个MIT公开课的讲义,算是一个初体验吧,也算是揭开了分布式系统的面纱,不再感到那么神秘.之后开始接触Bcache [2] ,这个做在内核态中的块设备缓存,当然这个部分对于内核初学者来说的确很难看懂,其中C语言的知识也好,内核的知识也好都不得不恶补了很多,基本上市面上那些带缩写的内核的书籍我都看了个遍,然而深入度还是欠缺.这段时间基本没干什么活,主要是学习,也过得比较轻松.最后是参与到libvirt[3]/QEMU[4] 这一套东西里面,主要是做了一下IO路径的切换,从QEMU-&gt;分布式网络存储转化为了QEMU-&gt;vhost-blk-&gt;Bcache-&gt;分布式网络存储的一个热迁移方案的解决,这里面主要是做了一些C的用户态的工具,熟悉了一下C语言,也开始了解了虚拟化的一些内容,当我正在准备从最基础的 vring [5] 部分从里往外看的时候我离开了阿里.</p>
<p>  公司内部的一些事情不是我想说的重点.然而失业的这段时间也是疲于奔命,一个是重新找实习还有一个就是做点兼职填补一下经济空白.之前工作的时候也是上完班就回来看看书补补内核的知识,或者看看B站虚度光阴.好像没有碰到一个契机来反思自己.</p>
<p>  总结的说,实习的这段经历让我感到失落,工作本身磨灭了我对编程的热情,我不太能总结,但包括了一些因素.首先是工作本身很乏味,不管是作热升级补丁也好,参与热迁移的方案也好,都是在做工具,但是在我眼里,做工具只是一个时间问题,我希望这个过程有一定程度是个未知数,是一片可以探索和发现的领域,然后工作却让我感觉按部就班做完就好了的颓废感.这一点让我感觉工作本身成为了一件机械性的重复性的劳动.</p>
<p>  其次是不管是libvirt也好QEMU也罢或者是Bcache这些东西,都是fork出来的,很多东西成为了组内的问题,不再变得open了,也就是说很多问题的确只能问组里人可能才能知道,因为组里的分支和上游还有蛮多区别的.我自己还是一个蛮有自信解决问题的人,但是这样导致一个很糟糕的情况是,当我们做的东西不open的时候,我们讨论问题的范围也会缩小,也就是说我问问题的话只能问组里的人,因为很多改动都是为了适应业务的需求,而且内部的代码拿出去问也的确不可能.而且组里的人都有工作都很忙,可能一些比较直接的问题比较好回答,具体的问题还是要靠我自己探索,这样我就感觉自己陷入了一个死循环.让我感觉自己的活动范围瞬间小了很多.当然这也跟我涉及东西的确有点复杂有关.</p>
<p>  还有就是一些零碎的东西了,我记得有一次和师兄讨论问题,主要是在跟我讲分布式存储上加缓存的业务的时候,后面有个人说”讨论这么热烈,不就是个实习生么”,当时我听在耳里,嘴上没有说什么,心里却五味杂陈.当时我想,换句话说在大部分人眼里我只是个实习生罢了.写到这里也是感觉自己不够争气呀.</p>
<p>  这是我实习的一些感受.我对比了一下我在学校的状态,感觉有些不同.</p>
<p>  首先是我已经修完所有的课程了,有大把空余的时间钻研自己感兴趣的东西,这也是我为什么单独写了一个OJ,从头到尾自己维护的原因,而且我把写在我的简历最前面是因为这个过程是我觉得最有意思的一件事情,从未知到已知,不断地请教别人,不断地尝试和寻找解决方案,最开始做沙箱的那段时间我是快乐的,因为我编程的同时感觉收获很大,而且这个东西从头到尾都是我自己写的,所以我写起来也很舒服,不像上班的时候一样光看代码就要看半天.直到后来把上层的WEB的内容写了个大概我的热情就开始渐渐消减,然后我又开始寻找新的可以钻研的东西,做沙箱的过程中让我真正体会到真正了解操作系统多么重要,不是调用那些系统调用这么简单,我记得有一次发邮件和别人讨论,因为当时那个人是也做了一个类似的东西,但是没有那么完全,我借鉴了他的代码,后来发邮件和他聊,他也在做类似的东西,但是是闭源的不方便拿给我看.但是他跟我聊了一些他的手段提到了 docker [6] 也提到准备利用 namespace[7]/cgroup[8] 做一个类似 docker 的沙箱的想法,当时我就觉得”卧槽,确实牛逼,这些我都不懂,我还有很长的路要走呀”.</p>
<p>  还有就是之前提到的,我可以自由地在segmenfault或者stackoverflow这些网站上面问问题,因为代码都在那,有问题就可以直接问就是了.我感觉大学学到东西最多的地方的确就是网络.这是说我自己写着玩的东西,如果一个项目和 upstream 越走越远的话,很产生很多的问题,而这些问题只会变得越来越私有,不再适合公开讨论了.</p>
<p>  另外就是自由度上,在学校随便睡到几点,起来之后开会儿书,更新几段代码再打打球一天就过去了轻松无比.然而在学校我也感受到了一个瓶颈.那就是学而不精.<br>很多东西想深入却没有门道,就举 Bcache 这个例子吧,不在工业条件下根本没办法研究这些内容,好歹有两块硬盘吧,一块得是快点的SSD才有效果吧,又或者是简单的搭个集群,这件事一个笔记本很难体验到,开个虚拟机都卡的飞起.还有就是没有一个工业环境,很多时候不知道一个更大数量级的业务到底是什么情况,还是只能用一台服务器起个进程跑服务的状态.这都是制约,所以这也促使着我想去公司看看.因为我本身就打算本科毕业就工作,所以偏纯科研的内容我的确没有什么准备.特别是大数据现在这么火的时代,我反倒不太喜欢去搞数据挖掘什么的,我更对底层支撑的分布式服务,如何让整个分布式的服务器更好更快地支撑上面的运算需求更感兴趣.</p>
<p>  除此之外,在学校经常在社区里面说话什么的, github也经常更新(当然进了公司以后才发现github很绿并没什么卵用).但是毕竟做程序员就是搞技术活的,口碑也很重要.光说不练假把式,代码亮出来几斤几两就知道了.当然这里面还有一层自我满足的东西在里面,自己写的东西有人观赏,甚至有人学习,更加的是有人用,都是很有成就感的一件事情.而且成就感这东西的确占了我对编程兴趣的一大半,这个东西在公司就感觉不到.那个时候就是一顿恶补,但是内核部分的代码还是不能很好的掌握,自己也懒得更新博客,因为一个模块都没有仔仔细细地搞明白,的确没什么好写的,写学习总结又太懒.更新github的代码更是别提了,基本没闲情了.</p>
<p>  最后做一下总结,学校的自由让我保持着对编程的热情,但是有限的条件和机会让我感觉不到快速进步的空间.然而公司虽然给了很大的环境却让我陷入了一个枯燥和禁闭的状态.</p>
<p>  在这里我对工作又有了一个新展望: 开放,探索,自由.</p>
<p>索引:</p>
<ul>
<li>  [1] 内核热升级: <a target="_blank" rel="noopener" href="https://www.ksplice.com/doc/ksplice.pdf">https://www.ksplice.com/doc/ksplice.pdf</a>, <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/aix/library/au-spunix_ksplice/">http://www.ibm.com/developerworks/cn/aix/library/au-spunix_ksplice/</a></li>
<li>  [2] 块设备缓存: <a target="_blank" rel="noopener" href="http://bcache.evilpiepirate.org/">http://bcache.evilpiepirate.org/</a>, <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/bcache.txt">https://www.kernel.org/doc/Documentation/bcache.txt</a></li>
<li>  [3] 虚拟机管理工具: 基本支持所有虚拟机 <a target="_blank" rel="noopener" href="http://libvirt.org/">http://libvirt.org/</a></li>
<li>  [4] QEMU: 非常主流的虚拟机方案 <a target="_blank" rel="noopener" href="http://wiki.qemu.org/Main_Page">http://wiki.qemu.org/Main_Page</a></li>
<li>  [5] vring: Linux虚拟总线virtio的数据存储结构 <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/linux/1402_caobb_virtio/">http://www.ibm.com/developerworks/cn/linux/1402_caobb_virtio/</a></li>
<li>  [6] docker: 现在非常流行的容器 <a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a></li>
<li>  [7] namespace: 内核级别的隔离方案 <a target="_blank" rel="noopener" href="http://www.haifux.org/lectures/299/netLec7.pdf">http://www.haifux.org/lectures/299/netLec7.pdf</a></li>
<li>  [8] cgroup: control group, 内核中对进程进行分组控制调度 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt">https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2015/10/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E8%AF%81%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2015/10/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E8%AF%81%E6%98%8E/" class="post-title-link" itemprop="url">最大子数组证明</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-10-16 11:51:41" itemprop="dateCreated datePublished" datetime="2015-10-16T11:51:41+08:00">2015-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2015/10/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E8%AF%81%E6%98%8E/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2015/10/16/最大子数组证明/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最大子数组之和问题是一道经典的面试题.<br>这里对这个问题的迭代解法做一个证明.</p>
<p>先给出C的伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int max_sub_array(int* arr, int len</span><br><span class="line">&#123;</span><br><span class="line">	int temp = 0, max = arr[0];</span><br><span class="line">	int i;</span><br><span class="line">	for(i = 0; i &lt; len; i++) &#123;</span><br><span class="line">		temp += a[i];</span><br><span class="line">		if(temp &lt; 0) &#123;</span><br><span class="line">			temp = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		if(temp &gt; max) &#123;</span><br><span class="line">			max = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return int</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>算法的思路是这样的:</p>
<p>所以用\(temp\)存储\(A[p..r]\),只要\(A[p..r]\)求和是负数的话,那么下一个\(A[r+1]\)开始,\(temp\)重新清零开始求和,只要\(temp\)比和大,就更新这个和.</p>
<p>这个算法的思路证明如下:</p>
<p>对于\(A[p..r]\),如果\(A[p..r]\)求和为负数的话,那么数组\(A[p..r+1]\)的最大子数组肯定不会是\(A[p..r+1]\)<br>因为\(A[p..r] + A[r+1] &lt; A[r+1]\)的.</p>
<p>对数组的所有元素进行一个划分,对于\(A[i]\),如果能够使得 \(temp&gt;0 and temp+A[i]&lt;0\),那么这个元素就是一个划分的边界.<br>这样就会形成很多个区间.</p>
<p>接下来要证明</p>
<ol>
<li> 最大子数组一定在划分块内</li>
<li> 一定存在首元素是划分块的首元素的最大子数组</li>
</ol>
<p>对于第一个点,假设有一个元素\(A[i]\)在划分区间\(A[p..r]\)内,那么\(A[p..i-1] &gt; 0 and A[i..r] &lt; 0\)一定成立,这个可以用反证法.</p>
<p>如果一个最大子数组横跨了这些区域假设这个最大子数组为\(A[i..j]\),并且\(A[r]\)最大子数组中最后一个处于分界的元素.<br>那么\(A[i..r] &lt; 0\)一定成立,所以最大子数组不可能有这段部分,因此最大子数组只会处于划分内.</p>
<p>对于第二点,假设\(A[i..j]\)处于划分\(A[p..q]\)当中,那么\(A[p..i-1]+A[i..j] &gt;= a[i..j]\)一定成立,所以最大子数组<br>的开始元素也是划分的开始元素.</p>
<p>综合起来就能证明这个算法的正确性.</p>
<p>实际上抽象地理解就是把数组划分成了恰好多加一个元素和就变负数的N个划分,而最大子数组不可能超过这个划分,<br>因此在计算划分当中的最大值就能得到最大子数组.产生一个新的划分的时候如果碰到负数肯定是独自成立了一个划分,如果碰到正数<br>就会作为新的划分的开始,所以这个划分的第一个元素会成为最大子数组的第一个元素,然后遍历每次包含一个元素以后的和就能确定最大值,最终获得最大子数组.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2015/07/04/%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E9%9D%99%E6%80%81IP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2015/07/04/%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E9%9D%99%E6%80%81IP/" class="post-title-link" itemprop="url">一根网线直连电脑配置树莓派网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-07-04 19:47:08" itemprop="dateCreated datePublished" datetime="2015-07-04T19:47:08+08:00">2015-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/" itemprop="url" rel="index"><span itemprop="name">树莓派</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2015/07/04/%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E9%9D%99%E6%80%81IP/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2015/07/04/配置树莓派静态IP/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="普通配置"><a href="#普通配置" class="headerlink" title="普通配置"></a>普通配置</h1><p>安装 <code>arp-scan</code>,可以通过ARP扫描获得IP到MAC的映射表.</p>
<p>执行 <code>arp-scan --interface wlan0 --localnet</code>(需要root权限),interface对应的是接入的网卡,这里我连接的是WIFI,所以选择wlan0.<br>结果是一堆表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Interface: wlan0, datalink type: EN10MB (Ethernet)</span><br><span class="line">Starting arp-scan 1.8.1 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)</span><br><span class="line">192.168.0.1	50:bd:5f:5f:02:be	(Unknown)</span><br><span class="line">192.168.0.100	8c:21:0a:7f:1a:bf	(Unknown)</span><br><span class="line">192.168.0.102	74:e5:43:db:f4:81	(Unknown)</span><br><span class="line">192.168.0.107	74:51:ba:c5:6f:4f	(Unknown)</span><br><span class="line">192.168.0.103	8c:be:be:9f:c7:ec	(Unknown) 192.168.0.114	b8:27:eb:63:d8:74	(Unknown)</span><br><span class="line">192.168.0.108	f8:a4:5f:ef:a4:b2	(Unknown)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在里面没有看到名字，但是树莓派的MAC都是<em>b8:27:eb</em>开头的.<br>所以可以执行<code>arp-scan --interface wlan0 --localnet | grep b8:27:eb</code>就可以看到树莓派对应的IP.</p>
<p>ssh在树莓派上是默认开启了的,这个时候可以通过<code>ssh pi@ip</code>ssh到树莓派上,密码是默认的__raspberry__.</p>
<p>这是在没有配置静态IP的情况下,如果不想每次都通过动态IP登陆的话，可以设置树莓派的静态IP。</p>
<p>通过编辑 <code>/etc/network/interfaces</code> 可以看到这样一行<code>iface eth0 inet dhcp</code>,这表示以太网的ip是动态分配的，<br>现在把这行换成<code>iface eth0 inet static</code>然后再进行我们的IP配置.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...省略</span><br><span class="line">iface eth0 inet static</span><br><span class="line">#my static IP</span><br><span class="line">address 192.168.0.118 // 自己设置的静态IP</span><br><span class="line">#my gateway IP</span><br><span class="line">gateway 192.168.0.1   // 网关 netstat -nr 可以通过路由表查看网关.</span><br><span class="line">netmask 255.255.255.0 // 子网掩码 可以通过ifconfig 查看子网掩码,一般都是255.255.255.0</span><br><span class="line">#my network address &quot;family&quot;</span><br><span class="line">network 192.168.0.0     // 表示网段. netstat -nr 也可以看到.</span><br><span class="line">broadcast 192.168.0.255 // 表示广播网络. ifconfig可以查看,最后一项一定是255.</span><br><span class="line"></span><br><span class="line">...省略</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如我不想记住这个IP,可以编辑<code>/etc/hosts</code>文件,来给IP绑定一个名字.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.118 pi</span><br></pre></td></tr></table></figure>

<p>这样以后就可以通过 <code>ssh pi@pi</code> 来登陆树莓派了.</p>
<h1 id="高潮来了"><a href="#高潮来了" class="headerlink" title="高潮来了:"></a>高潮来了:</h1><p>之前配置树莓派的时候把静态IP设置了,然后来北京实习之后没有带显示屏,所以只能通过一根网线来操作,网线还是我从公司上拔下来的.<br>其实奇淫巧计还是蛮多了,一种是直接把SD卡拔下来在电脑上改文件,但是之前我以为是操作系统崩掉了,所以傻逼一直想连接上去,最后发现这个地址: (<a target="_blank" rel="noopener" href="http://embeddedday.com/projects/raspberry-pi/basics/direct-connection-to-pc">http://embeddedday.com/projects/raspberry-pi/basics/direct-connection-to-pc</a></p>
<p>真是たすかた呀,boot/下面的cmdline.txt最后添加一段ip设置,可以设置一个静态IP(当时只是想连接上去,其实直接改网络配置文件就好了)然后把网线和树莓派直连ssh上去,最后连接上去了,然后果断把我的静态IP配置回去,我又买了一个USB无线网卡,记录一下无线配置.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allow-hotplug wlan0</span><br><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet static</span><br><span class="line">address 192.168.99.226</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.99.1</span><br><span class="line">wpa-ssid &quot;id&quot;</span><br><span class="line">wpa-psk &quot;password&quot;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2015/07/04/%E5%B1%85%E7%84%B6%E8%A2%ABheap%E9%9A%BE%E5%80%92%E4%BA%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2015/07/04/%E5%B1%85%E7%84%B6%E8%A2%ABheap%E9%9A%BE%E5%80%92%E4%BA%86/" class="post-title-link" itemprop="url">居然被heap难倒了</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-07-04 19:46:57" itemprop="dateCreated datePublished" datetime="2015-07-04T19:46:57+08:00">2015-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/data-structure/" itemprop="url" rel="index"><span itemprop="name">data structure</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/data-structure/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2015/07/04/%E5%B1%85%E7%84%B6%E8%A2%ABheap%E9%9A%BE%E5%80%92%E4%BA%86/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2015/07/04/居然被heap难倒了/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前一直小看了heap觉得这个数据结构比较简单,等串讲的时候发现其实并不是的,居然为了heap的插入删除争论了很久.<br>这里特地记录一下,heap的性质是递归的父结点比子节点大，说白了就是一个优先队列.<br>push,pop都只要分别做一次向上调整和向下调整.</p>
<p>但之前我的知识体系好像调整要有一次down再一次up.<br>这是在真正调整的时候用的比如替换任意一个元素或者删除任意一个元素.<br>替换很好理解就是引入一个元素可能很大也可能很小,要么向上要么向下.<br>而我卡住的地方是删除,老是觉得把最后一个结点换上来应该是不用向上调整只要向下的，<br>因为这个定义是递归的,但是不是的，虽然在删除处i下面的子树可以，但是如果最后一个结点不在i的子树下面,比如另外一个i的兄弟子树下面，整棵树都比i小的话（这里指最小堆），那么其实情况和替换是类似的，所以任意删除和替换才是会把down up两个函数都写入,但都是只执行一次.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2015/04/20/first-post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2015/04/20/first-post/" class="post-title-link" itemprop="url">hexo 搭建博客</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2015-04-20 21:54:39" itemprop="dateCreated datePublished" datetime="2015-04-20T21:54:39+08:00">2015-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2015/04/20/first-post/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2015/04/20/first-post/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前用jekyll在Github上面搭建了一个博客，但是发现语法高亮什么的，并不完全是markdown格式的，而且迁移起来也奇奇怪怪的，于是决定换成hexo来搭建。另外一个原因是想在博客里面写一些数学公式等等，但是却发现没有什么主题是支持的，然后就想自己改一个，结果发现自己改的实在太丑，不想用,当然，作为工程师型的人，丑不丑倒是无所谓，主要是配来配置去把耐心给消耗了，最后决定用别人写好的主题，选择了<a target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">next</a>漂亮而且支持数学公式等等（当然数学公式的支持就是添加一个js库<a target="_blank" rel="noopener" href="https://www.mathjax.org/">MathJax</a>就可以搞定了，也不是什么难事）。</p>
<p>hexo的部署可以参考官网和一些网上的资料，已经有很多了。这里主要记录一下hexo的一些主要使用方法。</p>
<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><ol>
<li><p>草稿</p>
<p> 通过<code>hexo new [layout] &lt;title&gt;</code>这样的命令就可以生成对应的文件，比如草稿，<br> hexo draft “draft”（如果题目有空格，要带双引号，layout默认是post,这<br> 些layout都存在_scaffolds_下面。可以通过hexo设置是否在网站上显示草稿，我<br> 设置的是显示（设置*_config<em>里面的</em>render_drafts<em>为</em>true*即可)。</p>
</li>
<li><p>发布</p>
<p> 发布可以选择草稿发布，也可以选择直接发布新文章,对应的命令分别是<code>hexo publish [layout] &lt;title&gt;</code>和<code>hexo new [post] &lt;title&gt;</code>，<br> 这个时候生成的静态文件里面就可以看到新的文章了。</p>
</li>
<li><p>前缀</p>
<p> tags和categories里面的内容,按照[content1,content2,…]的格式就可以分开显示在标签栏里面。</p>
</li>
<li><p>特殊插入</p>
<p> <a target="_blank" rel="noopener" href="https://hexo.io/docs/tag-plugins.html">tag-plugins</a>中可以找到一些特殊需要的插入，比如插入gist,twitter的引用或者youtube视频等等。</p>
</li>
<li><p>i18n</p>
<p> 支持国际化，在*_config.yml*下面设成</p>
<pre><code> language:
 - zh-CN
 - en
</code></pre>
<p> 设置*_config.yml<em>里面的</em>i18n_dir<em>可以根据路径前缀判断对应的语言。<br> 在发布的时候带上</em>–lang*选项设置语言，比如<code>hexo new &quot;Hello World&quot; --lang tw</code>就可以针对不同的语言产生对应目录。</p>
</li>
<li><p>数学公式</p>
<p> 数学公式主要依赖于<a target="_blank" rel="noopener" href="https://www.mathjax.org/">MathJax</a>,在编辑文本的时候<code>$$...$$</code>和<code>\[...\]</code>用来表示数学公式，<code>\\(...\\)</code>用来表示行内数学公式，比如<code>\\(a^2+b^2=c^2\\)</code>的效果是\(a^2+b^2=c^2\)。而<code>$$ a^2+b^2=c^2 $$</code>,就会另起一行。</p>
<p> $$ a^2+b^2=c^2 $$</p>
<p> 具体的使用可以在<a target="_blank" rel="noopener" href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">这里</a>查看<br> 注意markdown的一些符号，需要在公式里面转义，省的被markdown语法误解。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/" class="post-title-link" itemprop="url">Go语言并行测试（论文翻译）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2014-12-02 13:15:00" itemprop="dateCreated datePublished" datetime="2014-12-02T13:15:00+08:00">2014-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>  Peiyi Tang</li>
<li>  计算机科学部</li>
<li>  阿肯色州大学小石城分校</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.ualr.edu/pxtang/papers/acc10.pdf">原论文</a></p>
<p>##概要</p>
<p>  Go语言是一门新的并发编程语言.它的目标之一就是应对多核并行编程的挑战.在这篇论文里面,我们展示了两个多核并行的Go程序和他们在八核微处理器上的性能和并行Go代码的效率.</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>  直到2000年,计算机架构都可以把并发运算封装在硬件中,每18个月微处理器的性能就可以翻倍,而不需要丝毫地改动串行编程模型(sequential programming model).但有三个问题日益凸显,处理器和内存的速度在跨越式增长,指令级别的并发存在限制,高性能的计算能力也被提高,综合这三个原因,在2000年所有的微处理器厂商都转向了多核微处理器的开发.</p>
<p>  多核处理器展现了非常好的性能,为了能够充分发挥这样的性能,就需要通过并行编程来解决.运行串行的代码只能够发挥单个处理器的性能,而浪费了其他处理器的资源.</p>
<p>  最早和多核并行编程有关的书是_”multi-thread programming”<em>[1],然而在多线程模型上实现并行和并发程序是非常困难的.就像_Edward A.Lee</em>[2]指出的,多线程编程的问题是,这样的方式是一种落后的方式,使得程序在一开始就变得不确定,然后通过使用信号量,锁机制还有监视器来减少不确定性.</p>
<p>  最近Google推出了一门新语言Go(这里的最近是指2009年).Go是并发的并且具有垃圾回收的系统编程语言[3],目标之一就是迎合多核编程的挑战使得并发编程更加简便.Go不使用多线程模型,而是通过Go的routine（基于CSP的communication通道).任何Go语言中的函数,能够作为串行编程模型中的普通routine或者用关键字<code>go</code>在前端执行一个Goroutine,在运行时里面一个被调用的Goroutine是和调用者routine并发执行的，而不管他们是否运行在同一个CPU上.从编程这的角度来说,Go routine是并发的归宿,而且对比于之前的锁方式等等，有更加良好的确定性.Go在CSP的communication通道的基础上,扩展了无缓冲区大小的通道来实现异步发送(或写)操作.通道是Go语言的预定义类型(first-class),能够从一个routine传递到另一个routine.Goroutine和CSP通道的结合提供了一个强大的机制来来保证达到一个期望的确定性的并发计算。</p>
<p>  在这篇论文中,我们将通过两个例子展示Go语言在并行编程方面体现的多核利用率.第一个例子在第二节中讨论,是没有同步和通道的并行积分问题.第二段程序在第三节中讨论,是一个并发动态规划的问题,需要在多个并发任务中实现同步,第四节总结这篇论文.</p>
<h2 id="2-并行计算积分"><a href="#2-并行计算积分" class="headerlink" title="2 并行计算积分"></a>2 并行计算积分</h2><p>  计算积分是一个用来展示并发编程和它本身加速度(表示的是多处理器执行时间和单处理器执行时间的比值)的常见例子,例如一个函数\(f(x)\),在\([a,b]\)上的积分.</p>
<p>$$ \int_a^b f(x),dx $$</p>
<p>  能够通过\(n\)个在曲线下方的长方形来求和估计计算\(f(x)\),</p>
<p>$$ \sum\limits^{n-1}_{i=0} hf(a+h(i+\frac{1}{2})) $$</p>
<p>  因为\(h = \frac{a-b}{n}\)是小长方体的宽度.因为只有有限个\(np\),并且\(np &lt;&lt; n\),所以只要创建\( np\)个计算组,每个计算组分配给一个处理器就可以得出结果.为了平衡处理器之间的计算,我们用阻塞公式(blocking formula)[5]来把n个矩形\(0,\cdots,n-1\)平均分配到\( np\)个计算组里.</p>
<p>$$ \lfloor \frac{i*n}{np} \rfloor,\lfloor \frac{i*n}{np} \rfloor + 1,\cdots,\lfloor \frac{(i+1)*n}{np} \rfloor - 1  $$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func f(a float64) float64 &#123;</span><br><span class="line">	return 4.0/(1.0 + a * a)</span><br><span class="line">&#125;</span><br><span class="line">func chunk(start, end int64, c chan float64) &#123;</span><br><span class="line">	var sum float64 = 0.0</span><br><span class="line">	for i:= start; i &lt; end; i++ &#123;</span><br><span class="line">		x := h * (float64(i) + 0.5)</span><br><span class="line">		sum += f(x)</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- sum * h</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	runtime.GOMAXPROCS(np);</span><br><span class="line">	h = 1.0/float64(n)</span><br><span class="line">	..//start timing</span><br><span class="line">	c := make(chan float64, np)</span><br><span class="line">	for i:=0; i &lt; np; i++ &#123;</span><br><span class="line">		go chunk(int64(i)*n/int64(np),</span><br><span class="line">		(int64(i)+1)*n/int64(np), c)</span><br><span class="line">	&#125;</span><br><span class="line">	for i:=0; i &lt; np; i++ &#123;</span><br><span class="line">		pi += &lt;-c</span><br><span class="line">	&#125;</span><br><span class="line">	...//end timing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码1:计算Pi的代码.</p>
<p>  通过循环触发Goroutine来实现np个子算组的并行运算,代码1显示了被省略的Go代码来计算Pi的积分:</p>
<p>$$ \pi=\int_0^1 \frac{4}{1+x^2},dx $$</p>
<p>  计算一个计算组是通过 <code>chunk(start,end int,c chan float64)</code>这个函数实现的,这个函数计算从<em>start</em>到<em>end</em>之间的矩形面积.<code>Channel c</code>则是用来在结束的时候进行同步,并且把计算组的结果送到main routine.</p>
<img data-src="/zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/figure2.png" class="">
<p>图2:执行时间</p>
<p>  主routine 通过建立运行时来开始所有在\(np\)个处理器上的Go routine,通过调用<code>rutime.GOMAXPROCS(np)</code>就可以实现.<code>make</code>语句构造了一个有np大小缓存的通道,第一个循环是通过chunk开始所有的routine,并且把通道传递进去.这些routine和main routine并发执行.</p>
<img data-src="/zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/figure3.png" class="">
<p>图3:积分的加速度 </p>
<p><code>pi+= &lt;-c</code>会执行np次,累加以获得pi的结果,在第一个<code>chunck()</code>调用的时候,通道为空,从空的通道读取会阻塞main routine.第二个循环在接受了所有routine的</p>
<p>  结果之后终止,pi就会得到最终结果.</p>
<p>  我们在一个八核AMD Opteron(tm) 2.8GHz 1024KB cache的处理器上.我们把问题的n从\(10^4\)调整到\(10^10\)然后把处理器个数从1提升到8.图2 展示了,并行Go计算pi的效率.对于小的问题规模\( (n = 10^4,10^5) \),使用多核不能增加的执行时间,这是因为过多的调度和初始化routine导致的,大部分时间没有执行并行计算.当问题规模n变大的时候\((n = 10^8,10^9,10^10)\),使用多处理器能够显著的增加执行时间.</p>
<p>  为了能够体现并发执行的加速度(speedup),我们可以通过下面的式子计算速度:</p>
<p>$$ S_{np} = \frac{T_1}{T_{np}} $$</p>
<p>  在这里 \(T_1\)和\(T_{np}\) 是1个处理器和np个处理器.他们对应的结果在图3中.注意,当问题规模非常大的时候,增长几乎就是线性的了,特别是问题规模达到\(n=10^9\)的时候,几乎能达到7.79,这个时候处理器的个数是8个.</p>
<h2 id="3-并发的动态规划"><a href="#3-并发的动态规划" class="headerlink" title="3 并发的动态规划"></a>3 并发的动态规划</h2><p>  现在我们转向第二个多核并发的例子,这个例子是一个动态规划问题.动态规划旨在存在最优子结构的问题的解决,并且动态规划还要解决重叠问题[6],只计算一次子问题,然后把结果存在备忘录中,也就是一个用来查询结果的表结构.这种方式很多时候能把时间复杂度从指数级降低到多项式的级别.我们使用优化二分搜索树问题来展示动态规划的多核并行方式.</p>
<p>  给出n个key,\(k_1,\cdots,k_n\)和他们的概率分布\(p_1,\cdots,p_n\),优化二分树搜索问题是找到二分搜索树(BST)的key的最小平均时间.</p>
<p>  设\(BST_{i,j}\)为优化BST,存储了key,\(k_1,\cdots,k_n(j&gt;=i-1)\),并且\(MST_{i,j}\)代表最小搜索时间(mean search time,MST),\(BST_{i,i}\)是一个只有root \(k_i(1 &lt;= i &lt;= n)\) 的单一节点，它的最小搜索时间是\(MST_{i,i}\),也就是\(p_i\).另外\(BST_{i,i-1}\)是一颗空树\((1 &lt;= i &lt;= n)\),并且它的最小搜索时间是\(MST_{i,i-1}=0\)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">	cost [n+1][n+1]float</span><br><span class="line">	root [n+1][n+1]int</span><br><span class="line">	prob [n]float</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func mst(i,j int) &#123;</span><br><span class="line">	var bestCost float = 1e9 + 0.0</span><br><span class="line">	var bestRoot int = -1</span><br><span class="line">	switch &#123;</span><br><span class="line">		case i &gt;= j:</span><br><span class="line">			// 如果是空树,代价为0,没有根节点,注意i==j也是空的,j-1,j才是本结点</span><br><span class="line">			cost[i][j] = 0.0</span><br><span class="line">			root[i][j] = -1</span><br><span class="line">		case i+1==j:</span><br><span class="line">			// 如果是单结点,就是自己的概率</span><br><span class="line">			cost[i][j] = prob[i]</span><br><span class="line">			root[i][j] = i+1</span><br><span class="line">		case i+1 &lt; j:</span><br><span class="line">			// 如果是非单结点树,这里要注意的是,如果子树增加了一个root深度就会+1</span><br><span class="line">			// 所以每个子树的期望就会增加这个子树的所有结点的概率和,再加上一个根节本身的深度时1所以期望也就是概率的值</span><br><span class="line">			// 所以整个增加的期望就是构成的整个树的结点的概率和,这就是为什么要算psum.</span><br><span class="line">			psum := 0.0</span><br><span class="line">			for k := i; k &lt;= j-1; k++ &#123;</span><br><span class="line">				psum += prob[k]</span><br><span class="line">			&#125;</span><br><span class="line">			// 计算出子树期望和最小的情况,这里利用了最优子结构.</span><br><span class="line">			for r := i; r &lt;= j-1; r++ &#123;</span><br><span class="line">				rcost := cost[i][r] + cost[r+1][j]</span><br><span class="line">				if rcost &lt; bestCost &#123;</span><br><span class="line">					bestCost = rcost</span><br><span class="line">					bestRoot = r+1</span><br><span class="line">			&#125;</span><br><span class="line">			cost[i][j] = bestCost + psum</span><br><span class="line">			root[i][j] = bestRoot</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main()&#123;</span><br><span class="line">	...// initialize prob[]</span><br><span class="line">	for i:=n; i&gt;=0; i-- &#123;</span><br><span class="line">		for j:=i; j &lt;= n; j++ &#123;</span><br><span class="line">			mst(i,j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码4: 动态规划算法</p>
<p>  如果优化二叉搜索树\(k_1,\cdots,k_n \),把\( k_r ( 1 &lt;= r &lt;= n) \)作为根节点,那么左子树\(k_1,\cdots,k_{r-1}\)和右子树\(k_{r+1},\cdots,k_n\)必须也是最优化的(这个用反证法可以证明).因此,\(MST_{i,j}\)能够递归定义成</p>
<p>$$ MST_{i,h} = \min_{i&lt;=r&lt;==j} (MST_{i,r-1} + MST_{r+1,h}) + \sum_{k=i}^jp_k $$</p>
<p>  这个公式能够决定MST的最小子树的r对应的这棵树的根节点.</p>
<p>  存储MST的结构是矩阵(n+1)X(n+1)的上三角部分,这个矩阵对应的是最小搜索时间MST的cost[n+1][n+1].特别地 MSTi,j 存储在cost[i-1][j].相似地,\(k_i,\cdots,k_j\)优化二叉搜索树的根节点存储在root[i-1][j],root是另外一个root[n+1][n+1]矩阵.时间的概率的分布存储在数组prob[n]中,\(p_i\)对应prob[i-1].</p>
<img data-src="/zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/figure5.png" class="">

<p>图5:任务间的数据依赖.</p>
<p>  寻找最优二叉搜索树的串行动态规划算法[7]的代码在 代码4 中展示.总得来说,这个算法计算cost[i][j](0 &lt;= i &lt;= j &lt;= n)时是需要递归使用cost[i][i],cost[i][i+1],…,cost[i][j-1]和cost[i+1][j],cost[i+2][j],…,cost[j][j]的值的.cost[i][j]的计算依赖于cost[i][j-1],cost[i+1][j]的依赖.<br>图5展示了用来计算cost[i][j]的数据结构.这是因为串行算法里面的嵌套循环从按照从下到上以及从左到右来计算cost[i][j]的,当并行化这个算法的时候,我们必须借助这个数据依赖.</p>
<p>  原则上,我们可以构造(n+1)*(n+1)/2大小的矩阵,一个来记录cost,但是这个并行任务的粒度太小了,会使得调度和同步的代价过高,而挤占了并行计算的资源.为了能够控制并行计算的粒度,我们把任务空间切分成 vp(vp+1)/2 个块,并且把每个快分配给一个Goroutine作为一个运算单元.</p>
<p>  在每个任务块内,Goroutine以自顶向下或者由下而上的顺序计算二维数组cost,root的一部分.为了能够实现数据块间的数据依赖,要使用channels进行同步.</p>
<img data-src="/zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/figure6.png" class="">

<p>  图6展示了10个数据块,vp=4,数据规模n=11的一个用Gochannel同步的结果.每个点代表了数组cost的一个元素的计算称作point.任务块之间的箭头时Gochannel的同步.特别地,一个数据块左数据块和下数据块计算完毕才能够开始计算.每个任务块都有一个下标\((i,j)(0&lt;=i&lt;=j&lt;=vp-1)\).Channels能够通过发送给通道的任务块来识别.特别的,title(i,j)通过水平线上的channel \(h_{i,j}\)把信号传送给右边的title(i,j+1)(如果不是在最上面),或者通过水平的通道把信号发送到上面的title(i-1,j).在对角线上的title(i,j)(i==j)能够开始计算,因为他们没有依赖于任何其他的任务块的计算.最右上角的(vp-1,vp-1)时最后一个计算的.为了能够发送结束的信号,有另外一个finish通道用来告知main routine计算的结束.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">var h,v [vp][vp] chan int</span><br><span class="line">var finish chan int</span><br><span class="line">..//declare other variables and constants</span><br><span class="line">func creatChan() &#123;</span><br><span class="line">	for i:=0; i &lt; vp; i++ &#123;</span><br><span class="line">		for j:=i; j &lt; vp; j++ &#123;</span><br><span class="line">			if j &lt; vp-1 &#123;h[i][j] = make(chan int, 1)&#125;</span><br><span class="line">			if i &gt; 0</span><br><span class="line">			&#123;v[i][j] = make(chan int, 1)&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func mst(i,j int) &#123;</span><br><span class="line">	... // the same as in the sequetial code</span><br><span class="line">&#125;</span><br><span class="line">func chunk(i,j int) &#123;</span><br><span class="line">	var bb int</span><br><span class="line">	il := (i * (n+1))/vp</span><br><span class="line">	//block-low for i</span><br><span class="line">	ih := ((i+1) * (n+1))/vp - 1</span><br><span class="line">	//block-high for i</span><br><span class="line">	jl := (j * (n+1))/vp</span><br><span class="line">	//block-low for j</span><br><span class="line">	jh := ((j+1) * (n+1))/vp - 1</span><br><span class="line">	//block-high for j</span><br><span class="line">	if i &lt; j &#123;</span><br><span class="line">		// not a tile on the diagonal</span><br><span class="line">		&lt;-h[i][j-1] // receive from the left</span><br><span class="line">		&lt;-v[i+1][j] // receive from below</span><br><span class="line">	&#125;</span><br><span class="line">	for ii:=ih; ii &gt;= il; ii-- &#123;</span><br><span class="line">		if i==j &#123; bb = ii &#125; else &#123; bb = jl &#125;</span><br><span class="line">		for jj:=bb; jj &lt;= jh; jj++ &#123;</span><br><span class="line">			mst(ii,jj)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if j &lt; vp-1 &#123;// not a tile on the right border</span><br><span class="line">		h[i][j] &lt;- 1</span><br><span class="line">	&#125;</span><br><span class="line">	if i &gt; 0 &#123;</span><br><span class="line">		// not a tile on the top border</span><br><span class="line">		v[i][j] &lt;- 1</span><br><span class="line">	&#125;</span><br><span class="line">	if i==0 &amp;&amp; j==vp-1 &#123;//the last tile</span><br><span class="line">		finish &lt;- 1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	...//read flags</span><br><span class="line">	runtime.GOMAXPROCS(np)</span><br><span class="line">	... //start timing</span><br><span class="line">	creatChan()</span><br><span class="line">	finish = make(chan int, 1)</span><br><span class="line">	for d:=0; d &lt; vp; d++ &#123;//sub-diagonal of j=i+d</span><br><span class="line">		for i:=0; i+d&lt;vp; i++ &#123;</span><br><span class="line">			go chunk(i, i+d)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-finish</span><br><span class="line">	....//end timing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码7 Go语言并行动态规划</p>
<img data-src="/zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/figure8.png" class="">

<p>图8 规模2000的执行时间</p>
<p>  我们选择设定问题规模为2000来进行实验,来保证足够大的精确测量.我们需要在八核AMD Opteron(tm)微处理器运行图7中的并行代码,改变每个维度的block的数量,从1,2,4,8,…,1024和2001.当vp越大的时候,粒度越小.vp=1对应了粒度最大的情况,没有并行,只有一个数据块.这种情况只有一个Goroutine调用,一个channel finish.<br>执行时间几乎就像串行结果一样的,不管多少处理器被利用.vp=2001的时候对应粒度最小的最大任务块,每个点都有一个.<br>图8展示了不同的vp和不同处理器np的情况下并行执行时间.对于每种vp和np的组合,我们运行5次,用单用户模式,计算平均值并放入图8中.<br>注意np=1的时候执行时间.我们能够观察到执行时间会递减,当vp从1增加到32,这是因为vp的增加创造了更多的任务块并且增加了缓存的命中率.<br>当vp从32增加到2001的时候,执行时间却反而增加了,这是因为缓存命中率降低并且过多的创建和调度Goroutine的结果导致的.<br>我们运行另一个去除所有的channel和routine调用的串行但是分块的代码(这段代码没有展示),它的执行时间近似于图8 ¨seq-tile¨ 的曲线,这个时间真正的体现了没有goroutine的时候的缓存命中率的效果.因此¨seq-tile¨和¨np=1¨之间的距离就是Go调度和调用的代价.<br>对于vp=2001,右2,003,001 个Goroutine的调用,¨np=1¨和¨seq-title¨时62.318429-43.351857=18.966572秒.因此,创建和调度Goroutin的代价对于每个处理器来说平均时\( \frac{18.966572}{2003001} = 9.46*10^{-6}\)秒,也就时9.46us.<br>np&gt;1时的多核并行执行时间是小于np=1时的运行时间.但是np=1时,有goroutine的调用和调度的开销,这在串行执行的时候并不是完全需要的.我们用分块的串行时间¨seq-time¨作为基础来计算并行计算加速度.特别的,np&gt;=1的处理器</p>
<p>$$ S_{np}=\frac{T_{ts}}{T_{np}} $$</p>
<img data-src="/zh-CN/2014/12/02/Multi-Core-Parallel-Programming-in-Go/figure9.png" class="">

<p>  \(T_{ts}\)和\(T_{np}\)分别对应串行时间和使用np处理器的并行时间.图9 显示了不同任务块大小的并行运行时间和串行时间的比较.最好的加速度vp=128的时候.对于8个处理器的时候,加速度是7.70.当vp从128增加的时候,粒度减小而Goroutine调度和调用拖累了执行过程,降低了加速度.图9(a)当vp从128降低的时候,粒度增加而且没有足够的任务块,因此降低了并发度,也降低了加速度.图9(b)展示了降低了的加速度.</p>
<p>##4 总结</p>
<p>  我们展示了Go的两个问题的并行代码,并行积分和并行动态规划问题.这些代码展示了Go在编写多核并行代码的简易性.我们同样测量了代码的性能.最高的加速度分别时7.79和7.70.初始化和调度Goroutine的代价在使用一个处理器的时候只有9.46us.因为并行计算倾向于计算大块的任务,Goroutine的量级如此之小,基本上可以忽略.</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li> [1] Shameen Akhter and Jason Roberts. Mutli-Core Programming: Increasing Performance through Software Multi-threading. Intel Press, 2006.</li>
<li> [2] Edward A. Lee. The problem with threads. IEEE Computer, 39(5):33–42, May 2006.</li>
<li> [3] Go Team.The Go programming language specification.Technical Report <a target="_blank" rel="noopener" href="http://golang.org/doc/doc/go">http://golang.org/doc/doc/go</a> spec.html,Google Inc., 2009.</li>
<li> [4] C.A.R. Hoare. Communication Sequential Processes.Prentice Hall, 1985.</li>
<li> [5] Michael J. Quinn. Parallel Programming in C with MPI and OpenMP. McGraw-Hill, 2004.</li>
<li> [6] Thomas H. Corman, Charles E. Leiserson, Ronald L.Rivest, and Clifford Stein. Introductions to Algorithms,2nd Edition. McGraw-Hill Book Company, 2001.</li>
<li> [7] Sara Baase and Allen Van Gelder. Computer Algorithms: Introduction to Design and Analysis (3rd Ed).Addison-Wesley, 2000.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2014 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ggaaooppeenngg</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"ggaaooppeenngg","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
