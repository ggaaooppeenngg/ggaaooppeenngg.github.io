<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_85tctgPWrqH2EPVuuD5IT6KE-tW8nH0hTISJDMnShg">
  <meta name="baidu-site-verification" content="bb16c5b1fd3302c18e0015bef11eea42">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ggaaooppeenngg.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="接着上篇文章阐述了VFS以后,这篇文章主要想讲述一下在内核当中如何创建一个文件系统.其实根据上一篇博客来说,我们的文件系统主要能够满足VFS的抽象,就可以在内核中构建一个自己的文件系统.一个文件系统满足的功能其实就是针对文件的增删改查,目录的管理,还有链接等等,这是从用户的角度来看,而文件系统本身也要有自己的状态信息,维护在超级块里,可以被挂载,然后向下要提交IO请求(一般是磁盘也可以是网络,甚至">
<meta property="og:type" content="article">
<meta property="og:title" content="aufs-如何自己编写一个文件系统">
<meta property="og:url" content="https://ggaaooppeenngg.github.io/zh-CN/2016/01/04/aufs-%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="ggaaooppeenngg">
<meta property="og:description" content="接着上篇文章阐述了VFS以后,这篇文章主要想讲述一下在内核当中如何创建一个文件系统.其实根据上一篇博客来说,我们的文件系统主要能够满足VFS的抽象,就可以在内核中构建一个自己的文件系统.一个文件系统满足的功能其实就是针对文件的增删改查,目录的管理,还有链接等等,这是从用户的角度来看,而文件系统本身也要有自己的状态信息,维护在超级块里,可以被挂载,然后向下要提交IO请求(一般是磁盘也可以是网络,甚至">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-01-03T18:06:15.000Z">
<meta property="article:modified_time" content="2025-03-28T10:39:05.270Z">
<meta property="article:author" content="ggaaooppeenngg">
<meta property="article:tag" content="内核">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ggaaooppeenngg.github.io/zh-CN/2016/01/04/aufs-%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ggaaooppeenngg.github.io/zh-CN/2016/01/04/aufs-%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","path":"zh-CN/2016/01/04/aufs-如何自己编写一个文件系统/","title":"aufs-如何自己编写一个文件系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>aufs-如何自己编写一个文件系统 | ggaaooppeenngg</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-62096626-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-62096626-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?bb16c5b1fd3302c18e0015bef11eea42"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">ggaaooppeenngg</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">为什么计算机科学是无限的但生命是有限的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">136</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">14</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">80</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ggaaooppeenngg</p>
  <div class="site-description" itemprop="description">为什么计算机科学是无限的但生命是有限的</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">136</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ggaaooppeenngg" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ggaaooppeenngg" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:peng.gao.dut@gmail.com" title="E-Mail → mailto:peng.gao.dut@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ggaaooppeenngg.github.io/zh-CN/2016/01/04/aufs-%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ggaaooppeenngg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ggaaooppeenngg">
      <meta itemprop="description" content="为什么计算机科学是无限的但生命是有限的">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="aufs-如何自己编写一个文件系统 | ggaaooppeenngg">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          aufs-如何自己编写一个文件系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-01-04 02:06:15" itemprop="dateCreated datePublished" datetime="2016-01-04T02:06:15+08:00">2016-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-28 18:39:05" itemprop="dateModified" datetime="2025-03-28T18:39:05+08:00">2025-03-28</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/zh-CN/2016/01/04/aufs-%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="zh-CN/2016/01/04/aufs-如何自己编写一个文件系统/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>接着<a href="http://ggaaooppeenngg.github.io/zh-CN/2015/12/22/VFS-%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84/">上篇文章</a>阐述了VFS以后,这篇文章主要想讲述一下在内核当中如何创建一个文件系统.其实根据上一篇博客来说,我们的文件系统主要能够满足VFS的抽象,就可以在内核中构建一个自己的文件系统.一个文件系统满足的功能其实就是针对文件的增删改查,目录的管理,还有链接等等,这是从用户的角度来看,而文件系统本身也要有自己的状态信息,维护在超级块里,可以被挂载,然后向下要提交IO请求(一般是磁盘也可以是网络,甚至是内存).这里的实现我们选择在内存当中实现一个文件系统.</p>
<p>代码参考了《Linux内核探秘》[1],以及内核代码ramfs的部分[2],基于内存构建一个文件系统.完整代码可以在<a target="_blank" rel="noopener" href="https://github.com/ggaaooppeenngg/kernel-practice/tree/master/aufs">这里</a>查看,代码是基于2.6.32的内核的,当中涉及了一些模块编程的内容可以参考”The Linux Kernel Module Programming Guide”[3]</p>
<p>为了实现一个文件系统,首先我们需要定义一个文件系统.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line"></span><br><span class="line">static struct file_system_type au_fs_type = &#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .name = &quot;aufs&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int __init aufs_init(void)</span><br><span class="line">&#123;</span><br><span class="line">        register_filesystem(&amp;au_fs_type);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit aufs_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">        unregister_filesystem(&amp;au_fs_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(aufs_init);</span><br><span class="line">module_exit(aufs_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行<code>make</code>,<code>insmod aufs.ko</code>,然后<code>cat /proc/filesystems  | grep aufs</code>就能看到aufs名列其中,说明我们的文件系统已经注册到了内核当中.接下来我们需要挂载文件系统,但是挂载的过程中会导致panic,应为我们还没有定义文件系统super_block的获取和释放函数.<br>挂载文件系统的时候依赖这两个函数,不然就会导致空指针.接下来我们定义文件系统的两个接口.”kill_sb”使用的是内核函数<code>kill_litter_super</code>,它会对super_block的内容进行释放.”get_sb”这个接口调用了”aufs_get_sb”函数,这个函数也是调用了内核函数<code>get_sb_nodev</code>,这个函数会创建对应的super_block,这个函数针对的是不依赖/dev的文件系统,如果依赖/dev的话,需要调用别的函数,另外会根据/dev对应的设备获取super_block(比如说ext4会读对应的被格式化后的块设备的头来实例化超级块).我们需要传入一个函数指针用于填充空白的super_block,就是”aufs_fill_super”,然而”aufs_fill_super”也调用了内核函数.</p>
<p>看一下具体代码.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int aufs_fill_super(struct super_block *sb, void *data, int silent)</span><br><span class="line">&#123;</span><br><span class="line">        struct inode *inode = NULL;</span><br><span class="line">        struct dentry *root;</span><br><span class="line">        int err;</span><br><span class="line"></span><br><span class="line">        sb-&gt;s_maxbytes          = MAX_LFS_FILESIZE;</span><br><span class="line">        sb-&gt;s_blocksize         = PAGE_CACHE_SIZE;</span><br><span class="line">        sb-&gt;s_blocksize_bits    = PAGE_CACHE_SHIFT;</span><br><span class="line">        sb-&gt;s_magic             = AUFS_MAGIC;</span><br><span class="line"></span><br><span class="line">        inode = new_inode(sb);</span><br><span class="line">        if (!inode) &#123; </span><br><span class="line">                err = -ENOMEM;</span><br><span class="line">                goto fail;</span><br><span class="line">        &#125;</span><br><span class="line">        inode-&gt;i_mode = 0755;</span><br><span class="line">        inode-&gt;i_uid = current_fsuid();</span><br><span class="line">        inode-&gt;i_gid = current_fsgid(); </span><br><span class="line">        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">        inode-&gt;i_mode |= S_IFDIR;</span><br><span class="line">        inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line">        inode-&gt;i_op = &amp;simple_dir_inode_operations;</span><br><span class="line">        // inc reference count for &quot;.&quot;.</span><br><span class="line">        inc_nlink(inode);</span><br><span class="line"></span><br><span class="line">        root = d_alloc_root(inode);</span><br><span class="line">        sb-&gt;s_root = root;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">                err = -ENOMEM;</span><br><span class="line">                goto fail;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">fail:</span><br><span class="line">        return err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了填充super_block,需要初始化sb以及创建根目录的inode和dentry.<code>s_blocksize</code>指定了文件系统的块大小,一般是一个<code>PAGE_SIZE</code>的大小,这里的<code>PAGE_CACHE_SIZE</code>和<code>PAGE_SIZE</code>是一样的,<code>PAGE_CACHE_SIZE_SHIFT</code>是对应的位数,所以<br><code>s_blocksize_bits</code>是块大小的bit位位数. 接着是inode初始化,<code>new_inode</code>为sb创建一个关联的<code>inode</code>结构体,并对<code>inode</code>初始化,包括<code>uid</code>,<code>gid</code>,<code>i_mode</code>.对应的<code>i_fop</code>和<code>i_op</code>使用了内核默认的接口<code>simple_dir(_inode)_operations</code>,后面会仔细讨论,这里先加上方便展示代码,如果对应的接口未定义的话,初始化的时候文件系统根目录会出现不会被认作目录的情况.</p>
<p>接下来安装模块,然后挂载文件系统,<code>mount -t aufs none tmp</code>,因为我们的文件系统没有对应的设备类型所以参数会填none,对应的目录是tmp,这样tmp就成为了aufs的根目录,如果ls一把tmp,里面是什么都没有的,我们<code>cd tmp &amp;&amp; touch x</code>返回的结果是不被允许,因为我们还没有定义对应的接口,不能创建文件.</p>
<p>我们继续,我们让这个文件系统可以创建目录,那我们需要定义目录inode的接口,一组<code>inode_operations</code>和一组<code>file_operations</code>.以下是实现.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static struct inode *aufs_get_inode(struct super_block *sb, int mode, dev_t dev)</span><br><span class="line">&#123;</span><br><span class="line">        struct inode *inode = new_inode(sb);</span><br><span class="line">        if (inode) &#123;</span><br><span class="line">                inode-&gt;i_mode = mode;</span><br><span class="line">                inode-&gt;i_uid = current_fsuid();</span><br><span class="line">                inode-&gt;i_gid = current_fsgid(); </span><br><span class="line">                inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">                switch (mode &amp; S_IFMT) &#123;</span><br><span class="line">                case S_IFDIR:</span><br><span class="line">                        // TODO:</span><br><span class="line">                        inode-&gt;i_op = &amp;aufs_dir_inode_operations;</span><br><span class="line">                        inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line">                        /* i_nlink = 2 */</span><br><span class="line">                        inc_nlink(inode);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">aufs_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)</span><br><span class="line">&#123;</span><br><span class="line">        struct inode *inode = aufs_get_inode(dir-&gt;i_sb, mode, dev);</span><br><span class="line">        int error = -ENOSPC;</span><br><span class="line">        if (inode) &#123;</span><br><span class="line">                // inherits gid.</span><br><span class="line">                if (dir-&gt;i_mode &amp; S_ISGID) &#123;</span><br><span class="line">                        inode-&gt;i_gid = dir-&gt;i_gid;</span><br><span class="line">                        if (S_ISDIR(mode)) inode-&gt;i_mode |= S_ISGID;</span><br><span class="line">                &#125;</span><br><span class="line">                d_instantiate(dentry, inode);</span><br><span class="line">                // get dentry reference count.</span><br><span class="line">                dget(dentry);</span><br><span class="line">                error = 0;</span><br><span class="line">                dir-&gt;i_mtime = dir-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">        &#125;</span><br><span class="line">        return error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">aufs_mkdir(struct inode *dir, struct dentry *dentry, int mode)</span><br><span class="line">&#123;</span><br><span class="line">        int reval;</span><br><span class="line">        retval = aufs_mknod(dir, dentry, mode | S_IFDIR, 0);</span><br><span class="line">        printk(&quot;aufs: mkdir&quot;);</span><br><span class="line">        if (!retval)</span><br><span class="line">                inc_nlink(dir); // .</span><br><span class="line">        return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">aufs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)</span><br><span class="line">&#123;</span><br><span class="line">        return aufs_mknod(dir, dentry, mode | S_IFREG, 0);</span><br><span class="line">&#125;</span><br><span class="line">static const struct inode_operations aufs_dir_inode_operations = &#123;</span><br><span class="line">        .create         = aufs_create,</span><br><span class="line">        .lookup         = simple_lookup, // get dentry.</span><br><span class="line">        .link           = simple_link, // same inode, different dentry.</span><br><span class="line">        .unlink         = simple_unlink,</span><br><span class="line">        .symlink        = aufs_symlink, // 之后再讲,目前没有做mapping会panic.</span><br><span class="line">        .mkdir          = aufs_mkdir,</span><br><span class="line">        .rmdir          = simple_rmdir,</span><br><span class="line">        .mknod          = aufs_mknod,</span><br><span class="line">        .rename         = simple_rename, // exchange dentry and dir.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实很简单,aufs_get_inode只创建目录类型的inode,并且赋值对应的函数指针.<code>file_operations</code>使用的默认接口,这个后面再提,<code>inode_operations</code>主要是inode的创建,aufs_create和aufs_mkdir都是对aufs_mknod针对不同mode的封装,aufs_symlink暂时不讲,因为inode还没有做mapping,软链的时候不可写会导致panic.进行上面类似的编译和挂载以后我们就能创建简单文件和目录了,但是创建的文件不能做任何操作,因为我们没有定义对应的接口.</p>
<p>挑个接口说一下,比如link接口就是创建了一个dentry指向了同一个inode,并且增加inode的引用计数,unlink就是把dentry删掉,inode保留.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int simple_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)                                </span><br><span class="line">&#123;                                </span><br><span class="line">        struct inode *inode = old_dentry-&gt;d_inode;                                </span><br><span class="line">                                </span><br><span class="line">        inode-&gt;i_ctime = dir-&gt;i_ctime = dir-&gt;i_mtime = CURRENT_TIME;                                </span><br><span class="line">        inc_nlink(inode);                                </span><br><span class="line">        atomic_inc(&amp;inode-&gt;i_count);                                </span><br><span class="line">        dget(dentry);                                </span><br><span class="line">        d_instantiate(dentry, inode);                                </span><br><span class="line">        return 0;                                </span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>
<p>软链有点复杂,所以放到后面讲.</p>
<p>当我们能够完成目录和文件的创建和删除之后,我们可以继续文件的读写了,换句话说我们要定义普通文件的inode的<code>file_operations</code>接口.<br>为了能够添加文件我们增加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static const struct address_space_operations aufs_aops = &#123;</span><br><span class="line">        .readpage       = simple_readpage,</span><br><span class="line">        .write_begin    = simple_write_begin,</span><br><span class="line">        .write_end      = simple_write_end,</span><br><span class="line">        /* .set_page_dirty = __set_page_dirty_no_writeback, 内核私有函数 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct file_operations aufs_file_operations = &#123;</span><br><span class="line">        .read           = do_sync_read,                                // file read get mapping page and copy to userspace.                                 </span><br><span class="line">        .aio_read       = generic_file_aio_read,</span><br><span class="line">        .write          = do_sync_write,</span><br><span class="line">        .aio_write      = generic_file_aio_write,</span><br><span class="line">        .mmap           = generic_file_mmap,</span><br><span class="line">        .fsync          = simple_sync_file,</span><br><span class="line">        .splice_read    = generic_file_splice_read,</span><br><span class="line">        .splice_write   = generic_file_splice_write,</span><br><span class="line">        .llseek         = generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct inode_operations aufs_file_inode_operations = &#123;</span><br><span class="line">        .getattr        = simple_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>并把aufs_get_inode改成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static struct inode *aufs_get_inode(struct super_block *sb, int mode, dev_t dev)</span><br><span class="line">&#123;</span><br><span class="line">        struct inode *inode = new_inode(sb);</span><br><span class="line">        if (inode) &#123;</span><br><span class="line">                inode-&gt;i_mode = mode;</span><br><span class="line">                inode-&gt;i_uid = current_fsuid();</span><br><span class="line">                inode-&gt;i_gid = current_fsgid();</span><br><span class="line">                inode-&gt;i_mapping-&gt;a_ops = &amp;aufs_aops;</span><br><span class="line">                mapping_set_gfp_mask(inode-&gt;i_mapping, GFP_HIGHUSER);</span><br><span class="line">                mapping_set_unevictable(inode-&gt;i_mapping);</span><br><span class="line">                inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">                switch (mode &amp; S_IFMT) &#123;</span><br><span class="line">                        default:</span><br><span class="line">                                init_special_inode(inode, mode, dev);</span><br><span class="line">                                break;</span><br><span class="line">                        case S_IFDIR:</span><br><span class="line">                                inode-&gt;i_op = &amp;aufs_dir_inode_operations;</span><br><span class="line">                                inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line">                                /* i_nlink = 2 for &quot;.&quot; */</span><br><span class="line">                                inc_nlink(inode);</span><br><span class="line">                                break;</span><br><span class="line">                        case S_IFREG:</span><br><span class="line">                                inode-&gt;i_op = &amp;aufs_file_inode_operations;</span><br><span class="line">                                inode-&gt;i_fop = &amp;aufs_file_operations;</span><br><span class="line">                                break;</span><br><span class="line">                        case S_IFLNK:</span><br><span class="line">                                inode-&gt;i_op = &amp;page_symlink_inode_operations;</span><br><span class="line">                                break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样以后我们就能对文件进行读写了,实际上文件的读写首先要依赖于mmap操作,把对应的页映射到虚拟内存当中来进行读写.编译并添加模块再挂载以后我们发现touch的文件可以读写了.<br>现在具体举一段代码路径分析一下,从read开始.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)                                </span><br><span class="line">&#123;                                </span><br><span class="line">        struct iovec iov = &#123; .iov_base = buf, .iov_len = len &#125;;                                </span><br><span class="line">        struct kiocb kiocb;                                </span><br><span class="line">        ssize_t ret;                                </span><br><span class="line">                                </span><br><span class="line">        init_sync_kiocb(&amp;kiocb, filp);                                </span><br><span class="line">        kiocb.ki_pos = *ppos;                                </span><br><span class="line">        kiocb.ki_left = len;                                </span><br><span class="line">                                </span><br><span class="line">        for (;;) &#123;                                </span><br><span class="line">                ret = filp-&gt;f_op-&gt;aio_read(&amp;kiocb, &amp;iov, 1, kiocb.ki_pos);                                </span><br><span class="line">                if (ret != -EIOCBRETRY)                                </span><br><span class="line">                        break;                                </span><br><span class="line">                wait_on_retry_sync_kiocb(&amp;kiocb);                                </span><br><span class="line">        &#125;                                </span><br><span class="line">                                </span><br><span class="line">        if (-EIOCBQUEUED == ret)                                </span><br><span class="line">                ret = wait_on_sync_kiocb(&amp;kiocb);                                </span><br><span class="line">        *ppos = kiocb.ki_pos;                                </span><br><span class="line">        return ret;                                </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>read其实还是依赖了aio_read的接口,只不过加上了wait的部分,保证同步,<code>kiocb</code>是”kernel I/O control block”记录I/O的信息,这里标记了偏移和剩余量.<br>再看aio_read的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssize_t</span><br><span class="line">generic_file_aio_read(struct kiocb *iocb, const struct iovec *iov,</span><br><span class="line">                unsigned long nr_segs, loff_t pos)</span><br><span class="line">&#123;</span><br><span class="line">        struct file *filp = iocb-&gt;ki_filp;</span><br><span class="line">        ssize_t retval;</span><br><span class="line">        unsigned long seg;</span><br><span class="line">        size_t count;</span><br><span class="line">        loff_t *ppos = &amp;iocb-&gt;ki_pos;</span><br><span class="line"></span><br><span class="line">        count = 0;</span><br><span class="line">        retval = generic_segment_checks(iov, &amp;nr_segs, &amp;count, VERIFY_WRITE);</span><br><span class="line">        if (retval)</span><br><span class="line">                return retval;</span><br><span class="line"></span><br><span class="line">        /* coalesce the iovecs and go direct-to-BIO for O_DIRECT */</span><br><span class="line">        if (filp-&gt;f_flags &amp; O_DIRECT) &#123;</span><br><span class="line">                loff_t size;</span><br><span class="line">                struct address_space *mapping;</span><br><span class="line">                struct inode *inode;</span><br><span class="line"></span><br><span class="line">                mapping = filp-&gt;f_mapping;</span><br><span class="line">                inode = mapping-&gt;host;</span><br><span class="line">                if (!count)</span><br><span class="line">                        goto out; /* skip atime */</span><br><span class="line">                size = i_size_read(inode);</span><br><span class="line">                if (pos &lt; size) &#123;</span><br><span class="line">                        retval = filemap_write_and_wait_range(mapping, pos,</span><br><span class="line">                                        pos + iov_length(iov, nr_segs) - 1);</span><br><span class="line">                        if (!retval) &#123;</span><br><span class="line">                                retval = mapping-&gt;a_ops-&gt;direct_IO(READ, iocb,</span><br><span class="line">                                                        iov, pos, nr_segs);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (retval &gt; 0)</span><br><span class="line">                                *ppos = pos + retval;</span><br><span class="line">                        if (retval) &#123;</span><br><span class="line">                                file_accessed(filp);</span><br><span class="line">                                goto out;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (seg = 0; seg &lt; nr_segs; seg++) &#123;</span><br><span class="line">                read_descriptor_t desc;</span><br><span class="line"></span><br><span class="line">                desc.written = 0;</span><br><span class="line">                desc.arg.buf = iov[seg].iov_base;</span><br><span class="line">                desc.count = iov[seg].iov_len;</span><br><span class="line">                if (desc.count == 0)</span><br><span class="line">                        continue;</span><br><span class="line">                desc.error = 0;</span><br><span class="line">                do_generic_file_read(filp, ppos, &amp;desc, file_read_actor);</span><br><span class="line">                retval += desc.written;</span><br><span class="line">                if (desc.error) &#123;</span><br><span class="line">                        retval = retval ?: desc.error;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (desc.count &gt; 0)</span><br><span class="line">                        break;</span><br><span class="line">        &#125;</span><br><span class="line">out:</span><br><span class="line">        return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>struct iovec</code>是一个数组每个元素是一段数据的开始和长度,这个结构和后面的io有关.<br>如果是不是DIRECT_IO的话,就会把iovector组装成<code>read_descriptor_t</code>传入<code>do_generic_file_read</code>当中.<code>do_generic_file_read</code>的读的具体过程是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct address_space *mapping = filp-&gt;f_mapping;</span><br><span class="line">...</span><br><span class="line">for &#123;</span><br><span class="line">index = *ppos &gt;&gt; PAGE_CACHE_SHIFT; // 循环读取ppos,ppos每次都会更新,然后右移,相当于模一个页的大小,找到以页偏移的单位.</span><br><span class="line">find_get_page(mapping,index); // 获取对应的page引用.</span><br><span class="line">mapping-&gt;a_ops-&gt;readpage(filp, page); // 读取对应的页.</span><br><span class="line">...</span><br><span class="line">page_cache_release(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般是通过mapping获取页缓存中的页并且读到用户空间中,在完成之后释放引用.读页的函数就是把page缓存刷掉.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int simple_readpage(struct file *file, struct page *page)                                 </span><br><span class="line">&#123;                                </span><br><span class="line">        clear_highpage(page);                                                             </span><br><span class="line">        flush_dcache_page(page);                                </span><br><span class="line">        SetPageUptodate(page);                                </span><br><span class="line">        unlock_page(page);                                      </span><br><span class="line">        return 0;                                             </span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>
<p>获取页是通过mapping的radix_tree来找到对应的page引用.<br>写的过程也类似,同步写也调用了异步写的接口,最后把用户空间的数据拷贝到页当中.<code>address_space_operations</code>就是对应vma映射的接口.</p>
<p>其中page &lt;-&gt; virtual_address的转换依赖于 kmap把页转换成虚拟地址或者逻辑地址,然后对应的读写操作最后都变成读写虚拟内存,或者逻辑内存.</p>
<p>单就构造一个文件系统来说,目的已经达到了,但是凡事不能不求甚解,下一篇博客准备记录一下内存管理相关的内容.</p>
<ol>
<li> 《Linux 内核探秘》<a target="_blank" rel="noopener" href="http://book.douban.com/subject/25817503/">http://book.douban.com/subject/25817503/</a></li>
<li> ramfs目录 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/fs/ramfs/">http://lxr.free-electrons.com/source/fs/ramfs/</a></li>
<li> 内核模块编程教程 <a target="_blank" rel="noopener" href="http://www.tldp.org/LDP/lkmpg/2.6/html/">http://www.tldp.org/LDP/lkmpg/2.6/html/</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%85%E6%A0%B8/" rel="tag"># 内核</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/zh-CN/2015/12/22/VFS-%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84/" rel="prev" title="VFS- 内核是如何抽象文件系统的">
                  <i class="fa fa-angle-left"></i> VFS- 内核是如何抽象文件系统的
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/zh-CN/2016/02/09/timer%E5%9C%A8go%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E7%B2%BE%E7%A1%AE/" rel="next" title="timer 在 Golang 中可以有多精确？">
                  timer 在 Golang 中可以有多精确？ <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2014 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ggaaooppeenngg</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  



  <script src="/js/third-party/fancybox.js"></script>



  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"ggaaooppeenngg","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
